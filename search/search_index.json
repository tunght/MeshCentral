{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MeshCentral Documentation \u00b6 About \u00b6 MeshCentral is a full computer management web site. With MeshCentral, you can run your own web server to remotely manage and control computers on a local network or anywhere on the internet. Once you get the server started, create device group and download and install an agent on each computer you want to manage. A minute later, the new computer will show up on the web site and you can take control of it. MeshCentral includes full web-based remote desktop, terminal and file management capability. To try out this software on the public server, please visit MeshCentral.com/login . Be mindful that the public MeshCentral server comes with no guaranties, most should setup their own server. For more information, visit MeshCentral.com . Social Media \u00b6 YouTube Reddit Twitter BlogSpot Documentation \u00b6 The User's Guide contains information every adminstrator should know including usage, the server configuration file, databases, TLS offloading, Lets Encrypt, IP Filtering, Email setup, embedding, server port aliasing, reverse proxy setup, multi factor authentication, branding & terms of use, HashiCorp Vault support, and SSO. The Installation Guide has detailed instructions for installing the MeshCentral Server on Windows 8.1, Windows 10, Windows 2012 R2, Amazon Linux 2, Raspberry Pi, Microsoft Azure, Google Cloud, Ubuntu 18, Ubuntu 16 and OpenBSD. The Design and Architecture Guide is a short document that includes information on the design overview, dependencies, source code descriptions of each file, certificates, TLS security, the agent to server handshake, browser to agent relay and WebRTC and the messenger service. Video Tutorials \u00b6 You can watch many tutorial videos on the MeshCentral YouTube Channel . Two videos to get started involve installation and basic usages. Installing MeshCentral on Windows, Linux and macOS. MeshCentral - Installation Basic Usages including installing the agent and remote desktop, terminal and file access. MeshCentral - Basics MeshCentral support for two-factor authentication. MeshCentral - Two Factor Authentication How to setup MeshCentral with the NGINX reverse proxy. MeshCentral - NGINX Reverse Proxy Installing and using the MeshCentral Android agent. MeshCentral - Android Using MeshCentral Router to port map TCP connections. MeshCentral - Basics Feedback \u00b6 If you encounter a problem or have a suggestion to improve the product, you may file an issue report If you are filing a problem report, you should include: The version of the software you are using The Operating System and version The observed output The expected output Any troubleshooting you took to resolve the issue yourself Any other similar reports~~ If you are having issues with the following other products, you should file a report on their respective issue pages MeshAgent MeshRouter License This software is licensed under Apache 2.0 .","title":"Home"},{"location":"#meshcentral-documentation","text":"","title":"MeshCentral Documentation"},{"location":"#about","text":"MeshCentral is a full computer management web site. With MeshCentral, you can run your own web server to remotely manage and control computers on a local network or anywhere on the internet. Once you get the server started, create device group and download and install an agent on each computer you want to manage. A minute later, the new computer will show up on the web site and you can take control of it. MeshCentral includes full web-based remote desktop, terminal and file management capability. To try out this software on the public server, please visit MeshCentral.com/login . Be mindful that the public MeshCentral server comes with no guaranties, most should setup their own server. For more information, visit MeshCentral.com .","title":"About"},{"location":"#social-media","text":"YouTube Reddit Twitter BlogSpot","title":"Social Media"},{"location":"#documentation","text":"The User's Guide contains information every adminstrator should know including usage, the server configuration file, databases, TLS offloading, Lets Encrypt, IP Filtering, Email setup, embedding, server port aliasing, reverse proxy setup, multi factor authentication, branding & terms of use, HashiCorp Vault support, and SSO. The Installation Guide has detailed instructions for installing the MeshCentral Server on Windows 8.1, Windows 10, Windows 2012 R2, Amazon Linux 2, Raspberry Pi, Microsoft Azure, Google Cloud, Ubuntu 18, Ubuntu 16 and OpenBSD. The Design and Architecture Guide is a short document that includes information on the design overview, dependencies, source code descriptions of each file, certificates, TLS security, the agent to server handshake, browser to agent relay and WebRTC and the messenger service.","title":"Documentation"},{"location":"#video-tutorials","text":"You can watch many tutorial videos on the MeshCentral YouTube Channel . Two videos to get started involve installation and basic usages. Installing MeshCentral on Windows, Linux and macOS. MeshCentral - Installation Basic Usages including installing the agent and remote desktop, terminal and file access. MeshCentral - Basics MeshCentral support for two-factor authentication. MeshCentral - Two Factor Authentication How to setup MeshCentral with the NGINX reverse proxy. MeshCentral - NGINX Reverse Proxy Installing and using the MeshCentral Android agent. MeshCentral - Android Using MeshCentral Router to port map TCP connections. MeshCentral - Basics","title":"Video Tutorials"},{"location":"#feedback","text":"If you encounter a problem or have a suggestion to improve the product, you may file an issue report If you are filing a problem report, you should include: The version of the software you are using The Operating System and version The observed output The expected output Any troubleshooting you took to resolve the issue yourself Any other similar reports~~ If you are having issues with the following other products, you should file a report on their respective issue pages MeshAgent MeshRouter License This software is licensed under Apache 2.0 .","title":"Feedback"},{"location":"design/","text":"Design and Architecture \u00b6 Design and Architecture Guide as .pdf as .odt Video Walkthru \u00b6 Abstract \u00b6 This document attempts to describe the architecture and design of the second version of MeshCentral on which work started in late 2016. The document covers the overview of the design, goes in details about the protocol and various decisions and trade-offs. This document is intended for anyone that wants to understand the inner workings of MeshCentral or someone that wants to make a security review of the software. The software and added documentation and tutorial videos are available at: https://www.meshcommander.com/meshcentral2 Introduction \u00b6 MeshCentral is a free open source web-based remote computer management software. After over 8 years of working on the first version of MeshCentral, work as moved to version 2 which this document described. In 2010, when MeshCentral v1 was first designed, the Internet was very different. HTML5 and WebSocket did not exists, no such thing as a software container, etc. With MeshCentral version 2, a complete redesign was made to make the software much more in line with modern Internet deployment models. The advent of NodeJS, WebSocket, WebRTC and other web technologies coming out in the last 10 years has really made the design of MeshCentral v2 not only possible, but quite amazing. Being able to use a single programming language across platforms to JavaScript. Being able to easily exchange objects using web socket and JSON, being able to scale with WebRTC, deploy quickly with containers, etc. Looking back at the incredible advances in web technologies lead to an almost mandatory MeshCentral redesign. Goals & Requirements \u00b6 The goal of MeshCentral is to be the best open source remote management software in the world. Remote computer management is a big area with many different usages and requirements. To best suite this, it\u2019s important to have software that is as flexible as possible. Additionally, there are many other goals: Must be quick and easy to install. Must install on all major operating systems and platforms. Can be deployed on small computers and the cloud. Can be deployed within containers. Can be deployed in many network environments. Must support both software agent and Intel\u00ae AMT hardware agent. Must only use open source dependencies. Must provide all basic remote management features (desktop, terminal, files\u2026) Must use the network efficiently. Must have a real time user interface. Must be easy to use. Must be fast. Etc. Basically, all the requirements you would expect from open source software that can go viral. Since this software is sponsored by Intel, it\u2019s going to support Intel\u00ae AMT really well, making it possible to manage a remote computer regardless of its OS or power state. Intel\u00ae AMT is not required to use this software, however it\u2019s a great fit. Design Overview \u00b6 In this section, we do a very high level overview of MeshCentral\u2019s design. MeshCentral has 3 big components: the server, the agent and the web application. There is of course more software that support these 3 components like the Windows Server Installer, ClickOnce application, MeshCentral Discovery Tool and more. These will be covered later. Most of the document will focus on these 3 main components. Another component that is significant but not part of the software itself is Intel\u00ae AMT (Intel\u00ae Active Management Technology). MeshCentral supports Intel AMT that acts like an optional hardware based agent for MeshCentral. When it comes to programming languages used, MeshCentral is mostly built with JavaScript with the agent having significant portable C code. This makes things pretty simple since the browser, server and agents can share some of the code. More importantly, JavaScript is great at parsing JSON and so, the main protocol used between the components is JSON over Web Socket. It\u2019s important to note that while JavaScript is used in all 3 components, the JavaScript runtime is very different. The JavaScript written to run within a browser sandbox uses different calls than the one running in NodeJS on the server or on the agent with DukTape. This is probably a good time to introduce DukTape (https://www.duktape.org/) . Unlike the browser and NodeJS JavaScript engines, DukTape is a less known JavaScript runtime written in C. The agent is built in C code with little smarts other than being able to securely connect back to the server. The server then pushes to the agent a JavaScript file that the agent runs. This makes the agent very flexible since a developers can quickly change the JavaScript that is pushed to the agent and change the agent\u2019s behavior instantly. Another interesting design decision is that MeshCentral makes almost no use of RESTful API\u2019s. Instead, almost everything is done using WebSocket. This allows JSON objects to be exchanged fully asynchronously. There is no pushing the refresh button or polling as events are sent by all actors in real time. MeshCentral server \u00b6 The MeshCentral server is a NodeJS application that is published on NPM at: https://www.npmjs.com/package/meshcentral Many administrators can get started quickly using \u201cnpm install meshcentral\u201d once NodeJS is installed. MeshCentral will work on Node 6.x and higher. Dependencies \u00b6 The server makes use of the following dependencies on NPM. These are all automatically installed by NPM when installing MeshCentral. Can be found in the file: MeshCentralServer.njsproj The main takeaway is that MeshCentral is mostly an ExpressJS application. This is not a complete list of dependencies as many of these packages have their own dependencies creating a large tree. The security of these packages is a concern and all of the dependency tree is a concern. In addition to the dependencies that are \u201chard coded\u201d, there are a few more that are installed only when needed. These are: node-windows \u00b6 greenlock, le-store-certbot, le-challenge-fs : Installed on all Windows install. Allows background service install: le-acme-core : Installed only when Let\u2019s Encrypt must be used: mongojs : Installed when MongoDB is in used. nodemailer : Installed when SMTP server support is in used. MeshCentral will run npm install automatically when any of these optional modules are needed but not currently available. Understanding the different modes: LAN, WAN and Hybrid \u00b6 Code files and folders \u00b6 Someone would think the server is rather simple when taking a look at the MeshCentral server code files. At a high level, the entire server has 3 folders, 3 text files and a manageable number of .js files that are fairly self-descriptive. Here is a list of the source files and folders. Folders \u00b6 agents : Compiled agents, install scripts, tools and agent JavaScript. public : Static web elements such as images, CSS, HTML and more. views : Main web application, login screen and messenger app. Configuration & text files \u00b6 package.json : Description of the MeshCentral package on NPM. sample-config.json : A sample \u201cconfig.json\u201d file to get started. readme.txt : Readme file published with the MeshCentral package. Code files \u00b6 amtevents.js | Used to scan a local network for Intel AMT machines. amtscanner.js | Used to run Intel AMT scripts from MeshCommander. amtscript.js | Used to generate and perform certificate operations. certoperations.js | Various commonly used methods. common.js | Used to access the MongoDB or NeDB database. db.js | Used to modify windows executables. exeHandler.js | Used to insert credentials in an HTTP stream. interceptor.js | Used to obtain and use a Let\u2019s Encrypt certificate. letsencrypt.js | Used to offload RSA sign to other CPU cores. meshaccelerator.js | Used to communicate to agents. meshagent.js | The is the main module, gets the server started. meshcentral.js | Used to send SMTP mails. meshmail.js | Used to relay agent and browser web socket connections. meshrelay.js | MeshCentral server discovery when in LAN mode. meshscanner.js | Used to communicate with browsers. meshuser.js | Used to communicate to Intel\u00ae AMT CIRA. mpsserver.js | Used for server-to-server communication. multiserver.js | Performs password hash + salt. pass.js | Used to handle HTTP traffic. redirserver.js | Used to upgrade legacy MeshCentralv1 agents. swarmserver.js | Handles HTTPS traffic. webserver.js | Server background install on Windows. winservice.js | Server background install on Windows. At a high level, the MeshCentral.js file will get the server started. By default, it will start the webserver.js on port 443, redirectserver.js on port 80 and mpssrver.js on port 4433. The webserver.js file will create a meshuser.js or meshagent.js instance each time a user or agent connects. The other files support various usages, but this is the basic working on the server. Server database \u00b6 One of the big design decision on the server is its database. We want something that scales and so, opted to deal with the good and the bad of a NoSQL database, MongoDB. On the other hand, we want the server to be really simple to install for people who want to try it out or want to manage 100 computers or less. We don\u2019t want the added learning curve of MongoDB for people that don\u2019t really need it. It turned out, we can have both. NeDB is a NPM package that provides a simple MongoDB-like API while being completely implemented in NodeJS. For most people, this is plenty good to get started. By default, MeshCentral will just create and use a NeDB database, but can be configured to use MongoDB. The internal code path for both databases are almost exactly identical so the \u201cdb.js\u201d file handles both, almost the same way and the exact database in use is completely abstracted from the rest of the server code. Certificates \u00b6 MeshCentral makes use of many certificates to accomplish many security tasks. When first running the server or an agent, both of these actors will generate certificates. The agent will generate one or two certificates on the first run and the server will generate four certificates. In this section we review what certificates are created, what are their uses and how they are stored. Most administrators using MeshCentral will not need a deep understanding of this section to run the server, however, a basic understanding of this section can help understand how to best protect the server\u2019s critical security assets. Server Certificates \u00b6 As indicated above, the MeshCentral server creates four certificates when it first runs. It uses ForgeJS to perform certificate creation and all four certificates below are saved in the \u201cmeshcentral-data\u201d folder. The four certificates are: Server root \u00b6 root-cert-public.crt This is a self-signed root certificate that is used only to issue the 3 next certificates. This certificate can be useful when it\u2019s installed as a root of trust in some situations. For example, when Intel AMT connects to the MPS server on port 4433, it will correctly connect only if this root certificate is loaded into Intel AMT as a trusted certificate. Browser can also be setup to trust this root certificate in order to create a trusted connection between a browser and the servers HTTPS port. This certificate is RSA3072 unless the option \u201c--fastcert\" is used, in that case a RSA2048 certificate is generated. MPS certificate \u00b6 mpsserver-cert-public.crt This is a TLS certificate signed by the root above used as a TLS server certificate on the MPS port 4433. Intel AMT computers will connect to this port and verify the certificate time, common name and that it\u2019s signed by the root above. This certificate is not typically changed, even when the server is running in production. This certificate is always generated as RSA2048 because older Intel AMT firmware will not accept certificates with larger keys. Web certificate \u00b6 webserver-cert-public.crt This is the default certificate used to secure the HTTPS port 443. It is signed by the root above and is the certificate users will first see then connecting the browser to the server. Often, users will need to ignore the browser security warning. This certificate is RSA3072 unless the option \u201c--fastcert\" is used, in that case a RSA2048 certificate is generated. In production environments, this certificate is replaced with a real certificate. There are many ways to change this certificate for a more appropriate certificate in production environments: You can replace the \u201cwebserver-cert-*\u201d files in the \u201cmeshcentral-data\u201d folder. You can use Let\u2019s Encrypt which will override this certificate automatically. You can use a reverse-proxy in front of the server with \u201c--tlsoffload\". Agent certificate \u00b6 agentserver-cert-public.crt This certificate is used to authenticate the server to agents. It\u2019s signed by the root above and when installing an agent, the hash of this certificate is given to the agent so that it can connect back to the server securely. This certificate is RSA3072 unless the option \u201c--fastcert\" is used, in that case a RSA2048 certificate is generated. The \u201cmeshcentral-data\u201d folder contains critical server information including private keys therefore, it\u2019s important that it be well protected. It\u2019s important to backup the \u201cmeshcentral-data\u201d folder and keep the backup in a secure place. If, for example the \u201cagent certificate\u201d on the server is lost, there is no hope for agents ever be able to connect back to this server. All agents will need to be re-installed with a new trusted certificate. If someone re-installs a server, placing the \u201cmeshcentral-data\u201d folder back with these certificates should allow the server to resume normal operations and accept connections for Intel AMT and agents as before. Agent Certificates \u00b6 The mesh agent generates one or two RSA certificates when it first starts. On smaller IoT devices such as a Raspberry Pi, this can take a little while to do and the CPU will spike to 100% during this time. This is normal and only occurs the first time the agent runs. The certificates are generated a little differently depending on the platform. On Windows, the Mesh Agent will use Microsoft cryptographic providers to harder the agent root cert. If available, the agent will use the platform TPM to harden the certificate. On other platforms, only one certificate is generated and used for both agent authentication to the server and WebRTC session authentication. Agent root certificate \u00b6 This certificate is the root trust of the agent. The SHA384 hash of this certificates public key is the agent\u2019s identifier on the server. When a agent connects to the server using web socket, it performs a secondary authentication check using this certificate. The server will compute the agent\u2019s identifier after the agent sent a signed proof to the server. This certificate is also used to sign the secondary certificate below when it\u2019s needed. Secondary certificate \u00b6 This is a certificate signed by the agent root above. It\u2019s currently only used by WebRTC to perform dTLS authentication to a remote browser. This certificate does not need to be signed by a trusted CA for WebRTC purposes since the hash of the certificate will be sent to the browser using a trusted path. If the agent root certificate is not hardened using platform cryptography, the secondary certificate is not created and the agent root cert is used for all purposes. A possible attack would occur if someone were to be able to access the agent root certificate. They could impersonate the agent to the server. Agents don\u2019t have any rights to perform management operations on the server or other agents, but by impersonating a agent, a rogue agent would pretend to be an office computer to which administrator would login with their username & password, especially when the root is not hardened. Some care should be taken to protect the \u201cmeshagent.db\u201d file and to not give important information to untrusted agents. TLS Security \u00b6 MeshCentral makes heavy use of Transport Layer Security (TLS) and datagram-TLS (dTLS) to authenticate and encrypt network traffic between the browser, server and agent. Configuring TLS settings correctly is essential to making sure communications are secure and to minimize attacks on open ports. Probably the most important TLS configuration is for the MeshCentral server ports 443 and 4433. These two ports are exposed to the Internet and so, should be setup as securely as possible. MeshCentral HTTPS port 443 \u00b6 The HTTPS port on the MeshCentral server will only support TLS 1.2 and above, and makes use of only 6 cypher suites: TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_GCM\\_SHA384 (0xc030) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA384 (0xc028) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA (0xc014) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_GCM\\_SHA256 (0xc02f) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA256 (0xc027) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA (0xc013) Note that these cipher suites are all perfect forward secrecy (PFS) suites and are considered cryptographically secure as of the writing of this document. When the server is deployed on the Internet, https://ssllabs.com gives the server an A rating with no known vulnerabilities and no weak ciphers detected. SSL Labs confirms that all major browsers should be able to connect correctly to this server. MeshCentral MPS port 4433 \u00b6 The Manageability Presence Server (MPS) port 4433 is used for incoming Intel AMT CIRA connections. By default it uses a TLS certificate that is signed by a self-signed root certificates. This port is not intended to be connected to by typical browsers, only Intel AMT should connect to this port. Note that the TLS certificate generated by MeshCentral for port 4433 is RSA 2048bits, this is because older Intel AMT firmware don\u2019t support RSA 3072. Because the port is not secured using a trusted certificate, SSL Labs will not rate the security of this server. This is fully expected. Note that SSL Labs will not test servers that are not on port 443. To perform a test like this MeshCentral must be set temporarily with the MPS port set to 443 and the normal HTTPS port set to a different value. Because older Intel AMT computers that only support TLS 1.0 are common, the server supports TLS v1.0, v1.1 and v1.2 with the following 12 cipher suites: TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_GCM\\_SHA384 (0xc030) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA384 (0xc028) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA (0xc014) TLS\\_RSA\\_WITH\\_AES\\_256\\_GCM\\_SHA384 (0x9d) TLS\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA256 (0x3d) TLS\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA (0x35) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_GCM\\_SHA256 (0xc02f) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA256 (0xc027) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA (0xc013) TLS\\_RSA\\_WITH\\_AES\\_128\\_GCM\\_SHA256 (0x9c) TLS\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA256 (0x3c) TLS\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA (0x2f) The suites starting with \u201cTLS_RSA_\u201d don\u2019t have perfect forward secrecy (PFS) and so, are considered weak by SSL Labs. However, these are generally the suites that are supported by Intel AMT. Agent to server handshake \u00b6 One interesting aspect of MeshCentral\u2019s design is how the agent connects to the server. We wanted a way for the agent to connect to the server that would be similar to how browsers connect to web servers. This allows for a large number of agents to connect just like if a large number of browsers where connecting. All of the infrastructure that helps web server\u2019s scale would be put to use in the same way for agent connections. For example: TLS offload hardware, load balancers, reverse-proxies, web server scaling, etc. could all be put to use. It also makes the server easier to setup because only one port (HTTPS 443) is needed for both users and agents. One big difference between the agent connecting and a typical browser is how the server is authenticated. Browsers have a set of known trusted root certificates. The server\u2019s web certificate is checked for validity including the name, time trusted CA and more. The agent does not have this. Instead, it just has a hash to a private server certificate. The public facing web certificate of the server can change frequently. For example, Let\u2019s Encrypt certificates are valid 90 days. Agents need to be able to validate a specific server for a long time and don\u2019t really need to trust anything else except one specific server. We also don\u2019t want to tie the agents to a specific domain name as we could change that in the future or want to support servers with dynamic IP addresses and no fixed DNS names. To handle all this, the agent performs a TLS connection to the server and will first see the web certificate of the server. It will then exchange a set of web socket binary messages to the server to perform a secondary authentication with the server. The secondary check allows the agent to confirm that this server does own the private key of the private certificate expected by the agent. The agent caches the hash of the \u201couter\u201d web certificate. When re-connecting, if the agent sees the same outer web certificate, it will skip the secondary check. For obvious security raisons, it\u2019s important that the agent not accept any management messages until the secondary check is completed or skipped. To prevent man-in-the-middle attacks, the secondary check also \u201cpins\u201d the outer web certificate. That is, the server both confirms it\u2019s the right server and indicates to the agent the hash of the outer certificate that it must have seen during the TLS connection. The agent must check this hash to make sure there is no attacker in the middle. The agent connection design allows for reverse-proxies and TLS offload hardware. The agent will first connect a TLS session to the offload hardware. Clear traffic flows between the offload hardware and the server which will perform the secondary check if needed. To makes all this work, the MeshCentral server must be able to fetch the hash of the outer web certificate from the reverse proxy. In this case, the server does not need the private key to the web certificate. Note that when the outer web certificate is updated, the server may have to perform many secondary checks at the same time causing a server slowdown during this time. To help with this, MeshCentral will offload the RSA signing operation to many slave processes (as many as the CPU core count on the server) to speed this up. In addition, native NodeJS RSA signing is used (not ForgeJS). The details of the secondary certificate check look like the diagram below. To boost speed, the exchange is fully asynchronous and both sides send the first message as soon as the TLS connection completes. Note that these messages are binary (not JSON). The agent must be able to connect to the server independently of the JavaScript that is running in DukTape. So this exchange is handled by native C code in the agent. Binary message 1 is sent immediately after the TLS connection is setup. Both sides will send binary message 2 when message 1 is received and message 3 when message 2 is received. In addition, there are two extra messages of interest that can be sent by the agent right at the start. The agent may send the server message number 4 if the secondary check can be skipped and may send binary message number 5 indicating what server hash it expects to verify. Message number 5 is interesting because a server may have many \u201cidentities\u201d at the same time, and so, the server will use message number 5 in order to use the right Agent Server certificate. In order to be as secure as possible, all hashes use SHA384 and certificates are RSA3072 and nonces are generated on both sides using a cryptographic random source. The server and agent signatures are computed like this: While the server will often skip its RSA signature operation due to the agents caching the outer web certificate, the server must perform an RSA verify to each agent connection. This can\u2019t be skipped but is needed to authenticate the agent. Once connected, the trust relationship between the server and the agent is one-way. That is, the server has management rights on the agent, but the agent does not have any right on the server. This is important since the agent does not, by default, have any credentials to the server. Any agent can connect to the server and claim to be part of a device group. Browser to agent relay and WebRTC \u00b6 Browsers and agents often need to communicate to each other. Data sessions are used for desktop, terminal, file transfers, etc. and must be setup securely. To setup a session between a browser and the agent, the server will send a URL to both sides to connect to. The URL is generated by the server and includes a unique connection token. It is sent to both the browser and agent using the web socket control channel and a JSON message. Both sides perform a websocket connection to the target URL and the server will \u201cpipe\u201d both sessions together to act as a passive relay. For security, the agent will only accept connections to the URL given by the server if the server has the same outer web certificate as its control connection. Also note that in this mode, the session is not end-to-end encrypted. The server is performing a TLS decrypt and re-encrypt and the traffic cost is high as each byte of data has to be received and sent again. The relay server is just websocket server that will wait for connections with session tokens. When two connection with the same connection token arrive, the server makes sure that at least one of the two connections is an authenticated user, it then sends the character \u201cc\u201d on both sides to inform both parties that the relay is starting and then pipes both sessions together. Once the session is started, the browser and agent are free to send messages to each other. Note that when the server sends the relay URL to the agent, it also sends to the agent the user\u2019s permissions flags. This may be used by the agent to limit what the user can do on this session. With this design, the flow control between the browser and agent is simple, each session gets its own end-to-end connection and the server will apply appropriate TCP back pressure on both sides as needed. A unique feature of MeshCentral is its use of WebRTC. WebRTC was introduced in major browsers as a way to allow browsers to directly communicate to each other and perform audio/video streaming. The mesh agent has a WebRTC data-only stack that is custom built for this project in C code. It\u2019s compatible with Chrome and Firefox implementations and once a session is set up, allows data to flow directly from the browser to the agent, bypassing the server. The use of WebRTC allows MeshCentral to scale better, to offer a faster user experience and lower hosting costs all at the same time. However, WebRTC is not easy, especially when you must maintain the C code for it and have to keep up with browser implementations, but the benefits are clear. To setup WebRTC, browsers typically use STUN and TURN servers to get traffic thru any network obstacles (routers, proxies, firewalls). This infrastructure can be complex to setup especially if an administrator is not familiar with WebRTC concepts. To make things easy, MeshCentral opted to always start by using a websocket relay thru the server to get things started. While a session is active, the browser and agent will attempt to automatically switch the session traffic to WebRTC when possible. This way, the session always works and gets more efficient when network conditions allow. To perform the switch-over, both browser and agent will exchange WebRTC control messages over the newly established web socket relay session. In order to differentiate session traffic from WebRTC control traffic, the browser and agent agree to send WebRTC setup traffic using web socket text fragments. All other session traffic is sent using binary fragments. The agent has a special API allowing a session to be piped for a single fragment type. So we can perform a remote desktop session to the agent while trying to setup WebRTC at the same time. The browser will kick off the WebRTC setup sending the initial WebRTC offer with the agent responding with a WebRTC answer. If the WebRTC session gets setup, both sides need to negotiate a clear transition from the web socket session to the WebRTC session. To do this, both sides send a start switch control fragment (this is a text fragment), the other side will respond with an ACK when the web socket session is flushed out and it\u2019s safe to switch. On the agent side, the new WebRTC session inherits the user access rights of the web socket. Currently, the web socket channel is still maintained open. While it\u2019s not strickly needed, the web socket session terminates more cleanly than WebRTC and so, oddly its closure is used to signal the end of the WebRTC session. Messenger \u00b6 MeshCentral includes its own messaging web application it can be used to chat, transfer files and optionally used for audio and video chat. It\u2019s used to support two different usages: User-to-user and user-to-computer communication. In the first usage, two users that are connected to the same MeshCentral server at the same time can chat. If you are a MeshCentral administrator, you can see the list of currently logged in users and hit the chat button to launch a chat invitation. If accepted, the Messenger is open on both sides and the session starts. Alternatively, while managing a remote computer, an administrator can hit the chat button to cause the remote computer to open a web browser to the chat application. The chat app is standalone web application that is served by the MeshCentral server using a connection token and title in the URL. Once loaded in its own web frame, the messenger web application will get the connection token and title from the URL and proceed to connect to the URL using web socket. The same web socket relay that is used for browser-to-agent connections is also used in this case for browser-to-browser connections. The server relay acts the same and pipes both sessions together after sending the character \u201cc\u201d to both sides. At this point, the messenger application will show the remote user as connected and chat and file transfers can start. File transfers are just a set of binary messages sent over the web socket session with lots of JSON control messages. Once the web socket session is setup, the messenger application will then attempt to perform a switch over to WebRTC. Both web application start by selecting a random number (not cryptographic) and the highest number will initiate the WebRTC offer. The other party will answer and both sides will trade interface candidates as they are discovered. If successful, the web socket session are flushed and the traffic is switched over to WebRTC. Because the switchover is done cleanly, it can occur while in the middle of a file transfer without the file being corrupted. Finally, the web application will determine if the local computer is attached to a microphone and if it has a camera. If so, these options are offered in the chat window and audio/video chat is available for use. The chat app allows for one way setup of audio & video sessions. This is typically what is needed in support scenarios where the audio/video session is one-way. The messenger web application will setup a separate WebRTC connection for audio/video in each direction but the code is present to augment the WebRTC control channel with audio/video which is a bit more efficient but more testing is needed before defaulting to this mode. Additional Resources \u00b6 In addition to this document, there are a growing set of MeshCentral resources at: https://www.meshcommander.com/meshcentral2. This includes an Installer\u2019s documents, a User\u2019s Guide and plenty of YouTube tutorial videos. For developers, it\u2019s best to start on the MeshCentral GitHub repository at: https://github.com/Ylianst/MeshCentral . If any issues are found, it\u2019s best to create a new issue in GitHub or mail ylianst@gmail.com Conclusion \u00b6 MeshCentral is a free, open source and powerful remote management solution that is cross- platform. In this document, we have covered the goals, overview, design and some details of the software. It\u2019s hoped that this document will encourage developers to take a look at MeshCentral for more usages and review its security in detail. MeshCentral\u2019s use of modern web technologies make it a unique and amazing solution for remote management of computers. As with any good software, MeshCentral will continue to be updated and evolve. License \u00b6 MeshCentral and this document are both opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0","title":"Design and Architecture"},{"location":"design/#design-and-architecture","text":"Design and Architecture Guide as .pdf as .odt","title":"Design and Architecture"},{"location":"design/#video-walkthru","text":"","title":"Video Walkthru"},{"location":"design/#abstract","text":"This document attempts to describe the architecture and design of the second version of MeshCentral on which work started in late 2016. The document covers the overview of the design, goes in details about the protocol and various decisions and trade-offs. This document is intended for anyone that wants to understand the inner workings of MeshCentral or someone that wants to make a security review of the software. The software and added documentation and tutorial videos are available at: https://www.meshcommander.com/meshcentral2","title":"Abstract"},{"location":"design/#introduction","text":"MeshCentral is a free open source web-based remote computer management software. After over 8 years of working on the first version of MeshCentral, work as moved to version 2 which this document described. In 2010, when MeshCentral v1 was first designed, the Internet was very different. HTML5 and WebSocket did not exists, no such thing as a software container, etc. With MeshCentral version 2, a complete redesign was made to make the software much more in line with modern Internet deployment models. The advent of NodeJS, WebSocket, WebRTC and other web technologies coming out in the last 10 years has really made the design of MeshCentral v2 not only possible, but quite amazing. Being able to use a single programming language across platforms to JavaScript. Being able to easily exchange objects using web socket and JSON, being able to scale with WebRTC, deploy quickly with containers, etc. Looking back at the incredible advances in web technologies lead to an almost mandatory MeshCentral redesign.","title":"Introduction"},{"location":"design/#goals-requirements","text":"The goal of MeshCentral is to be the best open source remote management software in the world. Remote computer management is a big area with many different usages and requirements. To best suite this, it\u2019s important to have software that is as flexible as possible. Additionally, there are many other goals: Must be quick and easy to install. Must install on all major operating systems and platforms. Can be deployed on small computers and the cloud. Can be deployed within containers. Can be deployed in many network environments. Must support both software agent and Intel\u00ae AMT hardware agent. Must only use open source dependencies. Must provide all basic remote management features (desktop, terminal, files\u2026) Must use the network efficiently. Must have a real time user interface. Must be easy to use. Must be fast. Etc. Basically, all the requirements you would expect from open source software that can go viral. Since this software is sponsored by Intel, it\u2019s going to support Intel\u00ae AMT really well, making it possible to manage a remote computer regardless of its OS or power state. Intel\u00ae AMT is not required to use this software, however it\u2019s a great fit.","title":"Goals &amp; Requirements"},{"location":"design/#design-overview","text":"In this section, we do a very high level overview of MeshCentral\u2019s design. MeshCentral has 3 big components: the server, the agent and the web application. There is of course more software that support these 3 components like the Windows Server Installer, ClickOnce application, MeshCentral Discovery Tool and more. These will be covered later. Most of the document will focus on these 3 main components. Another component that is significant but not part of the software itself is Intel\u00ae AMT (Intel\u00ae Active Management Technology). MeshCentral supports Intel AMT that acts like an optional hardware based agent for MeshCentral. When it comes to programming languages used, MeshCentral is mostly built with JavaScript with the agent having significant portable C code. This makes things pretty simple since the browser, server and agents can share some of the code. More importantly, JavaScript is great at parsing JSON and so, the main protocol used between the components is JSON over Web Socket. It\u2019s important to note that while JavaScript is used in all 3 components, the JavaScript runtime is very different. The JavaScript written to run within a browser sandbox uses different calls than the one running in NodeJS on the server or on the agent with DukTape. This is probably a good time to introduce DukTape (https://www.duktape.org/) . Unlike the browser and NodeJS JavaScript engines, DukTape is a less known JavaScript runtime written in C. The agent is built in C code with little smarts other than being able to securely connect back to the server. The server then pushes to the agent a JavaScript file that the agent runs. This makes the agent very flexible since a developers can quickly change the JavaScript that is pushed to the agent and change the agent\u2019s behavior instantly. Another interesting design decision is that MeshCentral makes almost no use of RESTful API\u2019s. Instead, almost everything is done using WebSocket. This allows JSON objects to be exchanged fully asynchronously. There is no pushing the refresh button or polling as events are sent by all actors in real time.","title":"Design Overview"},{"location":"design/#meshcentral-server","text":"The MeshCentral server is a NodeJS application that is published on NPM at: https://www.npmjs.com/package/meshcentral Many administrators can get started quickly using \u201cnpm install meshcentral\u201d once NodeJS is installed. MeshCentral will work on Node 6.x and higher.","title":"MeshCentral server"},{"location":"design/#dependencies","text":"The server makes use of the following dependencies on NPM. These are all automatically installed by NPM when installing MeshCentral. Can be found in the file: MeshCentralServer.njsproj The main takeaway is that MeshCentral is mostly an ExpressJS application. This is not a complete list of dependencies as many of these packages have their own dependencies creating a large tree. The security of these packages is a concern and all of the dependency tree is a concern. In addition to the dependencies that are \u201chard coded\u201d, there are a few more that are installed only when needed. These are:","title":"Dependencies"},{"location":"design/#node-windows","text":"greenlock, le-store-certbot, le-challenge-fs : Installed on all Windows install. Allows background service install: le-acme-core : Installed only when Let\u2019s Encrypt must be used: mongojs : Installed when MongoDB is in used. nodemailer : Installed when SMTP server support is in used. MeshCentral will run npm install automatically when any of these optional modules are needed but not currently available.","title":"node-windows"},{"location":"design/#understanding-the-different-modes-lan-wan-and-hybrid","text":"","title":"Understanding the different modes: LAN, WAN and Hybrid"},{"location":"design/#code-files-and-folders","text":"Someone would think the server is rather simple when taking a look at the MeshCentral server code files. At a high level, the entire server has 3 folders, 3 text files and a manageable number of .js files that are fairly self-descriptive. Here is a list of the source files and folders.","title":"Code files and folders"},{"location":"design/#folders","text":"agents : Compiled agents, install scripts, tools and agent JavaScript. public : Static web elements such as images, CSS, HTML and more. views : Main web application, login screen and messenger app.","title":"Folders"},{"location":"design/#configuration-text-files","text":"package.json : Description of the MeshCentral package on NPM. sample-config.json : A sample \u201cconfig.json\u201d file to get started. readme.txt : Readme file published with the MeshCentral package.","title":"Configuration &amp; text files"},{"location":"design/#code-files","text":"amtevents.js | Used to scan a local network for Intel AMT machines. amtscanner.js | Used to run Intel AMT scripts from MeshCommander. amtscript.js | Used to generate and perform certificate operations. certoperations.js | Various commonly used methods. common.js | Used to access the MongoDB or NeDB database. db.js | Used to modify windows executables. exeHandler.js | Used to insert credentials in an HTTP stream. interceptor.js | Used to obtain and use a Let\u2019s Encrypt certificate. letsencrypt.js | Used to offload RSA sign to other CPU cores. meshaccelerator.js | Used to communicate to agents. meshagent.js | The is the main module, gets the server started. meshcentral.js | Used to send SMTP mails. meshmail.js | Used to relay agent and browser web socket connections. meshrelay.js | MeshCentral server discovery when in LAN mode. meshscanner.js | Used to communicate with browsers. meshuser.js | Used to communicate to Intel\u00ae AMT CIRA. mpsserver.js | Used for server-to-server communication. multiserver.js | Performs password hash + salt. pass.js | Used to handle HTTP traffic. redirserver.js | Used to upgrade legacy MeshCentralv1 agents. swarmserver.js | Handles HTTPS traffic. webserver.js | Server background install on Windows. winservice.js | Server background install on Windows. At a high level, the MeshCentral.js file will get the server started. By default, it will start the webserver.js on port 443, redirectserver.js on port 80 and mpssrver.js on port 4433. The webserver.js file will create a meshuser.js or meshagent.js instance each time a user or agent connects. The other files support various usages, but this is the basic working on the server.","title":"Code files"},{"location":"design/#server-database","text":"One of the big design decision on the server is its database. We want something that scales and so, opted to deal with the good and the bad of a NoSQL database, MongoDB. On the other hand, we want the server to be really simple to install for people who want to try it out or want to manage 100 computers or less. We don\u2019t want the added learning curve of MongoDB for people that don\u2019t really need it. It turned out, we can have both. NeDB is a NPM package that provides a simple MongoDB-like API while being completely implemented in NodeJS. For most people, this is plenty good to get started. By default, MeshCentral will just create and use a NeDB database, but can be configured to use MongoDB. The internal code path for both databases are almost exactly identical so the \u201cdb.js\u201d file handles both, almost the same way and the exact database in use is completely abstracted from the rest of the server code.","title":"Server database"},{"location":"design/#certificates","text":"MeshCentral makes use of many certificates to accomplish many security tasks. When first running the server or an agent, both of these actors will generate certificates. The agent will generate one or two certificates on the first run and the server will generate four certificates. In this section we review what certificates are created, what are their uses and how they are stored. Most administrators using MeshCentral will not need a deep understanding of this section to run the server, however, a basic understanding of this section can help understand how to best protect the server\u2019s critical security assets.","title":"Certificates"},{"location":"design/#server-certificates","text":"As indicated above, the MeshCentral server creates four certificates when it first runs. It uses ForgeJS to perform certificate creation and all four certificates below are saved in the \u201cmeshcentral-data\u201d folder. The four certificates are:","title":"Server Certificates"},{"location":"design/#server-root","text":"root-cert-public.crt This is a self-signed root certificate that is used only to issue the 3 next certificates. This certificate can be useful when it\u2019s installed as a root of trust in some situations. For example, when Intel AMT connects to the MPS server on port 4433, it will correctly connect only if this root certificate is loaded into Intel AMT as a trusted certificate. Browser can also be setup to trust this root certificate in order to create a trusted connection between a browser and the servers HTTPS port. This certificate is RSA3072 unless the option \u201c--fastcert\" is used, in that case a RSA2048 certificate is generated.","title":"Server root"},{"location":"design/#mps-certificate","text":"mpsserver-cert-public.crt This is a TLS certificate signed by the root above used as a TLS server certificate on the MPS port 4433. Intel AMT computers will connect to this port and verify the certificate time, common name and that it\u2019s signed by the root above. This certificate is not typically changed, even when the server is running in production. This certificate is always generated as RSA2048 because older Intel AMT firmware will not accept certificates with larger keys.","title":"MPS certificate"},{"location":"design/#web-certificate","text":"webserver-cert-public.crt This is the default certificate used to secure the HTTPS port 443. It is signed by the root above and is the certificate users will first see then connecting the browser to the server. Often, users will need to ignore the browser security warning. This certificate is RSA3072 unless the option \u201c--fastcert\" is used, in that case a RSA2048 certificate is generated. In production environments, this certificate is replaced with a real certificate. There are many ways to change this certificate for a more appropriate certificate in production environments: You can replace the \u201cwebserver-cert-*\u201d files in the \u201cmeshcentral-data\u201d folder. You can use Let\u2019s Encrypt which will override this certificate automatically. You can use a reverse-proxy in front of the server with \u201c--tlsoffload\".","title":"Web certificate"},{"location":"design/#agent-certificate","text":"agentserver-cert-public.crt This certificate is used to authenticate the server to agents. It\u2019s signed by the root above and when installing an agent, the hash of this certificate is given to the agent so that it can connect back to the server securely. This certificate is RSA3072 unless the option \u201c--fastcert\" is used, in that case a RSA2048 certificate is generated. The \u201cmeshcentral-data\u201d folder contains critical server information including private keys therefore, it\u2019s important that it be well protected. It\u2019s important to backup the \u201cmeshcentral-data\u201d folder and keep the backup in a secure place. If, for example the \u201cagent certificate\u201d on the server is lost, there is no hope for agents ever be able to connect back to this server. All agents will need to be re-installed with a new trusted certificate. If someone re-installs a server, placing the \u201cmeshcentral-data\u201d folder back with these certificates should allow the server to resume normal operations and accept connections for Intel AMT and agents as before.","title":"Agent certificate"},{"location":"design/#agent-certificates","text":"The mesh agent generates one or two RSA certificates when it first starts. On smaller IoT devices such as a Raspberry Pi, this can take a little while to do and the CPU will spike to 100% during this time. This is normal and only occurs the first time the agent runs. The certificates are generated a little differently depending on the platform. On Windows, the Mesh Agent will use Microsoft cryptographic providers to harder the agent root cert. If available, the agent will use the platform TPM to harden the certificate. On other platforms, only one certificate is generated and used for both agent authentication to the server and WebRTC session authentication.","title":"Agent Certificates"},{"location":"design/#agent-root-certificate","text":"This certificate is the root trust of the agent. The SHA384 hash of this certificates public key is the agent\u2019s identifier on the server. When a agent connects to the server using web socket, it performs a secondary authentication check using this certificate. The server will compute the agent\u2019s identifier after the agent sent a signed proof to the server. This certificate is also used to sign the secondary certificate below when it\u2019s needed.","title":"Agent root certificate"},{"location":"design/#secondary-certificate","text":"This is a certificate signed by the agent root above. It\u2019s currently only used by WebRTC to perform dTLS authentication to a remote browser. This certificate does not need to be signed by a trusted CA for WebRTC purposes since the hash of the certificate will be sent to the browser using a trusted path. If the agent root certificate is not hardened using platform cryptography, the secondary certificate is not created and the agent root cert is used for all purposes. A possible attack would occur if someone were to be able to access the agent root certificate. They could impersonate the agent to the server. Agents don\u2019t have any rights to perform management operations on the server or other agents, but by impersonating a agent, a rogue agent would pretend to be an office computer to which administrator would login with their username & password, especially when the root is not hardened. Some care should be taken to protect the \u201cmeshagent.db\u201d file and to not give important information to untrusted agents.","title":"Secondary certificate"},{"location":"design/#tls-security","text":"MeshCentral makes heavy use of Transport Layer Security (TLS) and datagram-TLS (dTLS) to authenticate and encrypt network traffic between the browser, server and agent. Configuring TLS settings correctly is essential to making sure communications are secure and to minimize attacks on open ports. Probably the most important TLS configuration is for the MeshCentral server ports 443 and 4433. These two ports are exposed to the Internet and so, should be setup as securely as possible.","title":"TLS Security"},{"location":"design/#meshcentral-https-port-443","text":"The HTTPS port on the MeshCentral server will only support TLS 1.2 and above, and makes use of only 6 cypher suites: TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_GCM\\_SHA384 (0xc030) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA384 (0xc028) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA (0xc014) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_GCM\\_SHA256 (0xc02f) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA256 (0xc027) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA (0xc013) Note that these cipher suites are all perfect forward secrecy (PFS) suites and are considered cryptographically secure as of the writing of this document. When the server is deployed on the Internet, https://ssllabs.com gives the server an A rating with no known vulnerabilities and no weak ciphers detected. SSL Labs confirms that all major browsers should be able to connect correctly to this server.","title":"MeshCentral HTTPS port 443"},{"location":"design/#meshcentral-mps-port-4433","text":"The Manageability Presence Server (MPS) port 4433 is used for incoming Intel AMT CIRA connections. By default it uses a TLS certificate that is signed by a self-signed root certificates. This port is not intended to be connected to by typical browsers, only Intel AMT should connect to this port. Note that the TLS certificate generated by MeshCentral for port 4433 is RSA 2048bits, this is because older Intel AMT firmware don\u2019t support RSA 3072. Because the port is not secured using a trusted certificate, SSL Labs will not rate the security of this server. This is fully expected. Note that SSL Labs will not test servers that are not on port 443. To perform a test like this MeshCentral must be set temporarily with the MPS port set to 443 and the normal HTTPS port set to a different value. Because older Intel AMT computers that only support TLS 1.0 are common, the server supports TLS v1.0, v1.1 and v1.2 with the following 12 cipher suites: TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_GCM\\_SHA384 (0xc030) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA384 (0xc028) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA (0xc014) TLS\\_RSA\\_WITH\\_AES\\_256\\_GCM\\_SHA384 (0x9d) TLS\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA256 (0x3d) TLS\\_RSA\\_WITH\\_AES\\_256\\_CBC\\_SHA (0x35) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_GCM\\_SHA256 (0xc02f) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA256 (0xc027) TLS\\_ECDHE\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA (0xc013) TLS\\_RSA\\_WITH\\_AES\\_128\\_GCM\\_SHA256 (0x9c) TLS\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA256 (0x3c) TLS\\_RSA\\_WITH\\_AES\\_128\\_CBC\\_SHA (0x2f) The suites starting with \u201cTLS_RSA_\u201d don\u2019t have perfect forward secrecy (PFS) and so, are considered weak by SSL Labs. However, these are generally the suites that are supported by Intel AMT.","title":"MeshCentral MPS port 4433"},{"location":"design/#agent-to-server-handshake","text":"One interesting aspect of MeshCentral\u2019s design is how the agent connects to the server. We wanted a way for the agent to connect to the server that would be similar to how browsers connect to web servers. This allows for a large number of agents to connect just like if a large number of browsers where connecting. All of the infrastructure that helps web server\u2019s scale would be put to use in the same way for agent connections. For example: TLS offload hardware, load balancers, reverse-proxies, web server scaling, etc. could all be put to use. It also makes the server easier to setup because only one port (HTTPS 443) is needed for both users and agents. One big difference between the agent connecting and a typical browser is how the server is authenticated. Browsers have a set of known trusted root certificates. The server\u2019s web certificate is checked for validity including the name, time trusted CA and more. The agent does not have this. Instead, it just has a hash to a private server certificate. The public facing web certificate of the server can change frequently. For example, Let\u2019s Encrypt certificates are valid 90 days. Agents need to be able to validate a specific server for a long time and don\u2019t really need to trust anything else except one specific server. We also don\u2019t want to tie the agents to a specific domain name as we could change that in the future or want to support servers with dynamic IP addresses and no fixed DNS names. To handle all this, the agent performs a TLS connection to the server and will first see the web certificate of the server. It will then exchange a set of web socket binary messages to the server to perform a secondary authentication with the server. The secondary check allows the agent to confirm that this server does own the private key of the private certificate expected by the agent. The agent caches the hash of the \u201couter\u201d web certificate. When re-connecting, if the agent sees the same outer web certificate, it will skip the secondary check. For obvious security raisons, it\u2019s important that the agent not accept any management messages until the secondary check is completed or skipped. To prevent man-in-the-middle attacks, the secondary check also \u201cpins\u201d the outer web certificate. That is, the server both confirms it\u2019s the right server and indicates to the agent the hash of the outer certificate that it must have seen during the TLS connection. The agent must check this hash to make sure there is no attacker in the middle. The agent connection design allows for reverse-proxies and TLS offload hardware. The agent will first connect a TLS session to the offload hardware. Clear traffic flows between the offload hardware and the server which will perform the secondary check if needed. To makes all this work, the MeshCentral server must be able to fetch the hash of the outer web certificate from the reverse proxy. In this case, the server does not need the private key to the web certificate. Note that when the outer web certificate is updated, the server may have to perform many secondary checks at the same time causing a server slowdown during this time. To help with this, MeshCentral will offload the RSA signing operation to many slave processes (as many as the CPU core count on the server) to speed this up. In addition, native NodeJS RSA signing is used (not ForgeJS). The details of the secondary certificate check look like the diagram below. To boost speed, the exchange is fully asynchronous and both sides send the first message as soon as the TLS connection completes. Note that these messages are binary (not JSON). The agent must be able to connect to the server independently of the JavaScript that is running in DukTape. So this exchange is handled by native C code in the agent. Binary message 1 is sent immediately after the TLS connection is setup. Both sides will send binary message 2 when message 1 is received and message 3 when message 2 is received. In addition, there are two extra messages of interest that can be sent by the agent right at the start. The agent may send the server message number 4 if the secondary check can be skipped and may send binary message number 5 indicating what server hash it expects to verify. Message number 5 is interesting because a server may have many \u201cidentities\u201d at the same time, and so, the server will use message number 5 in order to use the right Agent Server certificate. In order to be as secure as possible, all hashes use SHA384 and certificates are RSA3072 and nonces are generated on both sides using a cryptographic random source. The server and agent signatures are computed like this: While the server will often skip its RSA signature operation due to the agents caching the outer web certificate, the server must perform an RSA verify to each agent connection. This can\u2019t be skipped but is needed to authenticate the agent. Once connected, the trust relationship between the server and the agent is one-way. That is, the server has management rights on the agent, but the agent does not have any right on the server. This is important since the agent does not, by default, have any credentials to the server. Any agent can connect to the server and claim to be part of a device group.","title":"Agent to server handshake"},{"location":"design/#browser-to-agent-relay-and-webrtc","text":"Browsers and agents often need to communicate to each other. Data sessions are used for desktop, terminal, file transfers, etc. and must be setup securely. To setup a session between a browser and the agent, the server will send a URL to both sides to connect to. The URL is generated by the server and includes a unique connection token. It is sent to both the browser and agent using the web socket control channel and a JSON message. Both sides perform a websocket connection to the target URL and the server will \u201cpipe\u201d both sessions together to act as a passive relay. For security, the agent will only accept connections to the URL given by the server if the server has the same outer web certificate as its control connection. Also note that in this mode, the session is not end-to-end encrypted. The server is performing a TLS decrypt and re-encrypt and the traffic cost is high as each byte of data has to be received and sent again. The relay server is just websocket server that will wait for connections with session tokens. When two connection with the same connection token arrive, the server makes sure that at least one of the two connections is an authenticated user, it then sends the character \u201cc\u201d on both sides to inform both parties that the relay is starting and then pipes both sessions together. Once the session is started, the browser and agent are free to send messages to each other. Note that when the server sends the relay URL to the agent, it also sends to the agent the user\u2019s permissions flags. This may be used by the agent to limit what the user can do on this session. With this design, the flow control between the browser and agent is simple, each session gets its own end-to-end connection and the server will apply appropriate TCP back pressure on both sides as needed. A unique feature of MeshCentral is its use of WebRTC. WebRTC was introduced in major browsers as a way to allow browsers to directly communicate to each other and perform audio/video streaming. The mesh agent has a WebRTC data-only stack that is custom built for this project in C code. It\u2019s compatible with Chrome and Firefox implementations and once a session is set up, allows data to flow directly from the browser to the agent, bypassing the server. The use of WebRTC allows MeshCentral to scale better, to offer a faster user experience and lower hosting costs all at the same time. However, WebRTC is not easy, especially when you must maintain the C code for it and have to keep up with browser implementations, but the benefits are clear. To setup WebRTC, browsers typically use STUN and TURN servers to get traffic thru any network obstacles (routers, proxies, firewalls). This infrastructure can be complex to setup especially if an administrator is not familiar with WebRTC concepts. To make things easy, MeshCentral opted to always start by using a websocket relay thru the server to get things started. While a session is active, the browser and agent will attempt to automatically switch the session traffic to WebRTC when possible. This way, the session always works and gets more efficient when network conditions allow. To perform the switch-over, both browser and agent will exchange WebRTC control messages over the newly established web socket relay session. In order to differentiate session traffic from WebRTC control traffic, the browser and agent agree to send WebRTC setup traffic using web socket text fragments. All other session traffic is sent using binary fragments. The agent has a special API allowing a session to be piped for a single fragment type. So we can perform a remote desktop session to the agent while trying to setup WebRTC at the same time. The browser will kick off the WebRTC setup sending the initial WebRTC offer with the agent responding with a WebRTC answer. If the WebRTC session gets setup, both sides need to negotiate a clear transition from the web socket session to the WebRTC session. To do this, both sides send a start switch control fragment (this is a text fragment), the other side will respond with an ACK when the web socket session is flushed out and it\u2019s safe to switch. On the agent side, the new WebRTC session inherits the user access rights of the web socket. Currently, the web socket channel is still maintained open. While it\u2019s not strickly needed, the web socket session terminates more cleanly than WebRTC and so, oddly its closure is used to signal the end of the WebRTC session.","title":"Browser to agent relay and WebRTC"},{"location":"design/#messenger","text":"MeshCentral includes its own messaging web application it can be used to chat, transfer files and optionally used for audio and video chat. It\u2019s used to support two different usages: User-to-user and user-to-computer communication. In the first usage, two users that are connected to the same MeshCentral server at the same time can chat. If you are a MeshCentral administrator, you can see the list of currently logged in users and hit the chat button to launch a chat invitation. If accepted, the Messenger is open on both sides and the session starts. Alternatively, while managing a remote computer, an administrator can hit the chat button to cause the remote computer to open a web browser to the chat application. The chat app is standalone web application that is served by the MeshCentral server using a connection token and title in the URL. Once loaded in its own web frame, the messenger web application will get the connection token and title from the URL and proceed to connect to the URL using web socket. The same web socket relay that is used for browser-to-agent connections is also used in this case for browser-to-browser connections. The server relay acts the same and pipes both sessions together after sending the character \u201cc\u201d to both sides. At this point, the messenger application will show the remote user as connected and chat and file transfers can start. File transfers are just a set of binary messages sent over the web socket session with lots of JSON control messages. Once the web socket session is setup, the messenger application will then attempt to perform a switch over to WebRTC. Both web application start by selecting a random number (not cryptographic) and the highest number will initiate the WebRTC offer. The other party will answer and both sides will trade interface candidates as they are discovered. If successful, the web socket session are flushed and the traffic is switched over to WebRTC. Because the switchover is done cleanly, it can occur while in the middle of a file transfer without the file being corrupted. Finally, the web application will determine if the local computer is attached to a microphone and if it has a camera. If so, these options are offered in the chat window and audio/video chat is available for use. The chat app allows for one way setup of audio & video sessions. This is typically what is needed in support scenarios where the audio/video session is one-way. The messenger web application will setup a separate WebRTC connection for audio/video in each direction but the code is present to augment the WebRTC control channel with audio/video which is a bit more efficient but more testing is needed before defaulting to this mode.","title":"Messenger"},{"location":"design/#additional-resources","text":"In addition to this document, there are a growing set of MeshCentral resources at: https://www.meshcommander.com/meshcentral2. This includes an Installer\u2019s documents, a User\u2019s Guide and plenty of YouTube tutorial videos. For developers, it\u2019s best to start on the MeshCentral GitHub repository at: https://github.com/Ylianst/MeshCentral . If any issues are found, it\u2019s best to create a new issue in GitHub or mail ylianst@gmail.com","title":"Additional Resources"},{"location":"design/#conclusion","text":"MeshCentral is a free, open source and powerful remote management solution that is cross- platform. In this document, we have covered the goals, overview, design and some details of the software. It\u2019s hoped that this document will encourage developers to take a look at MeshCentral for more usages and review its security in detail. MeshCentral\u2019s use of modern web technologies make it a unique and amazing solution for remote management of computers. As with any good software, MeshCentral will continue to be updated and evolve.","title":"Conclusion"},{"location":"design/#license","text":"MeshCentral and this document are both opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0","title":"License"},{"location":"install/","text":"Quick Start Guide \u00b6 Installation \u00b6 Getting started is easy. If you don't have it already, install NodeJS. Then, create an empty folder and do this: npm install meshcentral node node_modules/meshcentral That's it. MeshCentral will set itself up and start managing computers on your local network. By default it will be setup in LAN mode and agents you install will multicast on the local network to find the server. To setup the server so that agents use a well known DNS name and to start customizing your server, go in the \"meshcentral-data\" folder and edit the config.json file. The configuration file must be valid JSON, you can use this link to validate the file format. For Windows users, you can download the MeshCentral Installer that will automate installation of NodeJS and provide basic configuration of the server. This option is not recommended for advanced users. Win32 MeshCentral Installer By default, MeshCentral will use NeDB as this is the built-in database. For more advanced users, it's recommended to switch to using MongoDB. MeshCentral can be installed on a very small server. A Raspberry Pi or AWS t3.nano running Amazon Linux 2 instance for 5$ a month will do just fine for managing up to a few hundred devices. You can run the MeshCentral Server with --help to get options for background installation. Configuration \u00b6 Once you get MeshCentral installed, the first user account that is created will be the server administrator. So, don't delay and navigate to the login page and create a new account. You can then start using your server right away. A lot of the fun with MeshCentral is the 100's of configuration options that are available in the config.json file. You can put your own branding on the web pages, setup a SMTP email server, SMS services and much more. You can look here for simple config.json , here for a more advanced configuration and here for all possible configuration options . You can also take a look at the MeshCentral User's Guide and tutorial videos for additional help. Video Walkthru \u00b6","title":"Quick Start Guide"},{"location":"install/#quick-start-guide","text":"","title":"Quick Start Guide"},{"location":"install/#installation","text":"Getting started is easy. If you don't have it already, install NodeJS. Then, create an empty folder and do this: npm install meshcentral node node_modules/meshcentral That's it. MeshCentral will set itself up and start managing computers on your local network. By default it will be setup in LAN mode and agents you install will multicast on the local network to find the server. To setup the server so that agents use a well known DNS name and to start customizing your server, go in the \"meshcentral-data\" folder and edit the config.json file. The configuration file must be valid JSON, you can use this link to validate the file format. For Windows users, you can download the MeshCentral Installer that will automate installation of NodeJS and provide basic configuration of the server. This option is not recommended for advanced users. Win32 MeshCentral Installer By default, MeshCentral will use NeDB as this is the built-in database. For more advanced users, it's recommended to switch to using MongoDB. MeshCentral can be installed on a very small server. A Raspberry Pi or AWS t3.nano running Amazon Linux 2 instance for 5$ a month will do just fine for managing up to a few hundred devices. You can run the MeshCentral Server with --help to get options for background installation.","title":"Installation"},{"location":"install/#configuration","text":"Once you get MeshCentral installed, the first user account that is created will be the server administrator. So, don't delay and navigate to the login page and create a new account. You can then start using your server right away. A lot of the fun with MeshCentral is the 100's of configuration options that are available in the config.json file. You can put your own branding on the web pages, setup a SMTP email server, SMS services and much more. You can look here for simple config.json , here for a more advanced configuration and here for all possible configuration options . You can also take a look at the MeshCentral User's Guide and tutorial videos for additional help.","title":"Configuration"},{"location":"install/#video-walkthru","text":"","title":"Video Walkthru"},{"location":"install/install2/","text":"Full Install Guide \u00b6 Abstract \u00b6 This guide is specifically intended to help users install MeshCentral from start to finish. Once installed, you can take a look at the MeshCentral user\u2019s guide for information on how to configure MeshCentral for your specific use. In this document, we will look at installing MeshCentral on AWS Linux, Raspberry Pi and Ubuntu. Quick Start \u00b6 For some who want to skip this document entirely, there are quick install scripts that will get a MeshCentral2 instance up and running on Linux in a few minutes. These scripts will pretty much do what this document explains very rapidly. Right now, there are two such scripts available: Amazon Linux 2 \u00b6 For Amazon EC2 users, that want to manage 100 devices or less. Launch a t3.nano or t3.micro EC2 instance with Amazon Linux 2 with TCP ports 22 (SSH), 80 (HTTP), 443 (HTTPS) and 4433 (CIRA) open. Then login as ec2-user and enter the following commands: wget http://info.meshcentral.com/scripts/mc-aws-linux2.sh chmod 755 mc-aws-linux2.sh ./mc-aws-linux2.sh This will download the fast install script and once run, will install nodejs, meshcentral, setup systemd and start the server. For a larger instance like a t3.small, t3.medium or larger you can run the following that does the same but also installs MongoDB. wget http://info.meshcentral.com/scripts/mc-aws-linux2-mongo.sh chmod 755 mc-aws-linux2-mongo.sh ./mc-aws-linux2-mongo.sh After these scripts are run, try accessing the server using a browser. MeshCentral will take a minute or two to create certificates after that, the server will be up. The first account to be created will be the site administrator \u2013 so don\u2019t delay and create an account right away. Once running, move on to the MeshCentral\u2019s user\u2019s guide to configure your new server. Microsoft Azure \u00b6 For 100 devices or less, launch an instance of Ubuntu 18.04 using a small B1s instance. Set the username to default in all lower case and open ports 22, 80, 443 and 3389 using the basic network profile. Then start the instance and run the following lines. wget http://info.meshcentral.com/scripts/mc-azure-ubuntu1804.sh chmod 755 mc-azure-ubuntu1804.sh ./mc-azure-ubuntu1804.sh In this situation, port 3389 will be used to receive Intel AMT CIRA connections instead of port 4433. After these scripts are run, try accessing the server using a browser. MeshCentral will take a minute or two to create certificates after that, the server will be up. The first account to be created will be the site administrator \u2013 so don\u2019t delay and create an account right away. Once running, move on to the MeshCentral\u2019s user\u2019s guide to configure your new server. Windows Installation \u00b6 MeshCentral is constructed entirely with NodeJS, an asynchronous event driven JavaScript runtime (https://nodejs.org/). A basic understanding on NodeJS may be preferable but not compulsory. MeshCentral server which heavily relies on NodeJS runtime will be able run on almost any computing platform with contemporary operating systems including Windows*, Linux* and macOS*. There are two ways to get MeshCentral setup. For Linux*, macOS*, or advanced users can use CLI based NPM tool. For Windows users, you can use the MeshCentral installation tool. Windows Installation Tool \u00b6 The MeshCentral installer tool for Microsoft Windows can be downloaded at https://www.meshcommander.com/meshcentral2 or by clicking this link. This tool will automatically detect and install NodeJS if needed. NodeJS will be downloaded from https://nodejs.org checked and installed. We recommend the installer be run on a modern version of Windows (.e.g. Win8.1, Win10, Win Server 2012* or better) During installation, the installation tool will prompt for the following settings: Multi-user Server : By enabling this option, the server will be open to any user with a web browser app. Users will be able to create accounts and start managing computers associated in their respective accounts. Note If this option is disabled (unchecked), the server will run as a single-user server, no login screen will be presented and MeshCentral application will be limited to the server host machine only. Auto-update Server: By enabling this option, the server will check new version releases daily and perform automatic update. Note Update check occurs at 0000 between 0100 hours (local time). During update, the server will not be accessible until update is completed. Server Modes, LAN, WAN or Hybrid: LAN mode : Recommended for small installation within a local network. Server host does not need a fixed IP address or DNS record to operate. WAN or Hybrid modes : Server host will require a fixed IP address or DNS record to function correctly. If selected, user will need to enter server\u2019s DNS name or static IP address in the Server Name field. This name or IP address will be used by browsers and agents to connect back to the server, this name MUST be correct or the server will not work. If you do not have a fixed name, select LAN mode to get started. Acquiring a static IP or DNS record is beyond the scope of this document. Please seek advice or consult your network administrator if unsure. If unsure, leave the settings as default (as-is) and proceed setup in LAN mode to manage computers that reside within the same network. Once installed MeshCentral will run as a background Windows Service and can be accessed using a web browser with the link provided by the installer. The installation tool can be run again to perform server update, re-installation or un-installation. When performing an update check, the tool will look at the currently installed version and compare it to the one present on NPM. By default, MeshCentral will use TCP ports 80 (HTTP), 443 (HTTPS) and 4433 (Intel\u00ae AMT CIRA). The installer will add Windows Defender Firewall rules to allow incoming connections on these ports. In addition, if the server is in LAN or Hybrid mode, an addition rule on UDP port 16990 is added to allow for server discovery. NPM Installation for Advanced Users \u00b6 For advanced users or administrators, MeshCentral can be installed with NPM, a NodeJS package manager that can be accessed via web browser (https://www.npmjs.com/) or command line tool, npm . Note As a prerequisite, NodeJS and NPM must be installed on host OS and HTTP/HTTPS proxy settings maybe required if server host resides behind a HTTP proxy server. To begin, start a command line terminal (Windows Command Prompt or Linux Terminal) and type the following to verify if nodeJS and npm has been installed correctly as shown below a. To check on nodeJS installed version, type node \u2013v and hit enter key b. To check on npm installed version, type npm \u2013v and hit enter key If MeshCentral installation is performed on a server host that resides behind a HTTP proxy, NPM\u2019s proxy settings must be updated with respective proxy settings associated with the network environment. Skip this step if not applicable. .e.g. for http proxy `npm config set proxy http://proxy.com:88` .e.g. for https proxy `npm config set https-proxy http://proxy.com:88` Create a new directory MeshCentral and run the NPM install command as shown below: mkdir meshcentral cd meshcentral npm install meshcentral Warning : Do not use sudo in front of npm install meshcentral . Upon download completion, the server can be started with the commands below: node node_modules/meshcentral [arguments] Warning : Do not run MeshCentral by going into the node_modules/meshcentral folder as this may cause auto-install and self-update features to fail. Instead, go into the directory above node_modules and run node node_modules/meshcentral . Note : If MeshCentral is started without any arguments, default settings in LAN-only mode will be in effect and user/administrator will only be able to manage computers that reside within the local network. To manage computers over the internet, the server needs to have static IP settings or a DNS record that resolves back to the right server. The mesh agents will be using the mechanism to call home to MeshCentral server. For WAN or Hybrid mode, run one of the commands below node node_modules/meshcentral --cert servername.domain.com node node_modules/meshcentral --cert hostname.domain.com node node_modules/meshcentral --cert 1.2.3.4 Note : On first attempt running on WAN or Hybrid Mode: Certificates will be generated for the first time and this may take a few minutes to complete. Note At this point, no user account will be created or available for the user hence 1 st user account will be the most privileged user with Administrator rights User is advised to create an admin account immediately by navigating to https://127.0.0.1 with a web browser. Note : To run MeshCentral as a service, run it using --install argument. Once running, start a web browser and access MeshCentral application with respective URL. Windows Defender Firewall Settings \u00b6 On Windows, the built-in firewall will need to be configured to allow TCP ports 80, 443 and 4433 and sometimes UDP port 16990. The MeshCentral Windows Installer will add incoming rules for these ports automatically. If using the advanced NPM installation or when changing the default ports, it may be needed to add or edit these firewall rules. In this section we look at how to do this. To get started, we need to go in the control panel, click System and Security then Windows Defender Firewall and Advanced Settings on the left side then click on Inbound rules . This will get us on the right place to add or edit firewall rules. If the MeshCentral Windows Installer was used, the MeshCentral Server TCP ports and optionally MeshCentral Server UDP ports rules should already be present. Editing the existing rules \u00b6 To edit an existing rule, simply double click on it. To change the allowed inbound ports, go to the Protocols and Ports tab and change the local ports. Add new firewall rules \u00b6 To add a new firewall rule, click on the New Rule\u2026 then select Port and ok. TCP or UDP and enter the specific local ports needed and ok. Then click ok twice, enter the rule name and ok again. Typically, inbound TCP ports 80, 443 and 4433 are used, but the rule can be added with different ports as needed. Amazon Linux 2 \u00b6 In this section, we will look at installing MeshCentral on Amazon AWS with Amazon Linux 2 . This is a low cost instance and a free tier is available so you can experiment or run a small instance of MeshCentral and it will work perfectly fine. Getting the AWS instance setup \u00b6 On AWS EC2, you can launch an instance and select Amazon Linux 2 . In this case, it\u2019s the first option available. When launching a new instance, you are asked to use or create a security group with the allowed inbound TCP and UDP ports. The security group should look like this: All security group rules should have a source of 0.0.0.0/0 and ::/0 . The last rule for port 8080 is only needed if migrating from a MeshCentral1 server, most people don\u2019t need it and should not be added. If you are not going to be managing Intel AMT computers, you can remove port 4433. One can also remove port 80, however it\u2019s needed to get a Let\u2019s Encrypt certificate and useful to route users from the HTTP to the HTTPS web page. For all the following sections, we assume that we are in the ec2-user home path. You can do: cd ~ This will change the current path to the home folder. Installing NodeJS \u00b6 To get started, launch an instance and start a SSH session to it. You can use SSH on Linux or Putty on Windows to login to the AWS instance. The first thing to do is get NodeJS installed on the instance. We will be installing a long term support (LTS) version of NodeJS. Additional information on how to do this can be found here. We first install the node version manager then activate it and install the NodeJS LTS. It\u2019s done with 3 commands: curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash . ~/.nvm/nvm.sh nvm install --lts We can test what version of NodeJS is installed using: node -v Installing MongoDB \u00b6 If we are going to run a large instance, it\u2019s best to use MongoDB as the database. If you are using a small instance, you can skip installing MongoDB and MeshCentral will use NeDB instead which is a light weight database that is probably great for managing less than 100 computers. If you want to use MongoDB, we can install MongoDB Community Edition. More information on how to do this can be found here. Using nano create the file /etc/yum.repos.d/mongodb-org-4.0.repo : sudo nano /etc/yum.repos.d/mongodb-org-4.0.repo Then, put this in it: [mongodb-org-4.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/amazon/2/mongodb-org/4.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc This file will setup the repository that we will be using to bet MongoDB. Once done, you can install the package using yum and get it started like this: sudo yum install -y mongodb-org sudo service mongod start To verify that MongoDB is running, you can enter the MongoDB shell like this: mongo --host 127.0.0.1:27017 You can leave the shell using Ctrl-C. The database and log files will be create at these locations: /var/log/mongodb /var/lib/mongo This is useful to know if you want to make a backup of the database file. Port permissions \u00b6 On Linux, ports below 1024 are reserved for the root user. This is a security feature. In our case MeshCentral will need to listen to ports 80 and 443. To allow this, we need to allow node to listen to ports below 1024 like this: whereis node node: /home/ec2-user/.nvm/versions/node/v8.11.3/bin/node sudo setcap cap_net_bind_service=+ep /home/ec2-user/.nvm/versions/node/v8.11.3/bin/node We first locate the node binary, using whereis node , we then use the setcap command to add permissions to node. Note that we take the path given by whereis and place it in the setcap command. The setcap command will set permissions allowing node to use ports 1024 and below. This permission may be lost when updating the Linux kernel, so this command may need to be applied again in some case. Installing MeshCentral \u00b6 It\u2019s almost time to install MeshCentral but first, we need to know the public name of our AWS instance, you can run the following command: curl http://169.254.169.254/latest/meta-data/public-hostname It will return the public name of the AWS instance, for example: ec2-1-2-3-4.us-west-2.compute.amazonaws.com You can use this name, or if you have another registered DNS name pointing to the server instance, you can also use that now. Note that you must setup any alternative name on your own, MeshCentral will not do this for you. This name must be correct and must resolve to this AWS instance as all mesh agents will use this name to connect back to this server. Now, we can use the node package manager (NPM) to install MeshCentral. npm install meshcentral Warning Do not use sudo in front of npm install meshcentral . After that, we can run MeshCentral for the first time. We want to run in WAN-only mode since we will not be managing any computers on the same local network at this server. We also want to create a server with a certificate name that is the same at the AWS instance name. So, we will use --wanonly and --cert [name] arguments to get the server started. For example: node ./node_modules/meshcentral --wanonly --cert ec2-1-2-3-4.us-west-2.compute.amazonaws.com At this point, the server will create its certificates and start running. MeshCentral HTTP redirection web server running on port 80. Generating certificates, may take a few minutes... Generating root certificate... Generating HTTPS certificate... Generating MeshAgent certificate... Generating Intel AMT MPS certificate... Generating Intel AMT console certificate... MeshCentral Intel(R) AMT server running on ec2-54-245-141-130.us-west-2.compute.amazonaws.com:4433. MeshCentral HTTPS web server running on ec2-54-245-141-130.us-west-2.compute.amazonaws.com:443. Server has no users, next new account will be site administrator. You can now open a browser to the name of the server, for example: https://ec2-1-2-3-4.us-west-2.compute.amazonaws.com You will see the server working as expected. You will get a certificate error since the server is used an untrusted certificate for now. Just ignore the error and see the MeshCentral User\u2019s Guide to fix this. At this point, the server is usable but, there are two things that may still need to be done. First, if we opted to use MongoDB, we have to configure MeshCentral to use a MongoDB database. By default, NeDB will be used which should only be used for small deployments managing less than 100 computers. We also need to automatically start the server when the AWS instance starts. To continue, stop the MeshCentral server with CTRL-C. Configuring for MongoDB \u00b6 By default, MeshCentral uses NeDB with a database file located in ~/meshcentral-data/meshcentral.db. This is great for small servers, but if we opted to install MongoDB, let\u2019s make use of it. We need to edit the config.json file located in the meshcentral-data folder. nano ~/meshcentral-data/config.json Then, make the start of the file look like this: { \"settings\" : { \"MongoDb\" : \"mongodb://127.0.0.1:27017/meshcentral\" , \"WANonly\" : true , \"_Port\" : 443 , \"_RedirPort\" : 80 , \"_AllowLoginToken\" : true , \"_AllowFraming\" : true , \"_WebRTC\" : false , \"_ClickOnce\" : false , \"_UserAllowedIP\" : \"127.0.0.1,::1,192.168.0.100\" }, \u2026 } If you start with the default config.json created by MeshCentral, you will need to remove some _ characters in front of settings, mongodb and wanonly. You can also add a _ to other values. You can then same the same and run MeshCentral again. This time, you don\u2019t need to specify the certificate name or --wanonly . You just need to run it like this: node ./node_modules/meshcentral The server should now run correctly and use MongoDB. You can even delete the file ~/meshcentral-data/meshcentral.db as it\u2019s not going to be used anymore. You can check that it runs correctly by browsing to the server\u2019s address again and creating a new account. The first account that is created will be administrator for the server, so don\u2019t delay and create the first account right away. Once you are done, we can stop the server again using CTRL-C and in the next sections, we will look at starting the server in the background. Manually starting the server \u00b6 We can manually start and stop the MeshCentral server in the background in different ways. In this section, we are going to create two commands mcstart and mcstop to take care of this. Type this to create the two commands: echo \"node ./node_modules/meshcentral > stdout.txt 2> stderr.txt &\" > mcstart chmod 755 mcstart echo \"pkill \u2013f node_modules/meshcentral\" > mcstop chmod 755 mcstop You can now run the ./mcstart command to launch the server in the background and stop it using the ./mcstop to stop it. This should work pretty well, but if the AWS instance is ever stopped and started again, the server will not automatically launch. Automatically starting the server \u00b6 Since Amazon Linux 2 supports systemd, we are going to use that to auto-start MeshCentral in the background. First, we need to know our own username and group. If we do ls -l in our home folder we get for example: drwxr-xr-x 2 default default 4096 Jul 20 00:03 Desktop drwxr-xr-x 2 default default 4096 Jul 20 00:03 Documents drwxr-xr-x 2 default default 4096 Jul 20 00:03 Downloads \u2026 Note the username and group name, in this example it\u2019s default for both. We need this information to create the system service description file. To create this file type: sudo pico /etc/systemd/system/meshcentral.service Then enter the following lines: [Unit] Description=MeshCentral Server [Service] Type=simple LimitNOFILE=1000000 ExecStart=/usr/bin/node /home/default/node_modules/meshcentral WorkingDirectory=/home/default Environment=NODE_ENV=production User=default Group=default Restart=always # Restart service after 10 seconds if node service crashes RestartSec=10 # Set port permissions capability AmbientCapabilities=cap_net_bind_service [Install] WantedBy=multi-user.target Note that the user and group values have to be set correctly for your specific situation. Also, the ExecStart and WorkingDirectory lines includes the path to the user\u2019s home folder which includes the username in it. Make sure that is set correctly. Once this is done, you can now start, enable, stop and disable using the following commands: sudo systemctl enable meshcentral.service sudo systemctl start meshcentral.service sudo systemctl stop meshcentral.service sudo systemctl disable meshcentral.service Type in the first two commands to start and enable the service. Enabling the service will make it automatically start when the computer restarts. Once the server is launched, you can access it using a web browser as before. From this point on, refer to the MeshCentral User\u2019s Guide for information on how to configure and use MeshCentral. Raspberry Pi \u00b6 In this section, we will look at installing MeshCentral on the famous Raspberry Pi. This computer\u2019s low price makes it a perfect always-on system for managing computers on a home or small business network. This installation will work on any version of the Raspberry Pi, but version 3 certainly much faster. For this installation, we are going to use the Raspbian operating system. You can use the NOOBS version to install this operating system on your Raspberry Pi and install Raspbian. For best performance you can use the Raspbian Stretch Lite image which is much smaller and does not have the X desktop interface. To keep things even smaller, we are not going to be installing MongoDB, instead we are just going to be using NeBD as a database that comes by default with MeshCentral. Installing NodeJS \u00b6 Start by opening a terminal. For all of the installation, we will assume we are the default pi user and we are in the home (~) folder. Let\u2019s get started by installing NodeJS. sudo apt-get update sudo apt-get dist-upgrade curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash sudo apt-get -y install nodejs We can now check what version of Node was installed by typing: node -v If all goes well, we can now move on to port permissions and installing MeshCentral itself. Port permissions \u00b6 On Linux, ports below 1024 are reserved for the root user. This is a security feature. In our case MeshCentral will need to listen to ports 80 and 443. To allow this, we need to allow node to listen to ports below 1024 like this: whereis node node: /usr/bin/node /usr/include/node /usr/share/man/man1/node.1.gz sudo setcap cap_net_bind_service=+ep /usr/bin/node We first locate the node binary, using whereis node , we then use the setcap command to add permissions to node. Note that we take the path given by whereis and place it in the setcap command. The setcap command will set permissions allowing node to use ports 1024 and below. This permission may be lost when updating the Linux kernel, so this command may need to be applied again in some case. Installing MeshCentral \u00b6 Now, we can use the Node Package Manager (NPM) to install MeshCentral. npm install meshcentral Warning Do not use sudo in front of npm install meshcentral . After that, we can run MeshCentral for the first time. We want to run in WAN-only mode since we will not be managing any computers on the same local network at this server. We also want to create a server with a certificate name that is the same at the AWS instance name. So, we will use --wanonly and --cert [name] arguments to get the server started. For example: node node_modules/meshcentral --lanonly --fastcert At this point, the server will create its certificates and start running. MeshCentral HTTP redirection web server running on port 80. Generating certificates, may take a few minutes... Generating root certificate... Generating HTTPS certificate... Generating MeshAgent certificate... Generating Intel AMT MPS certificate... Generating Intel AMT console certificate... Server name not configured, running in LAN-only mode. MeshCentral HTTPS web server running on port 443. Server has no users, next new account will be site administrator. The next step is to get the IP address of the Raspberry Pi. Use ipconfig : eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.2.162 netmask 255.255.255.0 broadcast 192.168.2.255 inet6 fe80::8841:34b7:685:14a7 prefixlen 64 scopeid 0x20<link> ether b8:27:eb:01:13:3f txqueuelen 1000 (Ethernet) RX packets 58325 bytes 72302196 (68.9 MiB) RX errors 0 dropped 271 overruns 0 frame 0 TX packets 28457 bytes 3576126 (3.4 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 You can now open a browser to the name of the server, for example: https://192.168.2.162 You will see the server working as expected. You will get a certificate error since the server is used an untrusted certificate for now. Just ignore the error and see the MeshCentral User\u2019s Guide to fix this. Configuring for LAN-only mode \u00b6 By default, MeshCentral will assume that you are managing devices both on a local network and on the internet. In the case of this Raspberry Pi installation, we only want to manage device on the local network and so, we can configure MeshCentral to do this. It will adapt the server for this usages. To do this, edit the config.json file: pico ~/meshcentral-data/config.json Then, make the start of the file look like this: { \"settings\" : { \"LANonly\" : true , \"FastCert\" : true , \"_Port\" : 443 , \"_RedirPort\" : 80 , \"_AllowLoginToken\" : true , \"_AllowFraming\" : true , \"_WebRTC\" : false , \"_ClickOnce\" : false , \"_UserAllowedIP\" : \"127.0.0.1,::1,192.168.0.100\" }, \u2026 } While we are at it, we can put FastCert to true so that RSA2048 certificates are created instead of RSA3072. This is less secure but runs much faster on small processors like the Raspberry Pi. This is the same as specifying `--fastcert\" in the prior section. Manually starting the server \u00b6 We can manually start and stop the MeshCentral server in the background in different ways. In this section, we are going to create two commands mcstart and mcstop to take care of this. Type this to create the two commands: echo \"node ./node_modules/meshcentral > stdout.txt 2> stderr.txt &\" > mcstart chmod 755 mcstart echo \"pkill -f node_modules/meshcentral\" > mcstop chmod 755 mcstop You can now run the ./mcstart command to launch the server in the background and stop it using the ./mcstop to stop it. This should work pretty well, but if the AWS instance is ever stopped and started again, the server will not automatically launch. Automatically starting the server \u00b6 Since Raspbian OS supports systemd, we are going to use that to auto-start MeshCentral in the background. First, we need to know our own username and group. If we do ls -l in our home folder we drwxr-xr-x 2 pi pi 4096 Jul 19 21:23 Desktop drwxr-xr-x 2 pi pi 4096 Jun 26 18:23 Documents drwxr-xr-x 2 pi pi 4096 Jun 26 18:23 Downloads \u2026 Note the username and group name, in this example it\u2019s pi for both. We need this information to create the system service description file. To create this file type: sudo nano /etc/systemd/system/meshcentral.service Then enter the following lines: [Unit] Description=MeshCentral Server [Service] Type=simple LimitNOFILE=1000000 ExecStart=/usr/bin/node /home/pi/node_modules/meshcentral WorkingDirectory=/home/pi Environment=NODE_ENV=production User=pi Group=pi Restart=always # Restart service after 10 seconds if node service crashes RestartSec=10 # Set port permissions capability AmbientCapabilities=cap_net_bind_service [Install] WantedBy=multi-user.target Note that the user and group values have to be set correctly for your specific situation. Also, the ExecStart and WorkingDirectory lines includes the path to the user\u2019s home folder which includes the username in it. Make sure that is set correctly. Once this is done, you can now enable, start, stop and disable using the following commands: sudo systemctl enable meshcentral.service sudo systemctl start meshcentral.service sudo systemctl stop meshcentral.service sudo systemctl disable meshcentral.service Type in the first two commands to start and enable the service. Enabling the service will make it automatically start when the computer restarts. Once the server is launched, you can access it using a web browser as before. From this point on, refer to the MeshCentral User\u2019s Guide for information on how to configure and use MeshCentral. Ubuntu 18.04 \u00b6 In this section, we will look at installing MeshCentral on Ubuntu 18.04 LTS. This is a long term support of Ubuntu freely available for download at https://www.ubuntu.com . Both the desktop and server versions of Ubuntu will work. If this is a remote server and the desktop will not be needed, the server version of Ubuntu can be used. This section will describe a way to install MeshCentral in a user\u2019s home folder, however there is a more secure way to do it, see Increased Security Installation at the end of this section. In all cases, MeshCentral must not be installed as root user. It\u2019s not secure and the instructions below will not work correctly. Installing NodeJS \u00b6 The first thing to do is get NodeJS installed on the computer. We first install the node version manager then activate it and install the NodeJS LTS. It\u2019s done with 4 commands: sudo add-apt-repository universe sudo apt update sudo apt install nodejs -y sudo apt install npm -y We can test what version of Node and NPM are installed using: node \u2013v npm -v Installing MongoDB \u00b6 If we are going to run a large instance, it\u2019s best to use MongoDB as the database. If you are using a small instance, you can skip installing MongoDB and MeshCentral will use NeDB instead which is a light weight database that is probably great for managing less than 100 computers. If you want to use MongoDB, we can install MongoDB Community Edition. More information on how to do this for Ubuntu can be found here. You can install the package using apt and get it started like this: sudo apt install mongodb -y Then start the Mongodb service in the background and enable it for auto-restart. sudo systemctl start mongodb sudo systemctl enable mongodb To verify that MongoDB is running, you can enter the MongoDB shell like this: mongo --host 127.0.0.1:27017 You can leave the shell using Ctrl-C. The database and log files will be create at these locations: /var/log/mongodb /var/lib/mongo This is useful to know if you want to make a backup of the database file. Port permissions \u00b6 On Linux, ports below 1024 are reserved for the root user. This is a security feature. In our case MeshCentral will need to listen to ports 80 and 443. To allow this, we need to allow node to listen to ports below 1024 like this: whereis node node: /usr/bin/node /usr/include/node /usr/share/man/man1/node.1.gz sudo setcap cap_net_bind_service=+ep /usr/bin/node We first locate the node binary, using whereis node , we then use the setcap command to add permissions to node. Note that we take the path given by whereis and place it in the setcap command. The setcap command will set permissions allowing node to use ports 1024 and below. This permission may be lost when updating the Linux kernel, so this command may need to be applied again in some case. Installing MeshCentral \u00b6 Now, we can use the node package manager (NPM) to install MeshCentral. npm install meshcentral Warning Do not use sudo in front of npm install meshcentral . After that, we can run MeshCentral for the first time. For example: node ./node_modules/meshcentral If the computer has a well-known DNS name that users and agents will use to connect to this server, run MeshCentral like this: node ./node_modules/meshcentral --cert example.servername.com At this point, the server will create its certificates and start running. MeshCentral HTTP redirection web server running on port 80. Generating certificates, may take a few minutes... Generating root certificate... Generating HTTPS certificate... Generating MeshAgent certificate... Generating Intel AMT MPS certificate... Generating Intel AMT console certificate... MeshCentral Intel(R) AMT server running on ec2-54-245-141-130.us-west-2.compute.amazonaws.com:4433. MeshCentral HTTPS web server running on ec2-54-245-141-130.us-west-2.compute.amazonaws.com:443. Server has no users, next new account will be site administrator. You can now open a browser and try the server. If you can on the same computer, you navigate to this URL: http://localhost If installing on a server that does not have a desktop GUI, use a different computer and enter http:// followed by the IP address or name of the server you installed. You should see the server working as expected. You will get a certificate error since the server is used an untrusted certificate for now. Just ignore the error and see the MeshCentral User\u2019s Guide to fix this. At this point, the server is usable but, there are two things that may still need to be done. First, if we opted to use MongoDB, we have to configure MeshCentral to use a MongoDB database. By default, NeDB will be used which should only be used for small deployments managing less than 100 computers. We also need to automatically start the server when the computer starts. To continue, stop the MeshCentral server with CTRL-C. Configuring for MongoDB \u00b6 By default, MeshCentral uses NeDB with a database file located in ~/meshcentral-data/meshcentral.db. This is great for small servers, but if we opted to install MongoDB, let\u2019s make use of it. We need to edit the config.json file located in the meshcentral-data folder. pico ~/meshcentral-data/config.json Then, make the start of the file look like this: { \"settings\" : { \"MongoDb\" : \"mongodb://127.0.0.1:27017/meshcentral\" , \"WANonly\" : true , \"_Port\" : 443 , \"_RedirPort\" : 80 , \"_AllowLoginToken\" : true , \"_AllowFraming\" : true , \"_WebRTC\" : false , \"_ClickOnce\" : false , \"_UserAllowedIP\" : \"127.0.0.1,::1,192.168.0.100\" }, \u2026 } If you start with the default config.json created by MeshCentral, you will need to remove some _ characters in front of settings, mongodb and wanonly. You can also add a _ to other values. For details on all of the config.json options, including the WANonly option, refer to the MeshCentral User\u2019s Guide. You can then save the config.json file and run MeshCentral again. This time, you don\u2019t need to specify the certificate name. You just need to run it like this: node ./node_modules/meshcentral The server should now run correctly and use MongoDB. You can even delete the file ~/meshcentral-data/meshcentral.db as it\u2019s not going to be used anymore. You can check that it runs correctly by browsing to the server\u2019s address again and creating a new account. The first account that is created will be administrator for the server, so don\u2019t delay and create the first account right away. Once you are done, we can stop the server again using CTRL-C and in the next sections, we will look at starting the server in the background. Manually starting the server \u00b6 We can manually start and stop the MeshCentral server in the background in different ways. In this section, we are going to create two commands mcstart and mcstop to take care of this. Type this to create the two commands: echo \"node ./node_modules/meshcentral > stdout.txt 2> stderr.txt &\" > mcstart chmod 755 mcstart echo \"pkill \u2013f node_modules/meshcentral\" > mcstop chmod 755 mcstop You can now run the ./mcstart command to launch the server in the background and stop it using the ./mcstop to stop it. This should work pretty well, but if the AWS instance is ever stopped and started again, the server will not automatically launch. Automatically starting the server \u00b6 Since Ubuntu 18.04 supports systemd, we are going to use that to auto-start MeshCentral in the background. First, we need to know our own username and group. If we do ls -l in our home folder we get for example: drwxr-xr-x 2 default default 4096 Jul 20 00:03 Desktop drwxr-xr-x 2 default default 4096 Jul 20 00:03 Documents drwxr-xr-x 2 default default 4096 Jul 20 00:03 Downloads \u2026 Note the username and group name, in this example it\u2019s default for both. We need this information to create the system service description file. To create this file type: sudo pico /etc/systemd/system/meshcentral.service Then enter the following lines: [Unit] Description=MeshCentral Server [Service] Type=simple LimitNOFILE=1000000 ExecStart=/usr/bin/node /home/default/node_modules/meshcentral WorkingDirectory=/home/default Environment=NODE_ENV=production User=default Group=default Restart=always # Restart service after 10 seconds if node service crashes RestartSec=10 # Set port permissions capability AmbientCapabilities=cap_net_bind_service [Install] WantedBy=multi-user.target Note that the user and group values have to be set correctly for your specific situation. Also, the ExecStart and WorkingDirectory lines includes the path to the user\u2019s home folder which includes the username in it. Make sure that is set correctly. Lastly the path to node may need to be changed. Type whereis node to find the correct path. Once this is done, you can now start, enable, stop and disable using the following commands: sudo systemctl enable meshcentral.service sudo systemctl start meshcentral.service sudo systemctl stop meshcentral.service sudo systemctl disable meshcentral.service Type in the first two commands to start and enable the service. Enabling the service will make it automatically start when the computer restarts. Once the server is launched, you can access it using a web browser as before. From this point on, refer to the MeshCentral User\u2019s Guide for information on how to configure and use MeshCentral. Increased Security Installation \u00b6 On Debian based Linux distributions like Ubuntu, a better and more secure way to install MeshCentral is to have it run within a user account this restricted privileges. When installed like this, the self-update capability of MeshCentral will not work. Instead of installing MeshCentral in the user\u2019s home folder, we install it in /opt/meshcentral and we create a meshcentral user that does not have rights to login or change any of the MeshCentral files. To do this, start by creating a new user called meshcentral sudo useradd -r -d /opt/meshcentral -s /sbin/nologin meshcentral We can then create the installation folder, install and change permissions of the files so that the meshcentral account gets read-only access to the files. sudo mkdir /opt/meshcentral cd /opt/meshcentral sudo npm install meshcentral sudo -u meshcentral node ./node_modules/meshcentral The last line will run MeshCentral manually and allow it to install any missing modules and create the MeshCentral data folders. Once it\u2019s running, press CTRL-C and continue. The following two lines will change the ownership of files to the meshcentral user and restrict access to the files. sudo chown -R meshcentral:meshcentral /opt/meshcentral sudo chmod 755 \u2013R /opt/meshcentral/meshcentral-* To make this work, you will need to make MeshCentral work with MongoDB because the /meshcentral-data folder will be read-only. In addition, MeshCentral will not be able to update itself since the account does not have write access to the /node_modules files, so the update will have to be manual. First used systemctl to stop the MeshCentral server process, than use this: cd /opt/meshcentral sudo npm install meshcentral sudo -u meshcentral node ./node_modules/meshcentral sudo chown -R meshcentral:meshcentral /opt/meshcentral This will perform the update to the latest server on NPM and re-set the permissions so that the meshcentral user account has read-only access again. You can then use systemctl to make the server run again. MeshCentral allows users to upload and download files stores in the server\u2019s meshcentral-files folder. In an increased security setup, we still want the server to be able to read and write files to this folder and we can allow this with: sudo chmod 755 \u2013R /opt/meshcentral/meshcentral-files If you plan on using the increased security installation along with MeshCentral built-in Let\u2019s Encrypt support you will need to type the following commands to make the letsencrypt folder in meshcentral-data writable. sudo mkdir /opt/meshcentral/meshcentral-data sudo mkdir /opt/meshcentral/meshcentral-data/letsencrypt sudo chmod 755 \u2013R /opt/meshcentral/meshcentral-data/letsencrypt This will allow the server to get and periodically update its Let\u2019s Encrypt certificate. If this is not done, the server will generate an ACCES: permission denied exception. Microsoft Azure \u00b6 In this section, we will look installing MeshCentral on Microsoft Azure. Microsoft Azure offers many operating system options and we will be selecting Ubuntu Server as our choice. From the Azure portal, we select Virtual machines on the left and Add . Once you click on Ubuntu Server, you will see a list of available versions. In this example, we selected Ubuntu 18.04 LTS (Long Term Support). We then have to create an instance name and a way to authenticate to the instance. Next is the type of instance to launch. Any instance will do including the B1s which is the smallest possible instance. Of course, as you manage more computers, using an instance that is a bit more powerful is a good idea. After selecting the instance type, you can configure storage. 30 gigabytes is plenty. Then the Network Security Group. This is where it\u2019s important to open at least TCP ports 22, 80 and 443. Optionally if you wish to use the instance with Intel AMT, open port 4433. In addition port 8080 must be open if you are migrating from MeshCentral1 (not typical). Lastly we launch the instance, it will take a few minutes to setup. You can then find the public IP address and use a SSH client like PUTTY on Windows to connect to the instance and start getting MeshCentral setup. From this point on, just use the Ubuntu section above to complete the installation. Google Cloud \u00b6 In this section, we will look installing MeshCentral on Google Cloud. You can sign up easily at https://cloud.google.com/ and you can run a small instance for less than 5$ a month. Once you have create an account, you can go to the main console and on the left side, go to Compute Engine and create a new VM instance. For our demonstration, we are going to create the smallest instance possible which is a single shared CPU and only 0.6 gigs of RAM. We select the proper settings and select Ubuntu 18.04 LTS Minimal as the boot operating system. This is convenient as we already covered how to install MeshCentral on this operating system. Make sure to allow HTTP and HTTPS traffic. Setup like this, we will not be able to manage Intel AMT unless we also open TCP port 4433. Once done with all these options, we can launch the VM instance. The new instance will take a few minutes to start up. An interesting feature of Google Cloud is that you can access the VM instance shell directly from the web browser. No need for a separate SSH client. This is exactly what we need and we opt to go ahead and option the web console. If will log you in automatically, no additional credentials needed. We can then follow the Ubuntu 18.04 LTS section above to complete the installation. If you opt for a very small instance, it\u2019s probably a good idea to skip installing MongoDB. Just to get started quickly, we can use the following commands: sudo apt update sudo apt install nodejs -y sudo apt install npm -y sudo setcap cap_net_bind_service=+ep /usr/bin/node npm install meshcentral node ./node_modules/meshcentral --fastcert \u2013wanonly --cert 35.227.45.84 Warning Do not use sudo in front of npm install meshcentral . This will install node and npm. Will allow non-root access to ports 80 and 443 and install and start MeshCentral. Because this example uses a very small server instance, we opted to use the fastcert option to create RSA 2048 certificates (the default is RSA 3072 which is more secure). We use the wantonly option because MeshCentral will not be managing computers on a local network, and for this demonstration just used the external IP address of the instance as the server name. If you plan on using an instance without the Intel AMT CIRA port being open (TCP 4433), it\u2019s recommended to add --mpsport 0 so to inform MeshCentral that this port is not open and to not offer Intel AMT CIRA features. Of course, this set of commands is just to get the server started quickly. Follow the Ubuntu 18.04 instructions to setup the server to automatically start using system. Ubuntu 16.04 \u00b6 In this section, we will look at installing MeshCentral on Ubuntu 16.04 LTS. This is the same installation at Ubuntu 18.04 LTS, however you need to install NodeJS in a special way. If you use apt install node , you will get an older version 4.x of NodeJS that will not work with MeshCentral. Installing NodeJS \u00b6 The first thing to do is get NodeJS installed on the computer. We first install the node version manager then activate it and install the NodeJS LTS. It\u2019s done with 3 commands: cd ~ wget https://deb.nodesource.com/setup_8.x sudo bash setup_8.x sudo apt-get \u2013y install nodejs We can test what version of Node and NPM are installed using: node \u2013v npm -v You should see Node version 8 and NPM version 5. At this point, you can continue installing MeshCentral using the Ubuntu 18.04 installation instructions. OpenBSD 6.4 \u00b6 In this section, we will look at installing MeshCentral on OpenBSD 6.4. This section was originally written by Daulton and placed here with this permission. The original instructions are located at: https://daulton.ca/meshcentral-server-on-openbsd/. The section will setup MeshCentral on non-standard ports HTTPS/3000 and HTTP/3001. Thank you to Daulton for his contribution. Installing MongoDB \u00b6 Install the Mongodb package. pkg_add mongodb Start and enable Mongodb at boot. rcctl start mongod rcctl enable mongod Temporary remount /usr with wxallowed while we compile the port. For Cloud VPS they usually only have a root partition instead of how OpenBSD splits it up by default, you will need to edit /etc/fstab and add wxallowed to the options for the root partition and then reboot. Assure to remove this from the fstab options after you are done. mount -r -o wxallowed /usr/ Installing NodeJS \u00b6 Install NodeJS from ports as it is not available by a package. $ cd /tmp $ ftp https://cdn.openbsd.org/pub/OpenBSD/$(uname -r)/{ports.tar.gz,SHA256.sig} # cd /usr # tar xzf /tmp/ports.tar.gz # cd /usr/ports/lang/node # make install # make clean Installing MeshCentral \u00b6 Create the MeshCentral user. The parameters used here are important as we will not let this user login, it has no home directory, and its class is set to daemon. In line with the OpenBSD daemon user naming scheme, we preface the username with an underscore _ to make it easily identifiable as a daemon user. useradd -s /sbin/nologin -d /nonexistent -L daemon -u 446 _meshcentral Let\u2019s install MeshCentral and adjust the permissions. mkdir -p /usr/local/meshcentral cd /usr/local/meshcentral npm install meshcentral chown -R _meshcentral:_meshcentral /usr/local/meshcentral Configuring for MongoDB and adjusting some other settings such as the network port. Open up the following config in an editor then, make the start of the file look like below. If the setting does not exist yet, just add it below one of the ones we are adjusting in the main settings block. If you start with the default config.json created by MeshCentral, you will need to remove some underscore character in front of settings to enable the setting, such as mongodb and wanonly. You can also add an underscore to other values. For details on all of the config.json options, including the WANonly option, refer to the MeshCentral User\u2019s Guide. Before you can edit the configuration, start the Meshcentral briefly so it generates the default configurations and certificates. Once you see that it says \"MeshCentral HTTPS server running...\", Ctrl-C to exit then edit the configuration file next. cd /usr/local/meshcentral/node_modules/meshcentral/ && doas -u _meshcentral /usr/local/bin/node /usr/local/meshcentral/node_modules/meshcentral/meshcentral.js --launch Edit the MeshCentral config.json. For example using vi: vi /usr/local/meshcentral/meshcentral-data/config.json In the settings section, set the following key value pairs: { \"settings\" : { \"Cert\" : \"meshcentral.example.com\" , \"MongoDb\" : \"mongodb://127.0.0.1:27017/meshcentral\" , \"WANonly\" : true , \"Port\" : 3000 , \"ExactPorts\" : true , \"RedirPort\" : 3001 , \"allowLoginToken\" : true , \"allowFraming\" : true , \"NewAccounts\" : 0 , }, \u2026 } Add the following to the root crontab to start MeshCentral at boot. Edit the root crontab by doing the following command as root: crontab -e @reboot cd /usr/local/meshcentral/node_modules/meshcentral/ && doas -u _meshcentral /usr/local/bin/node /usr/local/meshcentral/node_modules/meshcentral/meshcentral.js --launch As root launch Meshcentral while it installs mongojs, once that finishes and Meshcentral launches close it by doing Ctrl-C. Adjust the permissions again as we ran Meshcentral and it generated new files we need to change the ownership of. /usr/local/bin/node /usr/local/meshcentral/node_modules/meshcentral chown -R _meshcentral:_meshcentral /usr/local/meshcentral Warning Do not keep this running or use this command in the future to start the Meshcentral server as it starts the server as root! This is a reference /etc/pf.conf for you to keep your server secure. Add any locally connected networks which should have access and any public IP address of a network which will have client PCs connect from to target_whitelist table. Add your own home and/or business IP to my_own_IPs table. ext_if = vio0 set reassemble yes set block-policy return set loginterface egress set ruleset-optimization basic set skip on lo icmp_types = \"{ 0, 8, 3, 4, 11, 30 }\" table <target_whitelist> const { 45.63.15.84, 10.18.5.0/24 } table <my_own_IPs> const { 45.63.15.84 } table <bruteforce> match in all scrub (no-df max-mss 1440) match out all scrub (no-df max-mss 1440) block in quick log from urpf-failed label uRPF block quick log from <fail2ban> block in from no-route to any block in from urpf-failed to any block in quick on $ext_if from any to 255.255.255.255 block in log quick on $ext_if from { 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 255.255.255.255/32 } to any antispoof for $ext_if block log all pass in quick inet proto icmp icmp-type $icmp_types pass in quick inet6 proto icmp6 pass in quick proto tcp from <my_own_IPs> \\ to (egress) port { 22 } \\ flags S/SA modulate state \\ (max-src-conn 5, max-src-conn-rate 5/5, overload <bruteforce> flush global) pass in quick inet proto tcp from <target_whitelist> to port 3000 pass in quick inet6 proto tcp from <target_whitelist> to port 3000 block in quick log on egress all pass out quick on egress proto tcp from any to any modulate state pass out quick on egress proto udp from any to any keep state pass out quick on egress proto icmp from any to any keep state pass out quick on egress proto icmp6 from any to any keep state After saving the configuration in /etc/pf.conf, reload the pf rules with: pfctl -f /etc/pf.conf To save rebooting and have MeshCentral launch then, launch it so you can begin using it. This time it is running as _meshcentral, now it is safe to keep running and you can use this command in the future. cd /usr/local/meshcentral/node_modules/meshcentral/ && doas -u _meshcentral /usr/local/bin/node /usr/local/meshcentral/node_modules/meshcentral/meshcentral.js --launch You can now access MeshCentral at https://youraddress:3000 or https://meshcentral.example.com:3000 if you named the machine meshcentral or create an A record named meshcentral. The first user you create will be the Administrator, there is no default user.","title":"Full Install Guide"},{"location":"install/install2/#full-install-guide","text":"","title":"Full Install Guide"},{"location":"install/install2/#abstract","text":"This guide is specifically intended to help users install MeshCentral from start to finish. Once installed, you can take a look at the MeshCentral user\u2019s guide for information on how to configure MeshCentral for your specific use. In this document, we will look at installing MeshCentral on AWS Linux, Raspberry Pi and Ubuntu.","title":"Abstract"},{"location":"install/install2/#quick-start","text":"For some who want to skip this document entirely, there are quick install scripts that will get a MeshCentral2 instance up and running on Linux in a few minutes. These scripts will pretty much do what this document explains very rapidly. Right now, there are two such scripts available:","title":"Quick Start"},{"location":"install/install2/#amazon-linux-2","text":"For Amazon EC2 users, that want to manage 100 devices or less. Launch a t3.nano or t3.micro EC2 instance with Amazon Linux 2 with TCP ports 22 (SSH), 80 (HTTP), 443 (HTTPS) and 4433 (CIRA) open. Then login as ec2-user and enter the following commands: wget http://info.meshcentral.com/scripts/mc-aws-linux2.sh chmod 755 mc-aws-linux2.sh ./mc-aws-linux2.sh This will download the fast install script and once run, will install nodejs, meshcentral, setup systemd and start the server. For a larger instance like a t3.small, t3.medium or larger you can run the following that does the same but also installs MongoDB. wget http://info.meshcentral.com/scripts/mc-aws-linux2-mongo.sh chmod 755 mc-aws-linux2-mongo.sh ./mc-aws-linux2-mongo.sh After these scripts are run, try accessing the server using a browser. MeshCentral will take a minute or two to create certificates after that, the server will be up. The first account to be created will be the site administrator \u2013 so don\u2019t delay and create an account right away. Once running, move on to the MeshCentral\u2019s user\u2019s guide to configure your new server.","title":"Amazon Linux 2"},{"location":"install/install2/#microsoft-azure","text":"For 100 devices or less, launch an instance of Ubuntu 18.04 using a small B1s instance. Set the username to default in all lower case and open ports 22, 80, 443 and 3389 using the basic network profile. Then start the instance and run the following lines. wget http://info.meshcentral.com/scripts/mc-azure-ubuntu1804.sh chmod 755 mc-azure-ubuntu1804.sh ./mc-azure-ubuntu1804.sh In this situation, port 3389 will be used to receive Intel AMT CIRA connections instead of port 4433. After these scripts are run, try accessing the server using a browser. MeshCentral will take a minute or two to create certificates after that, the server will be up. The first account to be created will be the site administrator \u2013 so don\u2019t delay and create an account right away. Once running, move on to the MeshCentral\u2019s user\u2019s guide to configure your new server.","title":"Microsoft Azure"},{"location":"install/install2/#windows-installation","text":"MeshCentral is constructed entirely with NodeJS, an asynchronous event driven JavaScript runtime (https://nodejs.org/). A basic understanding on NodeJS may be preferable but not compulsory. MeshCentral server which heavily relies on NodeJS runtime will be able run on almost any computing platform with contemporary operating systems including Windows*, Linux* and macOS*. There are two ways to get MeshCentral setup. For Linux*, macOS*, or advanced users can use CLI based NPM tool. For Windows users, you can use the MeshCentral installation tool.","title":"Windows Installation"},{"location":"install/install2/#windows-installation-tool","text":"The MeshCentral installer tool for Microsoft Windows can be downloaded at https://www.meshcommander.com/meshcentral2 or by clicking this link. This tool will automatically detect and install NodeJS if needed. NodeJS will be downloaded from https://nodejs.org checked and installed. We recommend the installer be run on a modern version of Windows (.e.g. Win8.1, Win10, Win Server 2012* or better) During installation, the installation tool will prompt for the following settings: Multi-user Server : By enabling this option, the server will be open to any user with a web browser app. Users will be able to create accounts and start managing computers associated in their respective accounts. Note If this option is disabled (unchecked), the server will run as a single-user server, no login screen will be presented and MeshCentral application will be limited to the server host machine only. Auto-update Server: By enabling this option, the server will check new version releases daily and perform automatic update. Note Update check occurs at 0000 between 0100 hours (local time). During update, the server will not be accessible until update is completed. Server Modes, LAN, WAN or Hybrid: LAN mode : Recommended for small installation within a local network. Server host does not need a fixed IP address or DNS record to operate. WAN or Hybrid modes : Server host will require a fixed IP address or DNS record to function correctly. If selected, user will need to enter server\u2019s DNS name or static IP address in the Server Name field. This name or IP address will be used by browsers and agents to connect back to the server, this name MUST be correct or the server will not work. If you do not have a fixed name, select LAN mode to get started. Acquiring a static IP or DNS record is beyond the scope of this document. Please seek advice or consult your network administrator if unsure. If unsure, leave the settings as default (as-is) and proceed setup in LAN mode to manage computers that reside within the same network. Once installed MeshCentral will run as a background Windows Service and can be accessed using a web browser with the link provided by the installer. The installation tool can be run again to perform server update, re-installation or un-installation. When performing an update check, the tool will look at the currently installed version and compare it to the one present on NPM. By default, MeshCentral will use TCP ports 80 (HTTP), 443 (HTTPS) and 4433 (Intel\u00ae AMT CIRA). The installer will add Windows Defender Firewall rules to allow incoming connections on these ports. In addition, if the server is in LAN or Hybrid mode, an addition rule on UDP port 16990 is added to allow for server discovery.","title":"Windows Installation Tool"},{"location":"install/install2/#npm-installation-for-advanced-users","text":"For advanced users or administrators, MeshCentral can be installed with NPM, a NodeJS package manager that can be accessed via web browser (https://www.npmjs.com/) or command line tool, npm . Note As a prerequisite, NodeJS and NPM must be installed on host OS and HTTP/HTTPS proxy settings maybe required if server host resides behind a HTTP proxy server. To begin, start a command line terminal (Windows Command Prompt or Linux Terminal) and type the following to verify if nodeJS and npm has been installed correctly as shown below a. To check on nodeJS installed version, type node \u2013v and hit enter key b. To check on npm installed version, type npm \u2013v and hit enter key If MeshCentral installation is performed on a server host that resides behind a HTTP proxy, NPM\u2019s proxy settings must be updated with respective proxy settings associated with the network environment. Skip this step if not applicable. .e.g. for http proxy `npm config set proxy http://proxy.com:88` .e.g. for https proxy `npm config set https-proxy http://proxy.com:88` Create a new directory MeshCentral and run the NPM install command as shown below: mkdir meshcentral cd meshcentral npm install meshcentral Warning : Do not use sudo in front of npm install meshcentral . Upon download completion, the server can be started with the commands below: node node_modules/meshcentral [arguments] Warning : Do not run MeshCentral by going into the node_modules/meshcentral folder as this may cause auto-install and self-update features to fail. Instead, go into the directory above node_modules and run node node_modules/meshcentral . Note : If MeshCentral is started without any arguments, default settings in LAN-only mode will be in effect and user/administrator will only be able to manage computers that reside within the local network. To manage computers over the internet, the server needs to have static IP settings or a DNS record that resolves back to the right server. The mesh agents will be using the mechanism to call home to MeshCentral server. For WAN or Hybrid mode, run one of the commands below node node_modules/meshcentral --cert servername.domain.com node node_modules/meshcentral --cert hostname.domain.com node node_modules/meshcentral --cert 1.2.3.4 Note : On first attempt running on WAN or Hybrid Mode: Certificates will be generated for the first time and this may take a few minutes to complete. Note At this point, no user account will be created or available for the user hence 1 st user account will be the most privileged user with Administrator rights User is advised to create an admin account immediately by navigating to https://127.0.0.1 with a web browser. Note : To run MeshCentral as a service, run it using --install argument. Once running, start a web browser and access MeshCentral application with respective URL.","title":"NPM Installation for Advanced Users"},{"location":"install/install2/#windows-defender-firewall-settings","text":"On Windows, the built-in firewall will need to be configured to allow TCP ports 80, 443 and 4433 and sometimes UDP port 16990. The MeshCentral Windows Installer will add incoming rules for these ports automatically. If using the advanced NPM installation or when changing the default ports, it may be needed to add or edit these firewall rules. In this section we look at how to do this. To get started, we need to go in the control panel, click System and Security then Windows Defender Firewall and Advanced Settings on the left side then click on Inbound rules . This will get us on the right place to add or edit firewall rules. If the MeshCentral Windows Installer was used, the MeshCentral Server TCP ports and optionally MeshCentral Server UDP ports rules should already be present.","title":"Windows Defender Firewall Settings"},{"location":"install/install2/#editing-the-existing-rules","text":"To edit an existing rule, simply double click on it. To change the allowed inbound ports, go to the Protocols and Ports tab and change the local ports.","title":"Editing the existing rules"},{"location":"install/install2/#add-new-firewall-rules","text":"To add a new firewall rule, click on the New Rule\u2026 then select Port and ok. TCP or UDP and enter the specific local ports needed and ok. Then click ok twice, enter the rule name and ok again. Typically, inbound TCP ports 80, 443 and 4433 are used, but the rule can be added with different ports as needed.","title":"Add new firewall rules"},{"location":"install/install2/#amazon-linux-2_1","text":"In this section, we will look at installing MeshCentral on Amazon AWS with Amazon Linux 2 . This is a low cost instance and a free tier is available so you can experiment or run a small instance of MeshCentral and it will work perfectly fine.","title":"Amazon Linux 2"},{"location":"install/install2/#getting-the-aws-instance-setup","text":"On AWS EC2, you can launch an instance and select Amazon Linux 2 . In this case, it\u2019s the first option available. When launching a new instance, you are asked to use or create a security group with the allowed inbound TCP and UDP ports. The security group should look like this: All security group rules should have a source of 0.0.0.0/0 and ::/0 . The last rule for port 8080 is only needed if migrating from a MeshCentral1 server, most people don\u2019t need it and should not be added. If you are not going to be managing Intel AMT computers, you can remove port 4433. One can also remove port 80, however it\u2019s needed to get a Let\u2019s Encrypt certificate and useful to route users from the HTTP to the HTTPS web page. For all the following sections, we assume that we are in the ec2-user home path. You can do: cd ~ This will change the current path to the home folder.","title":"Getting the AWS instance setup"},{"location":"install/install2/#installing-nodejs","text":"To get started, launch an instance and start a SSH session to it. You can use SSH on Linux or Putty on Windows to login to the AWS instance. The first thing to do is get NodeJS installed on the instance. We will be installing a long term support (LTS) version of NodeJS. Additional information on how to do this can be found here. We first install the node version manager then activate it and install the NodeJS LTS. It\u2019s done with 3 commands: curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash . ~/.nvm/nvm.sh nvm install --lts We can test what version of NodeJS is installed using: node -v","title":"Installing NodeJS"},{"location":"install/install2/#installing-mongodb","text":"If we are going to run a large instance, it\u2019s best to use MongoDB as the database. If you are using a small instance, you can skip installing MongoDB and MeshCentral will use NeDB instead which is a light weight database that is probably great for managing less than 100 computers. If you want to use MongoDB, we can install MongoDB Community Edition. More information on how to do this can be found here. Using nano create the file /etc/yum.repos.d/mongodb-org-4.0.repo : sudo nano /etc/yum.repos.d/mongodb-org-4.0.repo Then, put this in it: [mongodb-org-4.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/amazon/2/mongodb-org/4.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc This file will setup the repository that we will be using to bet MongoDB. Once done, you can install the package using yum and get it started like this: sudo yum install -y mongodb-org sudo service mongod start To verify that MongoDB is running, you can enter the MongoDB shell like this: mongo --host 127.0.0.1:27017 You can leave the shell using Ctrl-C. The database and log files will be create at these locations: /var/log/mongodb /var/lib/mongo This is useful to know if you want to make a backup of the database file.","title":"Installing MongoDB"},{"location":"install/install2/#port-permissions","text":"On Linux, ports below 1024 are reserved for the root user. This is a security feature. In our case MeshCentral will need to listen to ports 80 and 443. To allow this, we need to allow node to listen to ports below 1024 like this: whereis node node: /home/ec2-user/.nvm/versions/node/v8.11.3/bin/node sudo setcap cap_net_bind_service=+ep /home/ec2-user/.nvm/versions/node/v8.11.3/bin/node We first locate the node binary, using whereis node , we then use the setcap command to add permissions to node. Note that we take the path given by whereis and place it in the setcap command. The setcap command will set permissions allowing node to use ports 1024 and below. This permission may be lost when updating the Linux kernel, so this command may need to be applied again in some case.","title":"Port permissions"},{"location":"install/install2/#installing-meshcentral","text":"It\u2019s almost time to install MeshCentral but first, we need to know the public name of our AWS instance, you can run the following command: curl http://169.254.169.254/latest/meta-data/public-hostname It will return the public name of the AWS instance, for example: ec2-1-2-3-4.us-west-2.compute.amazonaws.com You can use this name, or if you have another registered DNS name pointing to the server instance, you can also use that now. Note that you must setup any alternative name on your own, MeshCentral will not do this for you. This name must be correct and must resolve to this AWS instance as all mesh agents will use this name to connect back to this server. Now, we can use the node package manager (NPM) to install MeshCentral. npm install meshcentral Warning Do not use sudo in front of npm install meshcentral . After that, we can run MeshCentral for the first time. We want to run in WAN-only mode since we will not be managing any computers on the same local network at this server. We also want to create a server with a certificate name that is the same at the AWS instance name. So, we will use --wanonly and --cert [name] arguments to get the server started. For example: node ./node_modules/meshcentral --wanonly --cert ec2-1-2-3-4.us-west-2.compute.amazonaws.com At this point, the server will create its certificates and start running. MeshCentral HTTP redirection web server running on port 80. Generating certificates, may take a few minutes... Generating root certificate... Generating HTTPS certificate... Generating MeshAgent certificate... Generating Intel AMT MPS certificate... Generating Intel AMT console certificate... MeshCentral Intel(R) AMT server running on ec2-54-245-141-130.us-west-2.compute.amazonaws.com:4433. MeshCentral HTTPS web server running on ec2-54-245-141-130.us-west-2.compute.amazonaws.com:443. Server has no users, next new account will be site administrator. You can now open a browser to the name of the server, for example: https://ec2-1-2-3-4.us-west-2.compute.amazonaws.com You will see the server working as expected. You will get a certificate error since the server is used an untrusted certificate for now. Just ignore the error and see the MeshCentral User\u2019s Guide to fix this. At this point, the server is usable but, there are two things that may still need to be done. First, if we opted to use MongoDB, we have to configure MeshCentral to use a MongoDB database. By default, NeDB will be used which should only be used for small deployments managing less than 100 computers. We also need to automatically start the server when the AWS instance starts. To continue, stop the MeshCentral server with CTRL-C.","title":"Installing MeshCentral"},{"location":"install/install2/#configuring-for-mongodb","text":"By default, MeshCentral uses NeDB with a database file located in ~/meshcentral-data/meshcentral.db. This is great for small servers, but if we opted to install MongoDB, let\u2019s make use of it. We need to edit the config.json file located in the meshcentral-data folder. nano ~/meshcentral-data/config.json Then, make the start of the file look like this: { \"settings\" : { \"MongoDb\" : \"mongodb://127.0.0.1:27017/meshcentral\" , \"WANonly\" : true , \"_Port\" : 443 , \"_RedirPort\" : 80 , \"_AllowLoginToken\" : true , \"_AllowFraming\" : true , \"_WebRTC\" : false , \"_ClickOnce\" : false , \"_UserAllowedIP\" : \"127.0.0.1,::1,192.168.0.100\" }, \u2026 } If you start with the default config.json created by MeshCentral, you will need to remove some _ characters in front of settings, mongodb and wanonly. You can also add a _ to other values. You can then same the same and run MeshCentral again. This time, you don\u2019t need to specify the certificate name or --wanonly . You just need to run it like this: node ./node_modules/meshcentral The server should now run correctly and use MongoDB. You can even delete the file ~/meshcentral-data/meshcentral.db as it\u2019s not going to be used anymore. You can check that it runs correctly by browsing to the server\u2019s address again and creating a new account. The first account that is created will be administrator for the server, so don\u2019t delay and create the first account right away. Once you are done, we can stop the server again using CTRL-C and in the next sections, we will look at starting the server in the background.","title":"Configuring for MongoDB"},{"location":"install/install2/#manually-starting-the-server","text":"We can manually start and stop the MeshCentral server in the background in different ways. In this section, we are going to create two commands mcstart and mcstop to take care of this. Type this to create the two commands: echo \"node ./node_modules/meshcentral > stdout.txt 2> stderr.txt &\" > mcstart chmod 755 mcstart echo \"pkill \u2013f node_modules/meshcentral\" > mcstop chmod 755 mcstop You can now run the ./mcstart command to launch the server in the background and stop it using the ./mcstop to stop it. This should work pretty well, but if the AWS instance is ever stopped and started again, the server will not automatically launch.","title":"Manually starting the server"},{"location":"install/install2/#automatically-starting-the-server","text":"Since Amazon Linux 2 supports systemd, we are going to use that to auto-start MeshCentral in the background. First, we need to know our own username and group. If we do ls -l in our home folder we get for example: drwxr-xr-x 2 default default 4096 Jul 20 00:03 Desktop drwxr-xr-x 2 default default 4096 Jul 20 00:03 Documents drwxr-xr-x 2 default default 4096 Jul 20 00:03 Downloads \u2026 Note the username and group name, in this example it\u2019s default for both. We need this information to create the system service description file. To create this file type: sudo pico /etc/systemd/system/meshcentral.service Then enter the following lines: [Unit] Description=MeshCentral Server [Service] Type=simple LimitNOFILE=1000000 ExecStart=/usr/bin/node /home/default/node_modules/meshcentral WorkingDirectory=/home/default Environment=NODE_ENV=production User=default Group=default Restart=always # Restart service after 10 seconds if node service crashes RestartSec=10 # Set port permissions capability AmbientCapabilities=cap_net_bind_service [Install] WantedBy=multi-user.target Note that the user and group values have to be set correctly for your specific situation. Also, the ExecStart and WorkingDirectory lines includes the path to the user\u2019s home folder which includes the username in it. Make sure that is set correctly. Once this is done, you can now start, enable, stop and disable using the following commands: sudo systemctl enable meshcentral.service sudo systemctl start meshcentral.service sudo systemctl stop meshcentral.service sudo systemctl disable meshcentral.service Type in the first two commands to start and enable the service. Enabling the service will make it automatically start when the computer restarts. Once the server is launched, you can access it using a web browser as before. From this point on, refer to the MeshCentral User\u2019s Guide for information on how to configure and use MeshCentral.","title":"Automatically starting the server"},{"location":"install/install2/#raspberry-pi","text":"In this section, we will look at installing MeshCentral on the famous Raspberry Pi. This computer\u2019s low price makes it a perfect always-on system for managing computers on a home or small business network. This installation will work on any version of the Raspberry Pi, but version 3 certainly much faster. For this installation, we are going to use the Raspbian operating system. You can use the NOOBS version to install this operating system on your Raspberry Pi and install Raspbian. For best performance you can use the Raspbian Stretch Lite image which is much smaller and does not have the X desktop interface. To keep things even smaller, we are not going to be installing MongoDB, instead we are just going to be using NeBD as a database that comes by default with MeshCentral.","title":"Raspberry Pi"},{"location":"install/install2/#installing-nodejs_1","text":"Start by opening a terminal. For all of the installation, we will assume we are the default pi user and we are in the home (~) folder. Let\u2019s get started by installing NodeJS. sudo apt-get update sudo apt-get dist-upgrade curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash sudo apt-get -y install nodejs We can now check what version of Node was installed by typing: node -v If all goes well, we can now move on to port permissions and installing MeshCentral itself.","title":"Installing NodeJS"},{"location":"install/install2/#port-permissions_1","text":"On Linux, ports below 1024 are reserved for the root user. This is a security feature. In our case MeshCentral will need to listen to ports 80 and 443. To allow this, we need to allow node to listen to ports below 1024 like this: whereis node node: /usr/bin/node /usr/include/node /usr/share/man/man1/node.1.gz sudo setcap cap_net_bind_service=+ep /usr/bin/node We first locate the node binary, using whereis node , we then use the setcap command to add permissions to node. Note that we take the path given by whereis and place it in the setcap command. The setcap command will set permissions allowing node to use ports 1024 and below. This permission may be lost when updating the Linux kernel, so this command may need to be applied again in some case.","title":"Port permissions"},{"location":"install/install2/#installing-meshcentral_1","text":"Now, we can use the Node Package Manager (NPM) to install MeshCentral. npm install meshcentral Warning Do not use sudo in front of npm install meshcentral . After that, we can run MeshCentral for the first time. We want to run in WAN-only mode since we will not be managing any computers on the same local network at this server. We also want to create a server with a certificate name that is the same at the AWS instance name. So, we will use --wanonly and --cert [name] arguments to get the server started. For example: node node_modules/meshcentral --lanonly --fastcert At this point, the server will create its certificates and start running. MeshCentral HTTP redirection web server running on port 80. Generating certificates, may take a few minutes... Generating root certificate... Generating HTTPS certificate... Generating MeshAgent certificate... Generating Intel AMT MPS certificate... Generating Intel AMT console certificate... Server name not configured, running in LAN-only mode. MeshCentral HTTPS web server running on port 443. Server has no users, next new account will be site administrator. The next step is to get the IP address of the Raspberry Pi. Use ipconfig : eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.2.162 netmask 255.255.255.0 broadcast 192.168.2.255 inet6 fe80::8841:34b7:685:14a7 prefixlen 64 scopeid 0x20<link> ether b8:27:eb:01:13:3f txqueuelen 1000 (Ethernet) RX packets 58325 bytes 72302196 (68.9 MiB) RX errors 0 dropped 271 overruns 0 frame 0 TX packets 28457 bytes 3576126 (3.4 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 You can now open a browser to the name of the server, for example: https://192.168.2.162 You will see the server working as expected. You will get a certificate error since the server is used an untrusted certificate for now. Just ignore the error and see the MeshCentral User\u2019s Guide to fix this.","title":"Installing MeshCentral"},{"location":"install/install2/#configuring-for-lan-only-mode","text":"By default, MeshCentral will assume that you are managing devices both on a local network and on the internet. In the case of this Raspberry Pi installation, we only want to manage device on the local network and so, we can configure MeshCentral to do this. It will adapt the server for this usages. To do this, edit the config.json file: pico ~/meshcentral-data/config.json Then, make the start of the file look like this: { \"settings\" : { \"LANonly\" : true , \"FastCert\" : true , \"_Port\" : 443 , \"_RedirPort\" : 80 , \"_AllowLoginToken\" : true , \"_AllowFraming\" : true , \"_WebRTC\" : false , \"_ClickOnce\" : false , \"_UserAllowedIP\" : \"127.0.0.1,::1,192.168.0.100\" }, \u2026 } While we are at it, we can put FastCert to true so that RSA2048 certificates are created instead of RSA3072. This is less secure but runs much faster on small processors like the Raspberry Pi. This is the same as specifying `--fastcert\" in the prior section.","title":"Configuring for LAN-only mode"},{"location":"install/install2/#manually-starting-the-server_1","text":"We can manually start and stop the MeshCentral server in the background in different ways. In this section, we are going to create two commands mcstart and mcstop to take care of this. Type this to create the two commands: echo \"node ./node_modules/meshcentral > stdout.txt 2> stderr.txt &\" > mcstart chmod 755 mcstart echo \"pkill -f node_modules/meshcentral\" > mcstop chmod 755 mcstop You can now run the ./mcstart command to launch the server in the background and stop it using the ./mcstop to stop it. This should work pretty well, but if the AWS instance is ever stopped and started again, the server will not automatically launch.","title":"Manually starting the server"},{"location":"install/install2/#automatically-starting-the-server_1","text":"Since Raspbian OS supports systemd, we are going to use that to auto-start MeshCentral in the background. First, we need to know our own username and group. If we do ls -l in our home folder we drwxr-xr-x 2 pi pi 4096 Jul 19 21:23 Desktop drwxr-xr-x 2 pi pi 4096 Jun 26 18:23 Documents drwxr-xr-x 2 pi pi 4096 Jun 26 18:23 Downloads \u2026 Note the username and group name, in this example it\u2019s pi for both. We need this information to create the system service description file. To create this file type: sudo nano /etc/systemd/system/meshcentral.service Then enter the following lines: [Unit] Description=MeshCentral Server [Service] Type=simple LimitNOFILE=1000000 ExecStart=/usr/bin/node /home/pi/node_modules/meshcentral WorkingDirectory=/home/pi Environment=NODE_ENV=production User=pi Group=pi Restart=always # Restart service after 10 seconds if node service crashes RestartSec=10 # Set port permissions capability AmbientCapabilities=cap_net_bind_service [Install] WantedBy=multi-user.target Note that the user and group values have to be set correctly for your specific situation. Also, the ExecStart and WorkingDirectory lines includes the path to the user\u2019s home folder which includes the username in it. Make sure that is set correctly. Once this is done, you can now enable, start, stop and disable using the following commands: sudo systemctl enable meshcentral.service sudo systemctl start meshcentral.service sudo systemctl stop meshcentral.service sudo systemctl disable meshcentral.service Type in the first two commands to start and enable the service. Enabling the service will make it automatically start when the computer restarts. Once the server is launched, you can access it using a web browser as before. From this point on, refer to the MeshCentral User\u2019s Guide for information on how to configure and use MeshCentral.","title":"Automatically starting the server"},{"location":"install/install2/#ubuntu-1804","text":"In this section, we will look at installing MeshCentral on Ubuntu 18.04 LTS. This is a long term support of Ubuntu freely available for download at https://www.ubuntu.com . Both the desktop and server versions of Ubuntu will work. If this is a remote server and the desktop will not be needed, the server version of Ubuntu can be used. This section will describe a way to install MeshCentral in a user\u2019s home folder, however there is a more secure way to do it, see Increased Security Installation at the end of this section. In all cases, MeshCentral must not be installed as root user. It\u2019s not secure and the instructions below will not work correctly.","title":"Ubuntu 18.04"},{"location":"install/install2/#installing-nodejs_2","text":"The first thing to do is get NodeJS installed on the computer. We first install the node version manager then activate it and install the NodeJS LTS. It\u2019s done with 4 commands: sudo add-apt-repository universe sudo apt update sudo apt install nodejs -y sudo apt install npm -y We can test what version of Node and NPM are installed using: node \u2013v npm -v","title":"Installing NodeJS"},{"location":"install/install2/#installing-mongodb_1","text":"If we are going to run a large instance, it\u2019s best to use MongoDB as the database. If you are using a small instance, you can skip installing MongoDB and MeshCentral will use NeDB instead which is a light weight database that is probably great for managing less than 100 computers. If you want to use MongoDB, we can install MongoDB Community Edition. More information on how to do this for Ubuntu can be found here. You can install the package using apt and get it started like this: sudo apt install mongodb -y Then start the Mongodb service in the background and enable it for auto-restart. sudo systemctl start mongodb sudo systemctl enable mongodb To verify that MongoDB is running, you can enter the MongoDB shell like this: mongo --host 127.0.0.1:27017 You can leave the shell using Ctrl-C. The database and log files will be create at these locations: /var/log/mongodb /var/lib/mongo This is useful to know if you want to make a backup of the database file.","title":"Installing MongoDB"},{"location":"install/install2/#port-permissions_2","text":"On Linux, ports below 1024 are reserved for the root user. This is a security feature. In our case MeshCentral will need to listen to ports 80 and 443. To allow this, we need to allow node to listen to ports below 1024 like this: whereis node node: /usr/bin/node /usr/include/node /usr/share/man/man1/node.1.gz sudo setcap cap_net_bind_service=+ep /usr/bin/node We first locate the node binary, using whereis node , we then use the setcap command to add permissions to node. Note that we take the path given by whereis and place it in the setcap command. The setcap command will set permissions allowing node to use ports 1024 and below. This permission may be lost when updating the Linux kernel, so this command may need to be applied again in some case.","title":"Port permissions"},{"location":"install/install2/#installing-meshcentral_2","text":"Now, we can use the node package manager (NPM) to install MeshCentral. npm install meshcentral Warning Do not use sudo in front of npm install meshcentral . After that, we can run MeshCentral for the first time. For example: node ./node_modules/meshcentral If the computer has a well-known DNS name that users and agents will use to connect to this server, run MeshCentral like this: node ./node_modules/meshcentral --cert example.servername.com At this point, the server will create its certificates and start running. MeshCentral HTTP redirection web server running on port 80. Generating certificates, may take a few minutes... Generating root certificate... Generating HTTPS certificate... Generating MeshAgent certificate... Generating Intel AMT MPS certificate... Generating Intel AMT console certificate... MeshCentral Intel(R) AMT server running on ec2-54-245-141-130.us-west-2.compute.amazonaws.com:4433. MeshCentral HTTPS web server running on ec2-54-245-141-130.us-west-2.compute.amazonaws.com:443. Server has no users, next new account will be site administrator. You can now open a browser and try the server. If you can on the same computer, you navigate to this URL: http://localhost If installing on a server that does not have a desktop GUI, use a different computer and enter http:// followed by the IP address or name of the server you installed. You should see the server working as expected. You will get a certificate error since the server is used an untrusted certificate for now. Just ignore the error and see the MeshCentral User\u2019s Guide to fix this. At this point, the server is usable but, there are two things that may still need to be done. First, if we opted to use MongoDB, we have to configure MeshCentral to use a MongoDB database. By default, NeDB will be used which should only be used for small deployments managing less than 100 computers. We also need to automatically start the server when the computer starts. To continue, stop the MeshCentral server with CTRL-C.","title":"Installing MeshCentral"},{"location":"install/install2/#configuring-for-mongodb_1","text":"By default, MeshCentral uses NeDB with a database file located in ~/meshcentral-data/meshcentral.db. This is great for small servers, but if we opted to install MongoDB, let\u2019s make use of it. We need to edit the config.json file located in the meshcentral-data folder. pico ~/meshcentral-data/config.json Then, make the start of the file look like this: { \"settings\" : { \"MongoDb\" : \"mongodb://127.0.0.1:27017/meshcentral\" , \"WANonly\" : true , \"_Port\" : 443 , \"_RedirPort\" : 80 , \"_AllowLoginToken\" : true , \"_AllowFraming\" : true , \"_WebRTC\" : false , \"_ClickOnce\" : false , \"_UserAllowedIP\" : \"127.0.0.1,::1,192.168.0.100\" }, \u2026 } If you start with the default config.json created by MeshCentral, you will need to remove some _ characters in front of settings, mongodb and wanonly. You can also add a _ to other values. For details on all of the config.json options, including the WANonly option, refer to the MeshCentral User\u2019s Guide. You can then save the config.json file and run MeshCentral again. This time, you don\u2019t need to specify the certificate name. You just need to run it like this: node ./node_modules/meshcentral The server should now run correctly and use MongoDB. You can even delete the file ~/meshcentral-data/meshcentral.db as it\u2019s not going to be used anymore. You can check that it runs correctly by browsing to the server\u2019s address again and creating a new account. The first account that is created will be administrator for the server, so don\u2019t delay and create the first account right away. Once you are done, we can stop the server again using CTRL-C and in the next sections, we will look at starting the server in the background.","title":"Configuring for MongoDB"},{"location":"install/install2/#manually-starting-the-server_2","text":"We can manually start and stop the MeshCentral server in the background in different ways. In this section, we are going to create two commands mcstart and mcstop to take care of this. Type this to create the two commands: echo \"node ./node_modules/meshcentral > stdout.txt 2> stderr.txt &\" > mcstart chmod 755 mcstart echo \"pkill \u2013f node_modules/meshcentral\" > mcstop chmod 755 mcstop You can now run the ./mcstart command to launch the server in the background and stop it using the ./mcstop to stop it. This should work pretty well, but if the AWS instance is ever stopped and started again, the server will not automatically launch.","title":"Manually starting the server"},{"location":"install/install2/#automatically-starting-the-server_2","text":"Since Ubuntu 18.04 supports systemd, we are going to use that to auto-start MeshCentral in the background. First, we need to know our own username and group. If we do ls -l in our home folder we get for example: drwxr-xr-x 2 default default 4096 Jul 20 00:03 Desktop drwxr-xr-x 2 default default 4096 Jul 20 00:03 Documents drwxr-xr-x 2 default default 4096 Jul 20 00:03 Downloads \u2026 Note the username and group name, in this example it\u2019s default for both. We need this information to create the system service description file. To create this file type: sudo pico /etc/systemd/system/meshcentral.service Then enter the following lines: [Unit] Description=MeshCentral Server [Service] Type=simple LimitNOFILE=1000000 ExecStart=/usr/bin/node /home/default/node_modules/meshcentral WorkingDirectory=/home/default Environment=NODE_ENV=production User=default Group=default Restart=always # Restart service after 10 seconds if node service crashes RestartSec=10 # Set port permissions capability AmbientCapabilities=cap_net_bind_service [Install] WantedBy=multi-user.target Note that the user and group values have to be set correctly for your specific situation. Also, the ExecStart and WorkingDirectory lines includes the path to the user\u2019s home folder which includes the username in it. Make sure that is set correctly. Lastly the path to node may need to be changed. Type whereis node to find the correct path. Once this is done, you can now start, enable, stop and disable using the following commands: sudo systemctl enable meshcentral.service sudo systemctl start meshcentral.service sudo systemctl stop meshcentral.service sudo systemctl disable meshcentral.service Type in the first two commands to start and enable the service. Enabling the service will make it automatically start when the computer restarts. Once the server is launched, you can access it using a web browser as before. From this point on, refer to the MeshCentral User\u2019s Guide for information on how to configure and use MeshCentral.","title":"Automatically starting the server"},{"location":"install/install2/#increased-security-installation","text":"On Debian based Linux distributions like Ubuntu, a better and more secure way to install MeshCentral is to have it run within a user account this restricted privileges. When installed like this, the self-update capability of MeshCentral will not work. Instead of installing MeshCentral in the user\u2019s home folder, we install it in /opt/meshcentral and we create a meshcentral user that does not have rights to login or change any of the MeshCentral files. To do this, start by creating a new user called meshcentral sudo useradd -r -d /opt/meshcentral -s /sbin/nologin meshcentral We can then create the installation folder, install and change permissions of the files so that the meshcentral account gets read-only access to the files. sudo mkdir /opt/meshcentral cd /opt/meshcentral sudo npm install meshcentral sudo -u meshcentral node ./node_modules/meshcentral The last line will run MeshCentral manually and allow it to install any missing modules and create the MeshCentral data folders. Once it\u2019s running, press CTRL-C and continue. The following two lines will change the ownership of files to the meshcentral user and restrict access to the files. sudo chown -R meshcentral:meshcentral /opt/meshcentral sudo chmod 755 \u2013R /opt/meshcentral/meshcentral-* To make this work, you will need to make MeshCentral work with MongoDB because the /meshcentral-data folder will be read-only. In addition, MeshCentral will not be able to update itself since the account does not have write access to the /node_modules files, so the update will have to be manual. First used systemctl to stop the MeshCentral server process, than use this: cd /opt/meshcentral sudo npm install meshcentral sudo -u meshcentral node ./node_modules/meshcentral sudo chown -R meshcentral:meshcentral /opt/meshcentral This will perform the update to the latest server on NPM and re-set the permissions so that the meshcentral user account has read-only access again. You can then use systemctl to make the server run again. MeshCentral allows users to upload and download files stores in the server\u2019s meshcentral-files folder. In an increased security setup, we still want the server to be able to read and write files to this folder and we can allow this with: sudo chmod 755 \u2013R /opt/meshcentral/meshcentral-files If you plan on using the increased security installation along with MeshCentral built-in Let\u2019s Encrypt support you will need to type the following commands to make the letsencrypt folder in meshcentral-data writable. sudo mkdir /opt/meshcentral/meshcentral-data sudo mkdir /opt/meshcentral/meshcentral-data/letsencrypt sudo chmod 755 \u2013R /opt/meshcentral/meshcentral-data/letsencrypt This will allow the server to get and periodically update its Let\u2019s Encrypt certificate. If this is not done, the server will generate an ACCES: permission denied exception.","title":"Increased Security Installation"},{"location":"install/install2/#microsoft-azure_1","text":"In this section, we will look installing MeshCentral on Microsoft Azure. Microsoft Azure offers many operating system options and we will be selecting Ubuntu Server as our choice. From the Azure portal, we select Virtual machines on the left and Add . Once you click on Ubuntu Server, you will see a list of available versions. In this example, we selected Ubuntu 18.04 LTS (Long Term Support). We then have to create an instance name and a way to authenticate to the instance. Next is the type of instance to launch. Any instance will do including the B1s which is the smallest possible instance. Of course, as you manage more computers, using an instance that is a bit more powerful is a good idea. After selecting the instance type, you can configure storage. 30 gigabytes is plenty. Then the Network Security Group. This is where it\u2019s important to open at least TCP ports 22, 80 and 443. Optionally if you wish to use the instance with Intel AMT, open port 4433. In addition port 8080 must be open if you are migrating from MeshCentral1 (not typical). Lastly we launch the instance, it will take a few minutes to setup. You can then find the public IP address and use a SSH client like PUTTY on Windows to connect to the instance and start getting MeshCentral setup. From this point on, just use the Ubuntu section above to complete the installation.","title":"Microsoft Azure"},{"location":"install/install2/#google-cloud","text":"In this section, we will look installing MeshCentral on Google Cloud. You can sign up easily at https://cloud.google.com/ and you can run a small instance for less than 5$ a month. Once you have create an account, you can go to the main console and on the left side, go to Compute Engine and create a new VM instance. For our demonstration, we are going to create the smallest instance possible which is a single shared CPU and only 0.6 gigs of RAM. We select the proper settings and select Ubuntu 18.04 LTS Minimal as the boot operating system. This is convenient as we already covered how to install MeshCentral on this operating system. Make sure to allow HTTP and HTTPS traffic. Setup like this, we will not be able to manage Intel AMT unless we also open TCP port 4433. Once done with all these options, we can launch the VM instance. The new instance will take a few minutes to start up. An interesting feature of Google Cloud is that you can access the VM instance shell directly from the web browser. No need for a separate SSH client. This is exactly what we need and we opt to go ahead and option the web console. If will log you in automatically, no additional credentials needed. We can then follow the Ubuntu 18.04 LTS section above to complete the installation. If you opt for a very small instance, it\u2019s probably a good idea to skip installing MongoDB. Just to get started quickly, we can use the following commands: sudo apt update sudo apt install nodejs -y sudo apt install npm -y sudo setcap cap_net_bind_service=+ep /usr/bin/node npm install meshcentral node ./node_modules/meshcentral --fastcert \u2013wanonly --cert 35.227.45.84 Warning Do not use sudo in front of npm install meshcentral . This will install node and npm. Will allow non-root access to ports 80 and 443 and install and start MeshCentral. Because this example uses a very small server instance, we opted to use the fastcert option to create RSA 2048 certificates (the default is RSA 3072 which is more secure). We use the wantonly option because MeshCentral will not be managing computers on a local network, and for this demonstration just used the external IP address of the instance as the server name. If you plan on using an instance without the Intel AMT CIRA port being open (TCP 4433), it\u2019s recommended to add --mpsport 0 so to inform MeshCentral that this port is not open and to not offer Intel AMT CIRA features. Of course, this set of commands is just to get the server started quickly. Follow the Ubuntu 18.04 instructions to setup the server to automatically start using system.","title":"Google Cloud"},{"location":"install/install2/#ubuntu-1604","text":"In this section, we will look at installing MeshCentral on Ubuntu 16.04 LTS. This is the same installation at Ubuntu 18.04 LTS, however you need to install NodeJS in a special way. If you use apt install node , you will get an older version 4.x of NodeJS that will not work with MeshCentral.","title":"Ubuntu 16.04"},{"location":"install/install2/#installing-nodejs_3","text":"The first thing to do is get NodeJS installed on the computer. We first install the node version manager then activate it and install the NodeJS LTS. It\u2019s done with 3 commands: cd ~ wget https://deb.nodesource.com/setup_8.x sudo bash setup_8.x sudo apt-get \u2013y install nodejs We can test what version of Node and NPM are installed using: node \u2013v npm -v You should see Node version 8 and NPM version 5. At this point, you can continue installing MeshCentral using the Ubuntu 18.04 installation instructions.","title":"Installing NodeJS"},{"location":"install/install2/#openbsd-64","text":"In this section, we will look at installing MeshCentral on OpenBSD 6.4. This section was originally written by Daulton and placed here with this permission. The original instructions are located at: https://daulton.ca/meshcentral-server-on-openbsd/. The section will setup MeshCentral on non-standard ports HTTPS/3000 and HTTP/3001. Thank you to Daulton for his contribution.","title":"OpenBSD 6.4"},{"location":"install/install2/#installing-mongodb_2","text":"Install the Mongodb package. pkg_add mongodb Start and enable Mongodb at boot. rcctl start mongod rcctl enable mongod Temporary remount /usr with wxallowed while we compile the port. For Cloud VPS they usually only have a root partition instead of how OpenBSD splits it up by default, you will need to edit /etc/fstab and add wxallowed to the options for the root partition and then reboot. Assure to remove this from the fstab options after you are done. mount -r -o wxallowed /usr/","title":"Installing MongoDB"},{"location":"install/install2/#installing-nodejs_4","text":"Install NodeJS from ports as it is not available by a package. $ cd /tmp $ ftp https://cdn.openbsd.org/pub/OpenBSD/$(uname -r)/{ports.tar.gz,SHA256.sig} # cd /usr # tar xzf /tmp/ports.tar.gz # cd /usr/ports/lang/node # make install # make clean","title":"Installing NodeJS"},{"location":"install/install2/#installing-meshcentral_3","text":"Create the MeshCentral user. The parameters used here are important as we will not let this user login, it has no home directory, and its class is set to daemon. In line with the OpenBSD daemon user naming scheme, we preface the username with an underscore _ to make it easily identifiable as a daemon user. useradd -s /sbin/nologin -d /nonexistent -L daemon -u 446 _meshcentral Let\u2019s install MeshCentral and adjust the permissions. mkdir -p /usr/local/meshcentral cd /usr/local/meshcentral npm install meshcentral chown -R _meshcentral:_meshcentral /usr/local/meshcentral Configuring for MongoDB and adjusting some other settings such as the network port. Open up the following config in an editor then, make the start of the file look like below. If the setting does not exist yet, just add it below one of the ones we are adjusting in the main settings block. If you start with the default config.json created by MeshCentral, you will need to remove some underscore character in front of settings to enable the setting, such as mongodb and wanonly. You can also add an underscore to other values. For details on all of the config.json options, including the WANonly option, refer to the MeshCentral User\u2019s Guide. Before you can edit the configuration, start the Meshcentral briefly so it generates the default configurations and certificates. Once you see that it says \"MeshCentral HTTPS server running...\", Ctrl-C to exit then edit the configuration file next. cd /usr/local/meshcentral/node_modules/meshcentral/ && doas -u _meshcentral /usr/local/bin/node /usr/local/meshcentral/node_modules/meshcentral/meshcentral.js --launch Edit the MeshCentral config.json. For example using vi: vi /usr/local/meshcentral/meshcentral-data/config.json In the settings section, set the following key value pairs: { \"settings\" : { \"Cert\" : \"meshcentral.example.com\" , \"MongoDb\" : \"mongodb://127.0.0.1:27017/meshcentral\" , \"WANonly\" : true , \"Port\" : 3000 , \"ExactPorts\" : true , \"RedirPort\" : 3001 , \"allowLoginToken\" : true , \"allowFraming\" : true , \"NewAccounts\" : 0 , }, \u2026 } Add the following to the root crontab to start MeshCentral at boot. Edit the root crontab by doing the following command as root: crontab -e @reboot cd /usr/local/meshcentral/node_modules/meshcentral/ && doas -u _meshcentral /usr/local/bin/node /usr/local/meshcentral/node_modules/meshcentral/meshcentral.js --launch As root launch Meshcentral while it installs mongojs, once that finishes and Meshcentral launches close it by doing Ctrl-C. Adjust the permissions again as we ran Meshcentral and it generated new files we need to change the ownership of. /usr/local/bin/node /usr/local/meshcentral/node_modules/meshcentral chown -R _meshcentral:_meshcentral /usr/local/meshcentral Warning Do not keep this running or use this command in the future to start the Meshcentral server as it starts the server as root! This is a reference /etc/pf.conf for you to keep your server secure. Add any locally connected networks which should have access and any public IP address of a network which will have client PCs connect from to target_whitelist table. Add your own home and/or business IP to my_own_IPs table. ext_if = vio0 set reassemble yes set block-policy return set loginterface egress set ruleset-optimization basic set skip on lo icmp_types = \"{ 0, 8, 3, 4, 11, 30 }\" table <target_whitelist> const { 45.63.15.84, 10.18.5.0/24 } table <my_own_IPs> const { 45.63.15.84 } table <bruteforce> match in all scrub (no-df max-mss 1440) match out all scrub (no-df max-mss 1440) block in quick log from urpf-failed label uRPF block quick log from <fail2ban> block in from no-route to any block in from urpf-failed to any block in quick on $ext_if from any to 255.255.255.255 block in log quick on $ext_if from { 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 255.255.255.255/32 } to any antispoof for $ext_if block log all pass in quick inet proto icmp icmp-type $icmp_types pass in quick inet6 proto icmp6 pass in quick proto tcp from <my_own_IPs> \\ to (egress) port { 22 } \\ flags S/SA modulate state \\ (max-src-conn 5, max-src-conn-rate 5/5, overload <bruteforce> flush global) pass in quick inet proto tcp from <target_whitelist> to port 3000 pass in quick inet6 proto tcp from <target_whitelist> to port 3000 block in quick log on egress all pass out quick on egress proto tcp from any to any modulate state pass out quick on egress proto udp from any to any keep state pass out quick on egress proto icmp from any to any keep state pass out quick on egress proto icmp6 from any to any keep state After saving the configuration in /etc/pf.conf, reload the pf rules with: pfctl -f /etc/pf.conf To save rebooting and have MeshCentral launch then, launch it so you can begin using it. This time it is running as _meshcentral, now it is safe to keep running and you can use this command in the future. cd /usr/local/meshcentral/node_modules/meshcentral/ && doas -u _meshcentral /usr/local/bin/node /usr/local/meshcentral/node_modules/meshcentral/meshcentral.js --launch You can now access MeshCentral at https://youraddress:3000 or https://meshcentral.example.com:3000 if you named the machine meshcentral or create an A record named meshcentral. The first user you create will be the Administrator, there is no default user.","title":"Installing MeshCentral"},{"location":"intelamt/","text":"Intel AMT \u00b6 Intel AMT Guide as .odt Video Walkthru \u00b6 Abstract \u00b6 This user guide contains all essential information for activating and using Intel\u00ae Active Management Technology (Intel\u00ae AMT) with MeshCentral. We will review how to activate, connect to and use Intel AMT features and how this benefit administrators that want to manage computers remotely. This document expect the reader to already be familiar with how to install and operate MeshCentral and have a basic understanding of how Intel\u00ae AMT works. History of AMT \u00b6 Introduction \u00b6 MeshCentral is a free open source web-based remote computer management software and it fully supports Intel\u00ae Active Management Technology (Intel\u00ae AMT). MeshCentral does not require that computers it manages support Intel AMT, but if a remote computer has this capability, MeshCentral will make use of it. Intel AMT can be seen as a hardware based management agent that is built into some Intel PC\u2019s. Once setup, Intel AMT can be used to remotely manage a computer regardless of the operating system health. It can be used to power on a computer when it\u2019s in soft-off state or to provide enhanced monitoring and security to remote systems. Once setup, a computer can have up to management connections to MeshCentral. One of them by the Mesh Agent that lives in the operating system and another connection from Intel AMT. When remote management is made using an operating system agent, we call this \u201cin-band management\u201d and when management is done using a hardware based agent like Intel AMT, we call this \u201cout-of-band management\u201d MeshCentral can support computers that have either or both agents. So, you can setup a computer with just the Mesh Agent, just Intel AMT or both. In this document we will show how to install computers with both agent connections or with just Intel AMT. When Intel AMT is used alone, we call this \u201cagent-less\u201d as there will be no operating system software required to remotely manage the computer. The Mesh Agent and Intel\u00ae AMT have very different and complementary capabilities and so, it\u2019s often beneficial to use both and one will offer features the other can\u2019t provide. Here are some of the benefits each has to offer: Mesh Agent Fast remote desktop / clipboard access. Remote access to operating system files. Remote chat and other OS features. Intel\u00ae AMT Remote desktop even when the agent or operating system is not functional. Remote access to BIOS. Connectivity when soft-off / sleeping. Remote power actions. If you are looking into managing remote computers that would be difficult to physically get access to for remote support or maintenance, one should probably look at getting a PC with Intel AMT. MeshCentral Group Types \u00b6 Once MeshCentral is installed, a user will typically create a new device group. Here is the first hint that MeshCentral supports Intel AMT. Device groups come in two types. You can manage using a software agent, or using Intel AMT only. Note that if you use the OS agent to manage computers, you can also set and use Intel AMT. However, if you opt to create an Intel AMT only group, then Mesh Agents are not supported. One can create groups of both types in order to manage devices that have and don\u2019t have the Mesh Agent installed. The main benefit of \u201cIntel AMT only\u201d group is if someone does not want to install a background agent on remote systems or already have a remote management solution and intends to only use MeshCentral to supplement the existing solution with Intel AMT features. Once a group is created, the links MeshCentral provides to on-board devices will change depending on the group type and how the server is setup. The device on-boarding links are located in the \u201cMy Devices\u201d page, next to the group name. If the MeshCentral server is setup in \u201cLAN mode\u201d or \u201cHybrid mode\u201d, options will be available to add computers on the local network. If you have an Intel AMT computer that is already activated, you can select the \u201cAdd Local\u201d or \u201cScan Network\u201d options in the \u201cIntel AMT only\u201d group type and start adding local network computers this way. If MeshCentral is in \u201cWAN mode\u201d, you will need to setup Intel AMT to connect back to MeshCentral using a feature called \u201cClient Initiated Remote Access\u201d or CIRA for short. We will cover that in a later section. Client Initiated Remote Access & MPS server \u00b6 Client Initiated Remote Access (CIRA) is a feature of Intel AMT that, then configured, makes Intel AMT connect back to the server using a TLS tunneling connection similar with a SSH tunnel. Once this tunnel connection is established, the server can perform remote management operations on Intel AMT. CIRA is great when remotely managing Intel AMT devices over the Internet thru network address translator (NAT) routers where the server would not be able to connect to Intel AMT. This is similar to the Mesh Agent that initiated and keeps an idle connection to the server. By default, MeshCentral will be configured to receive Mesh Agent connections on TCP port 443 and Intel AMT connections on TCP port 4433. These port values can be configured in the config.json file of MeshCentral. Once connected to port 443, the Mesh agent will using secure HTTPS WebSocket to securely communicate with the server. Intel AMT will use TLS to connect to port 4433 and use a binary tunneling protocol called the Intel AMT Port Forwarding Protocol (APF). You can find documentation on this protocol at the following URL: https://software.intel.com/sites/manageability/AMT_Implementation_and_Reference_Guide/HTMLDocuments/MPSDocuments/Intel%20AMT%20Port%20Forwarding%20Protocol%20Reference%20Manual.pdf It\u2019s not necessary to know or understand the details of this protocol, MeshCentral will take care of handling this. In Intel AMT nomenclature, the server that receives a CIRA connection is called a \u201cManagement Presence Server\u201d or MPS for short. In other words, MeshCentral has a MPS server on port 4433 ready to receive Intel AMT CIRA connections. When MeshCentral is first setup, a self-signed root certificate is created along with a MPS certificate that will be presented when a device connects on port 4433. There is typically no need to use a CA signed & trusted certificate on port 4433 was we only expect Intel AMT computers to connect to this port and we will be loading our self-signed root in Intel AMT for authentication purposes. One way to check that the MeshCentral MPS server is running correctly is to use a browser and access port 4433 using HTTPS. The browser will display a warning because the port 4433 certificate is not trusted, but this is expected. The CIRA protocol is binary, but MeshCentral will detect that the request is made from a browser and return a short message: MeshCentral2 MPS server. Intel\u00ae AMT computers should connect here. This is practical to make sure connectivity with the MeshCentral MPS server is working. Now that we know the basics of Intel AMT CIRA and the MPS server, we can configure Intel AMT to connect. Activation Certificate Setup \u00b6 If you have an Intel AMT activation certificate, you should configure MeshCentral to take advantage of it. Your activation certificate must have been issued by one of the certificate authorities (CA\u2019s) that is trusted by Intel AMT and MeshCentral will need the entire certificate chain to be provided since the entire chain is needed to perform Intel AMT ACM activation. The leaf certificate will have the Intel AMT activation option and a specific domain name while the hash of the trusted CA certificate must be trusted by Intel AMT. The certificate chain will have to be setup in the domain section of the MeshCentral config.json file. If you have a certificate chain in a .pfx or .p12 format, place that file in the \u201cmeshcentral-data\u201d folder and add the \u201cAmtAcmActivation\u201d section in the domain section like so: { \"settings\" : { \"Cert\" : \"devbox.mesh.meshcentral.com\" , }, \"domains\" : { \"\" : { \"title\" : \"My Server\" , \"AmtAcmActivation\" : { \"log\" : \"amtactivation.log\" , \"certs\" : { \"myamtcert\" : { \"certpfx\" : \"amtcert.pfx\" , \"certpfxpass\" : \"pfxpassword\" } } } } } If you have the certificate chain in PEM format as a set of .crt files and a .key file, start by placing all of the certificate files in the \u201cmeshcentral-data\u201d folder and setup the certificate chain like this: { \"settings\" : { \"Cert\" : \"devbox.mesh.meshcentral.com\" , }, \"domains\" : { \"\" : { \"title\" : \"My Server\" , \"AmtAcmActivation\" : { \"log\" : \"amtactivation.log\" , \"certs\" : { \"myvprocert\" : { \"certfiles\" : [ \"amtacm-vprodemo.crt\" , \"amtacm-intermediate1.crt\" , \"amtacm-intermediate2.crt\" , \"amtacm-root.crt\" ], \"keyfile\" : \"amtacm-vprodemo.key\" } } } } } It\u2019s important that the leaf certificate file be the first file in the \u201ccertfiles\u201d array. The order of the other certificates is not important as MeshCentral will figure out and re-order them correctly. Within the new \u201cAmtAcmActivation\u201d section, there is a \u201clog\u201d entry. This is a log file that will contain every activation attempt including the details of the computer being activation and what Intel AMT administrator password was used for activation. This log file should be kept securely as it will contain Intel AMT credentials. It\u2019s also important to have this file as a backup so that Intel AMT credentials are not lost after activation. If MeshCentral can\u2019t write to this log, the activation will not go forward and will fail. Once the config.json was modified, restart the server. There will be two indications that the server has the new certificate correctly configured. For \u201cIntel AMT only\u201d groups, a new \u201cActivation\u201d link will show up. Clicking this link will show a command that can be run to perform ACM activation. For device groups that operate with a Mesh Agent, you can edit the group and select the \u201cSimple Admin Control Mode\u201d Intel AMT activation policy. This policy is not available unless a correct Intel AMT ACM activation certificate is configured. Once setup, Intel AMT will not automatically activate to Intel AMT unless the right situation is met. The Intel AMT activation certificate is for a specific domain name suffix, for example \u201cmeshcentral.com\u201d. Intel AMT must be in a situation where this domain can be accepted. One of the following must be true: Intel AMT must have a wired Ethernet interface that is connected to a local network with a DHCP server responding with option 15 set to \u201cxxx.meshcentral.com\u201d. The name \u201cmeshcentral.com\u201d by have been set as \u201cTrusted FQDN\u201d in MEBx. The name \u201cmeshcentral.com\u201d must have been set using a USB key with a setup.bin file. Once Intel AMT is in a situation where ACM activation can occur, the activation command line can be run or the Mesh Agent will detect this situation and ask the server to perform activation. The best way to test this feature is to create an \u201cIntel AMT only\u201d device group and run the MeshCMD command on the remote system to perform activation. If there is a problem, this process should clearly display why ACM activation fails. Intel AMT MEI and LMS \u00b6 Intel Active Management Technology (Intel AMT) can communicate to the local platform using the Management Engine Interface (MEI). We show how your can use that to get Intel AMT information. For more advanced usages, you need to connect using TCP and TLS which requires Intel Local Manageability Service (LMS). We show how MeshCentral's Mesh Agent and MeshCMD have a small version of LMS built-in and how it works Intel AMT System Defense \u00b6 As part of Intel AMT there are hardware filters in the network interface you can setup to match and perform actions on packets. This happens at Ethernet speeds with no slow down and independent of the OS.","title":"Intel AMT"},{"location":"intelamt/#intel-amt","text":"Intel AMT Guide as .odt","title":"Intel AMT"},{"location":"intelamt/#video-walkthru","text":"","title":"Video Walkthru"},{"location":"intelamt/#abstract","text":"This user guide contains all essential information for activating and using Intel\u00ae Active Management Technology (Intel\u00ae AMT) with MeshCentral. We will review how to activate, connect to and use Intel AMT features and how this benefit administrators that want to manage computers remotely. This document expect the reader to already be familiar with how to install and operate MeshCentral and have a basic understanding of how Intel\u00ae AMT works.","title":"Abstract"},{"location":"intelamt/#history-of-amt","text":"","title":"History of AMT"},{"location":"intelamt/#introduction","text":"MeshCentral is a free open source web-based remote computer management software and it fully supports Intel\u00ae Active Management Technology (Intel\u00ae AMT). MeshCentral does not require that computers it manages support Intel AMT, but if a remote computer has this capability, MeshCentral will make use of it. Intel AMT can be seen as a hardware based management agent that is built into some Intel PC\u2019s. Once setup, Intel AMT can be used to remotely manage a computer regardless of the operating system health. It can be used to power on a computer when it\u2019s in soft-off state or to provide enhanced monitoring and security to remote systems. Once setup, a computer can have up to management connections to MeshCentral. One of them by the Mesh Agent that lives in the operating system and another connection from Intel AMT. When remote management is made using an operating system agent, we call this \u201cin-band management\u201d and when management is done using a hardware based agent like Intel AMT, we call this \u201cout-of-band management\u201d MeshCentral can support computers that have either or both agents. So, you can setup a computer with just the Mesh Agent, just Intel AMT or both. In this document we will show how to install computers with both agent connections or with just Intel AMT. When Intel AMT is used alone, we call this \u201cagent-less\u201d as there will be no operating system software required to remotely manage the computer. The Mesh Agent and Intel\u00ae AMT have very different and complementary capabilities and so, it\u2019s often beneficial to use both and one will offer features the other can\u2019t provide. Here are some of the benefits each has to offer: Mesh Agent Fast remote desktop / clipboard access. Remote access to operating system files. Remote chat and other OS features. Intel\u00ae AMT Remote desktop even when the agent or operating system is not functional. Remote access to BIOS. Connectivity when soft-off / sleeping. Remote power actions. If you are looking into managing remote computers that would be difficult to physically get access to for remote support or maintenance, one should probably look at getting a PC with Intel AMT.","title":"Introduction"},{"location":"intelamt/#meshcentral-group-types","text":"Once MeshCentral is installed, a user will typically create a new device group. Here is the first hint that MeshCentral supports Intel AMT. Device groups come in two types. You can manage using a software agent, or using Intel AMT only. Note that if you use the OS agent to manage computers, you can also set and use Intel AMT. However, if you opt to create an Intel AMT only group, then Mesh Agents are not supported. One can create groups of both types in order to manage devices that have and don\u2019t have the Mesh Agent installed. The main benefit of \u201cIntel AMT only\u201d group is if someone does not want to install a background agent on remote systems or already have a remote management solution and intends to only use MeshCentral to supplement the existing solution with Intel AMT features. Once a group is created, the links MeshCentral provides to on-board devices will change depending on the group type and how the server is setup. The device on-boarding links are located in the \u201cMy Devices\u201d page, next to the group name. If the MeshCentral server is setup in \u201cLAN mode\u201d or \u201cHybrid mode\u201d, options will be available to add computers on the local network. If you have an Intel AMT computer that is already activated, you can select the \u201cAdd Local\u201d or \u201cScan Network\u201d options in the \u201cIntel AMT only\u201d group type and start adding local network computers this way. If MeshCentral is in \u201cWAN mode\u201d, you will need to setup Intel AMT to connect back to MeshCentral using a feature called \u201cClient Initiated Remote Access\u201d or CIRA for short. We will cover that in a later section.","title":"MeshCentral Group Types"},{"location":"intelamt/#client-initiated-remote-access-mps-server","text":"Client Initiated Remote Access (CIRA) is a feature of Intel AMT that, then configured, makes Intel AMT connect back to the server using a TLS tunneling connection similar with a SSH tunnel. Once this tunnel connection is established, the server can perform remote management operations on Intel AMT. CIRA is great when remotely managing Intel AMT devices over the Internet thru network address translator (NAT) routers where the server would not be able to connect to Intel AMT. This is similar to the Mesh Agent that initiated and keeps an idle connection to the server. By default, MeshCentral will be configured to receive Mesh Agent connections on TCP port 443 and Intel AMT connections on TCP port 4433. These port values can be configured in the config.json file of MeshCentral. Once connected to port 443, the Mesh agent will using secure HTTPS WebSocket to securely communicate with the server. Intel AMT will use TLS to connect to port 4433 and use a binary tunneling protocol called the Intel AMT Port Forwarding Protocol (APF). You can find documentation on this protocol at the following URL: https://software.intel.com/sites/manageability/AMT_Implementation_and_Reference_Guide/HTMLDocuments/MPSDocuments/Intel%20AMT%20Port%20Forwarding%20Protocol%20Reference%20Manual.pdf It\u2019s not necessary to know or understand the details of this protocol, MeshCentral will take care of handling this. In Intel AMT nomenclature, the server that receives a CIRA connection is called a \u201cManagement Presence Server\u201d or MPS for short. In other words, MeshCentral has a MPS server on port 4433 ready to receive Intel AMT CIRA connections. When MeshCentral is first setup, a self-signed root certificate is created along with a MPS certificate that will be presented when a device connects on port 4433. There is typically no need to use a CA signed & trusted certificate on port 4433 was we only expect Intel AMT computers to connect to this port and we will be loading our self-signed root in Intel AMT for authentication purposes. One way to check that the MeshCentral MPS server is running correctly is to use a browser and access port 4433 using HTTPS. The browser will display a warning because the port 4433 certificate is not trusted, but this is expected. The CIRA protocol is binary, but MeshCentral will detect that the request is made from a browser and return a short message: MeshCentral2 MPS server. Intel\u00ae AMT computers should connect here. This is practical to make sure connectivity with the MeshCentral MPS server is working. Now that we know the basics of Intel AMT CIRA and the MPS server, we can configure Intel AMT to connect.","title":"Client Initiated Remote Access &amp; MPS server"},{"location":"intelamt/#activation-certificate-setup","text":"If you have an Intel AMT activation certificate, you should configure MeshCentral to take advantage of it. Your activation certificate must have been issued by one of the certificate authorities (CA\u2019s) that is trusted by Intel AMT and MeshCentral will need the entire certificate chain to be provided since the entire chain is needed to perform Intel AMT ACM activation. The leaf certificate will have the Intel AMT activation option and a specific domain name while the hash of the trusted CA certificate must be trusted by Intel AMT. The certificate chain will have to be setup in the domain section of the MeshCentral config.json file. If you have a certificate chain in a .pfx or .p12 format, place that file in the \u201cmeshcentral-data\u201d folder and add the \u201cAmtAcmActivation\u201d section in the domain section like so: { \"settings\" : { \"Cert\" : \"devbox.mesh.meshcentral.com\" , }, \"domains\" : { \"\" : { \"title\" : \"My Server\" , \"AmtAcmActivation\" : { \"log\" : \"amtactivation.log\" , \"certs\" : { \"myamtcert\" : { \"certpfx\" : \"amtcert.pfx\" , \"certpfxpass\" : \"pfxpassword\" } } } } } If you have the certificate chain in PEM format as a set of .crt files and a .key file, start by placing all of the certificate files in the \u201cmeshcentral-data\u201d folder and setup the certificate chain like this: { \"settings\" : { \"Cert\" : \"devbox.mesh.meshcentral.com\" , }, \"domains\" : { \"\" : { \"title\" : \"My Server\" , \"AmtAcmActivation\" : { \"log\" : \"amtactivation.log\" , \"certs\" : { \"myvprocert\" : { \"certfiles\" : [ \"amtacm-vprodemo.crt\" , \"amtacm-intermediate1.crt\" , \"amtacm-intermediate2.crt\" , \"amtacm-root.crt\" ], \"keyfile\" : \"amtacm-vprodemo.key\" } } } } } It\u2019s important that the leaf certificate file be the first file in the \u201ccertfiles\u201d array. The order of the other certificates is not important as MeshCentral will figure out and re-order them correctly. Within the new \u201cAmtAcmActivation\u201d section, there is a \u201clog\u201d entry. This is a log file that will contain every activation attempt including the details of the computer being activation and what Intel AMT administrator password was used for activation. This log file should be kept securely as it will contain Intel AMT credentials. It\u2019s also important to have this file as a backup so that Intel AMT credentials are not lost after activation. If MeshCentral can\u2019t write to this log, the activation will not go forward and will fail. Once the config.json was modified, restart the server. There will be two indications that the server has the new certificate correctly configured. For \u201cIntel AMT only\u201d groups, a new \u201cActivation\u201d link will show up. Clicking this link will show a command that can be run to perform ACM activation. For device groups that operate with a Mesh Agent, you can edit the group and select the \u201cSimple Admin Control Mode\u201d Intel AMT activation policy. This policy is not available unless a correct Intel AMT ACM activation certificate is configured. Once setup, Intel AMT will not automatically activate to Intel AMT unless the right situation is met. The Intel AMT activation certificate is for a specific domain name suffix, for example \u201cmeshcentral.com\u201d. Intel AMT must be in a situation where this domain can be accepted. One of the following must be true: Intel AMT must have a wired Ethernet interface that is connected to a local network with a DHCP server responding with option 15 set to \u201cxxx.meshcentral.com\u201d. The name \u201cmeshcentral.com\u201d by have been set as \u201cTrusted FQDN\u201d in MEBx. The name \u201cmeshcentral.com\u201d must have been set using a USB key with a setup.bin file. Once Intel AMT is in a situation where ACM activation can occur, the activation command line can be run or the Mesh Agent will detect this situation and ask the server to perform activation. The best way to test this feature is to create an \u201cIntel AMT only\u201d device group and run the MeshCMD command on the remote system to perform activation. If there is a problem, this process should clearly display why ACM activation fails.","title":"Activation Certificate Setup"},{"location":"intelamt/#intel-amt-mei-and-lms","text":"Intel Active Management Technology (Intel AMT) can communicate to the local platform using the Management Engine Interface (MEI). We show how your can use that to get Intel AMT information. For more advanced usages, you need to connect using TCP and TLS which requires Intel Local Manageability Service (LMS). We show how MeshCentral's Mesh Agent and MeshCMD have a small version of LMS built-in and how it works","title":"Intel AMT MEI and LMS"},{"location":"intelamt/#intel-amt-system-defense","text":"As part of Intel AMT there are hardware filters in the network interface you can setup to match and perform actions on packets. This happens at Ethernet speeds with no slow down and independent of the OS.","title":"Intel AMT System Defense"},{"location":"meshcentral/","text":"Meshcentral2 Guide \u00b6 MeshCentral2 Guide MeshCmd Guide as .pdf as .odt Video Walkthru \u00b6 Abstract \u00b6 This user guide contains all essential information for the user to make full use of MeshCentral, a free open source web-based remote computer management software. The guide provides quick steps to setup administrative groups to remote control and manage computers in local network environments or via the Internet. Latter parts of the document will cover some advanced topics. The reader is expected to already have some of the basic understanding on computer networking, operating system and network security. Introduction \u00b6 MeshCentral is a free open source web-based remote computer management software. You could setup your own management server on a local network or on the internet and remote control and manage computers that runs either Windows* or Linux* OS. To begin, a base or management server will be required. A management server could be any computing device (PC or VM) that has sufficient compute, storage and reliable network components to host an environment for MeshCentral and deliver good performance during remote management exercise. Whilst there are many configurations available for advanced users, typical server setup would only take just a few minutes to complete. At a high level, there are only four (4) main steps: Setup, Install, Connect and Control. Setup the MeshCentral server on VM or PC Log on to MeshCentral portal with a valid account, creates an administrative mesh to collect all end-points (systems to be managed) Generates an agent and installs it on a target or each end-point that immediately attempts a connection back to MeshCentral server. Controls/manages assets or end-points that are available in respective administrative mesh Server Installation \u00b6 Because the MeshCentral server is written in NodeJS it can be installed on many operating systems including Windows, Linux. Please refer to the MeshCentral Installer\u2019s Guide available at https://www.meshcommander.com/meshcentral2 for information on how to install the server. The server can be installed both on a local area network for local computer management and in the cloud for management of computers over the Internet. You can also install it on small IoT devices like a Raspberry Pi all the way to big servers. It\u2019s recommended to get started with a test setup to get a feel for this server. Once installed, come back to this document for configuring and using your new server. Basic Usage \u00b6 In this section we will cover the basics of MeshCentral in your newly setup server. Launch \u00b6 Start your web browser and access MeshCentral via IP address/URL, http://serverFQDN/. If MeshCentral is running locally, enter http://127.0.0.1/. MeshCentral will redirect the browser to HTTPS if the server was accessed with HTTP. Once on HTTPS you will likely see this message: This is because by default MeshCentral is using a self-signed certificate that is not known to the browser as a \u201ctrusted\u201d or \u201ctrustworthy\u201d certificate. To prevent this warning from recurring, the following chapter will provide useful steps that can be considered. To proceed on Firefox browser, Click on \u201cAdvanced\u201d, \u201cAdd Exception\u201d and \u201cConfirm Security Exception\u201d To proceed on Chrome Browser, Click on \u201cAdvanced\u201d, \u201cProceed to http://serverIP (unsafe)\u201d To proceed on Internet Explorer 11, Click \u201cContinue to this website (not recommended)\u201d Note: You can also get to a device by specifying the device name in the URL by adding ?viewmode=10&gotodevicename=MyComputer to the URL of the MeshCentral web page. The new gotodevicename will find a device with the specified name and navigate to that device\u2019s page. This is perfect for integrating MeshCentral with other solutions but be aware that a computer name is not a unique identifier and so, &gotonode= is always the preferred way to access a device. This feature also works on the mobile web site. Create Account \u00b6 Create an account by clicking \u201cCreate One\u201d and click \u201cCreate Account\u201d once the text fields had been populated correctly. New device group \u00b6 Once logged in, create a new device group. This is a group of computers that we want to manage. To proceed, Click on \u201cClick here to create a new group of devices\u201d, Key in a suitable \u201cName\u201d, .e.g. \u201cSampleGroup\u201d Leave \u201cType\u201d to default \u201cManage using a software agent\u201d and click \u2018OK\u201d. Note There are two types of groups: Software Agent Group: Commonly used to manage computers. Administrator must install a \u201cremote management agent\u201d on the remote computers. Intel\u00ae AMT Agent-less Group: Exclusive for remote computers that has Intel\u00ae AMT activated and needs to be managed independent of a \u201cremote management agent\u201d. Add device \u00b6 To add devices into new mesh Click \u201cAdd Agent\u201d, Select the right Operating Systems (Windows* OS) and download the Mesh Agent executable. Copy the Mesh Agent file into remote computers with Windows* OS Run Mesh Agent and Click \u201cinstall\u201d Note Mesh Agent is available for Windows* and Linux*. For Windows*, the mesh agent doesn\u2019t contain any sensitive data and can copied and reused on many Windows* computers. For Linux*, instead of an executable, an installation script is provided to add remote computers. The script checks the type of computer and installs the proper agent automatically. After agent install \u00b6 Once the agents are installed, it will take up to a minute before the computer shows up on the user\u2019s account automatically. Click on each computer to access it and user can rename the each computer with a unique name and icons. Manage Computer \u00b6 Click on any computer and go into the \u201cDesktop\u201d and \u201cFiles\u201d tabs to remotely manage the computer or perform file transfer. For advance users with console/command line interface experience, go into \u201cTerminal\u201d to perform scripting or quick tasks with CLI tools. Desktop Control \u00b6 Depending on how the agent is connected to the server, there are multiple methods to remote control. Mesh Agent, RDP, and AMT For RDP connections, if you have previously saved the credentials that is usable by all users on the system. If you want to remove those saved credentials that's under the General Tab > Credentials . Click pen to clear them. Server Certificate \u00b6 As seen in the previous chapter, MeshCentral is setup with a self-signed certificate by default and the web browser will issue a warning concerning the validity of the certificate. Users have few ways to handle this certificate warning: Ignore the warning and proceed with an exception in a recurring fashion. However, traffic from the server to the web browser remains encrypted. User must check the validity of the certificate presented by the website and compare with \u201cwebserver-cert-public.crt\u201d file in the \u201cmeshcentral-data\u201d folder of the server. Add webserver\u2019s root certificate into web browser\u2019s trust list. Click on \u201cRoot Certificate\u201d link at the bottom right of login page to download the root certificate of the web server and then add/import this as a trusted certificate into web browser. Some web browser may require a restart before the certificate installation takes effect. If you own a domain name that points to your MeshCentral server, you can get a free trusted certificate using Let\u2019s Encrypt (https://letsencrypt.org/). See the section on Let\u2019s Encrypt in this document for more information on this option. MeshCentral has built-in support for Let\u2019 Encrypt. Important Before adding/importing the certificate, user must check the validity of the certificate presented by the website and compare with \u201croot-cert-public.crt\u201d file in the \u201cmeshcentral-data\u201d folder of the server. For large scale deployments or setup, a legitimate trusted certificate is highly recommended for your web server. This way, any web browser that navigates to this web server will be able to readily verify its authenticity. If a legitimate trusted certificate is available, replace \u201cwebserver-cert-public.crt\u201d and \u201cwebserver-cert-private.key\u201d with your certificate. These files are located in \u201cmeshcentral-data\u201d folder of the server. If intermediate certificates are needed, add the files \u201cwebserver-cert-chain1.crt\u201d, \u201cwebserver-cert-chain2.crt\u201d, \u201cwebserver-cert-chain3.crt\u201d respectively with the intermediate certificates. Note : If you are using TLS offloading, see the section on \u201cTLS Offloading\u201d cover in the latter parts of this document. Files and Folder Structure \u00b6 It\u2019s important to know the basic file and folder structure from which MeshCentral was installed as shown below Right after running the \u201cnpm install meshcentral\u201d command, the node_module folder will be created which contains meshcentral and all of its dependent modules. When the server executes for the first time, both meshcentral-data and meshcentral-files folders will be created. Important User must periodically backup both meshcentral-data and meshcentral-files which contains all of server\u2019s data. The \u201cmeshcentral-data\u201d folder will contain: meshcentral.db file : The server\u2019s database file which contains all of the user and computer information. This includes account information and other sensitive information. Five .key and .crt files : These are the server\u2019s certificates and private keys. They are used to securely identify the server. The .key files must not be obtained by anyone else since they could be used to impersonate the server. config.json file : This is the server\u2019s configuration file. It first starts with a sample configuration that you can change. In a following section, we will discuss how to edit this file to customize the server. The \u201cmeshcentral-files\u201d folder contains user files that have been uploaded to the server. This folder can be quite large, especially if no user space quota is set in the config.json file. Users can upload a significant amount of files on the server. Important Back-up the \u201cmeshcentral-data\u201d folder since this is the folder needed to reconstruct the server if something goes wrong. Without it, user will to start over. Recommended to apply suitable encryption on both folders given that they contain sensitive data. Server Configuration File \u00b6 In the \u201cmeshcentral-data\u201d folder, there is a file called config.json that contains the main configuration of the server. A sample configuration file could look like this: { \"settings\": { \"cert\": \"mesh.myserver.com\", \"port\": 8080, \"redirport\": 81 }, \"domains\": { \"\": { \"title\": \"MyServer\", \"title2\": \"Servername\", \"userQuota\": 1048576, \"meshQuota\": 248576, \"newAccounts\" : 1 }, \"Customer1\": { \"title\": \"Customer1\", \"title2\": \"Extra String\", \"newAccounts\" : 0 } }, \"peers\": { \"serverId\" : \"Server1\", \"servers\": { \"Server1\": { \"url\": \"wss://192.168.1.100:443/\" }, \"Server2\": { \"url\": \"wss://192.168.1.101:443/\" } } } } First, we will look at each of the top levels of the configuration file. The tops levels are \u201csettings\u201d, \u201cdomains\u201d, \u201cpeers\u201d, and \u201csmtp\u201d as shown in the table below. Settings \u00b6 As indicated before, the settings section of the config.json is equivalent to passing arguments to the server at runtime. Below is a list of settings that are available for the user. Settings Option Description Cert Sets the DNS name of the server. If this name is not set, the server will run in \"LAN mode\". When set, the server\"s web certificate will use this name and the server will instruct agents and browsers to connect to that DNS name. You must set a server DNS name to run in \"WAN mode\". MeshCentral will not configure your DNS server. The DNS name must be configured separately. Port This sets the main web port used by the MeshCentral server and it\"s the same port that users and mesh agents will connect to. The default port is 443, but if the port is busy, the next available higher port is used (.e.g. 444) AliasPort Sets the main port that will be used by the server externally. By default is the same as \"Port\" above, but can be set to be different when next. See \"Server port aliasing\" section for more details. RedirPort This is the port for redirecting traffic in the web server. When the server is configured with HTTPS, users that uses HTTP will be redirected to HTTPS. Port 80 is the default port. So, redirection will happen from port 80 to port 443. MpsPort Port for Intel\" AMT Management Presence Server to receive Intel\" AMT CIRA (Client Initiated Remote Access) connections. The default is port 4433. This port is disabled in LAN mode. If user don\"t plan on using Intel\" AMT for management, this port can be left as-is. TLSOffload By default this option is set to \"false\". If set to \"true\", server will run both web port and the Intel AMT MPS port without TLS with the assumption that a TLS offloading is taking care of this task. For further details, see the \"TLS Offloading\" section. This option can also be set to the IP address of the reverse-proxy in order to indicate to MeshCental to only trust HTTP X-Forwarded headers coming from this IP address. See the \"Reverse-Proxy Setup\" section for an example. SelfUpdate When set to \"true\" the server will check for a new version and attempt to self-update automatically a bit after midnight local time every day. For this to work, the server needs to run with sufficient permissions to overwrite its own files. If you run the server with more secure, restricted privileges, this option should not be used. If set to a specific version such as \"0.2.7-g\" when the server will immediately update to the specified version on startup if it\"s not already at this version. SessionKey This is the encryption key used to secure the user\"s login session. It will encrypt the browser cookie. By default, this value is randomly generated each time the server starts. If many servers are used with a load balancer, all servers should use the same session key. In addition, one can set this key so that when the server restarts, users do not need to re-login to the server. Minify Default value is 0, when set to 1 the server will serve \"minified\" web pages, that is, web pages that have all comments, white spaces and other unused characters removed. This reduces the data size of the web pages by about half and reduced the number requests made by the browser. The source code of the web page will not be easily readable, adding \"&nominify=1\" at the end of the URL will override this option. User Specify a username that browsers will be automatically logged in as. Useful to skip the login page and password prompts. Used heavily during development of MeshCentral. NoUsers By default this option is \"false\" and if set to \"true\", server will only accept users from localhost (127.0.0.1) and will not have a login page. Instead, a single user is always logged in. This mode is useful if user opts to setup MeshCentral as a local tool instead of as a multi-user server MpsCert Specifies the official name of the Intel AMT MPS server. If not specified, this is the same as the official server name specified by \"cert\". This option is generally used with MPS aliasing, see the \"Server port aliasing\" section for more information. MpsAliasPort Specify an alias port for the MPS server. See the section on \"Server port aliasing\" for use of this option. ExactPorts If this option is set to \"true\", only the exact port will be used. By default, if a port is in use, the server will try to bind the next available higher port. This is true for the \"port\", \"redirport\" and \"mpsport\" settings. Lanonly Server\"s default mode if not set with \"--cert\" option. If this option is set to \"true\", Intel\" AMT MPS will be disabled, server name and fixed IP option will be hidden. Mesh agents will search for the server using multicast on the network. Wanonly A recommended option when running MeshCentral in the cloud. If set to \"true\", server will run as a cloud service and assumes LAN features are disabled. For this option to work, the server must have a fixed IP or DNS record using the \"--cert\"\" option. In this mode, LAN discovery features are disabled. AllowFraming By default is set to \"false\". If set to \"true\", web pages will be served in a way that allows them to be placed within an iframe of another web page. This is useful when you wish to add MeshCentral features into another website. AllowLoginToken By default is set to \"false\". If set to \"true\", the server allows login tokens to be used in the URL as a replacement for user login. This is useful along with \"allowFraming\" option to embed MeshCentral features into another website. MongoDB Used to specify the MongoDB connection string. If not specified, MeshCentral will use the NeDB database with the file meshcentral.db in the meshcentral-data folder. To setup MongoDB, please refer to the Database section of this document. MongoDBCol Used to specify the MongoDB collection name in the database. By default this value is \"meshcentral\". See Database section for more details on MongoDB setup. DbEncryptKey Specifies a password used to encrypt the database when NeDB is in use. If wanting to encrypt an existing database, use the \"dbexport\" and \"dbimport\" to save and reload the database with the encryption password set. WebRTC Set to \"true\" or \"false\" depending if you want to allow the server to setup WebRTC communication. If WebRTC is setup, management traffic will flow directly between the browser and mesh agent, bypassing the server completely. The default is false now, but will be switched to true when WebRTC is ready for production. ClickOnce Set to \"true\" or \"false\" to allow or disallow browser ClickOnce features. When enabled, browsers running on Windows will be shown extra options to allow RDP and other sessions thru the MeshCentral server. This requires ClickOnce browser support that is built-in to IE and available as add-in to Chrome and Firefox. Default is true. Important Changes in config.json will NOT take effect until server is restarted. Note : We recommend the user to use a non-production server to experiment the setting options above. Domains \u00b6 In the domains section, you can set options for the default domain (\"\") in addition to creating new domains to establish a multi-tenancy server. For standard configuration, the root domain and other domains will be accessible like this: https://servername:8080/ <- default domain https://servername:8080/customer1 <- customer1 domain https://servername:8080/customer2 <- customer2 domain When a user setup many domains, the server considers each domain separately and each domain has separate user accounts, administrators, etc. If a domain has no users, the first created account will be administrator for that domain. Each domain has sub-settings as follows: Sub Settings Description Title & Title2 This are the strings that will be displayed at the banner of the website. By default title is set to \u201cMeshCentral\u201d and title2 is set to a version number UserQuota This is the maximum amount of data in kilobytes that can be placed in the \u201cMy Files\u201d tab for a user account. MeshQuota This is the maximum amount of data in kilobytes that can be placed in the \u201cMy Files\u201d tab for a given mesh NewAccounts If set to zero (0) UserAllowedIP Allows user to set a list of allowed IP addresses. See section on server IP filtering. Auth This mode is often used in corporate environments. When server is running on Windows and this value is set to \u201csspi\u201d, domain control authentication to the website is performed. In this mode, no login screen is displayed and browser will authenticate using the user\u2019s domain credentials. Dns The DNS record for this domain. If specified, the domain is accessed using a DNS record like \u201ccustomer1.servername.com\u201d instead of \u201cservername/customer1\u201d. This feature requires the DNS server to be configured to point this server with a valid DNS record. CertUrl Load the TLS certificate for this domain from this https url. For example \u201chttps://127.0.0.1:123\u201d. This option is useful when used along with the \u201cTlsOffload\u201d option. When MeshCentral is not doing any TLS but has a reverse-proxy or TLS offload device doing this work in front of the server, you can use this to have MeshCentral load the certificate from the server in front of MeshCentral. This is needed because when agents connect, they need to be told that the certificate they saw upon connecting is the correct one. Using this, MeshCentral will know what certificate the agents are expected to see. PasswordRequirements Used to specify the minimum password requirements for user authentication to this domain. By default, no password requirements are enforced but the user will see a password strength indicator that is not backed by any verifiable data. The value must be set to an object, for example: { \"\"min\"\": 8, \"\"max\"\": 128, \"\"upper\"\": 1, \"\"lower\"\": 1, \"\"numeric\"\": 1, \"\"nonalpha\"\": 1 } This indicated that passwords must be at least 8 characters long and have at least one upper case, one lower case, one numeric and one non-alphanumeric character. You can also set the maximum length of the password, however MeshCentral has already a limit of 256 characters. Specifying anything above this will have no effect. Note that password requirements for Intel\u00ae AMT are defined by Intel and so, Intel\u00ae AMT passwords will always be verified using a separate set of requirements. Note : When the DNS value is set for a domain, user can\u2019t access the domain using \u201cservername/customer1\u201d instead it must be accessed with the valid DNS record and the DNS server should be setup to have two or more DNS records pointing to the same IP address. In this mode, the server will serve a different TLS certificate depending on what DNS record is used to access the server. As shown in the example above, we have two names that point to the same IP address. Since the configuration specifies the \u201cdns\u201d value, the second domain is only shown when the right name is used. We use \u201cmeshcentral\u201d and \u201cdevbox\u201d for DNS names, but in practice the user will use fully qualified domain names (FQDN) like \u201cmeshcentral.com\u201d or \u201cdevbox.meshcentral.com\u201d. Server Peering \u00b6 MeshCentral supports server peering. User could setup up many servers to share the task of handling incoming connections from managed clients and consoles. For server peering to function, all servers must have access to the same database, use the same certificates, the same configuration (with the exception of the server name) and servers must be able to communicate with each other behind a load balancer. Hence, the user is expected to have good understanding on networking, server administration and applications to accomplish this setup. This document will not get into the details of setting up a load-balancer. Recommended Before setting up MeshCentral peering, database migration from NeDB database to MongoDB with replication/sharding option enabled is highly recommend. See: Setting up MeshCentral with MongoDB (section 8.4) The setup flow above guides the user to pull together server peering setup with Meshcentral. (2) Shared storage is compulsory to host user files and it must be accessible from all of the servers. If the server is expected for critical work, replicated shared storage should be considered. When Meshcentral is ready for peering setup (5), replicate the \u201cmeshcentral-data\u201d directory on each server and configure the \u201cpeers\u201d section of the config.json file as shown below. { \"peers\": { \"serverId\" : \"Server1\", \"servers\": { \"Server1\": { \"url\": \"wss://192.168.1.100:443/\" }, \"Server2\": { \"url\": \"wss://192.168.1.101:443/\" } } } } The configuration above assumes that server1 has an IP address of \u2018192.168.1.100\u2019 and server2 has \u2018192.168.1.101\u2019 respectively. The \"serverId\" value is a short and unique identifier for each server and it is optional. If it's not specified, the computer hostname is used instead. The \u201cservers\u201d section of the configuration file should have the identifier of the server followed by each websocket URL and port (generally 443) of the peer servers. If the servers are running with \u201c--tlsoffload\u201d, then use \u201cws://\u201d for the URL instead of \u201cwss://\u201d. When the MongoDB is setup for the first time, a unique identifier is generated and written into the DB. To prevent situations where two servers with different database from peering together, during peering process, each server will validate among each other if they have the same unique DB identifier. Peering connection will only succeed if this condition is met. Once peered, all of the servers should act like one single host, no matter which server the user(s) are connected to. Database \u00b6 A critical component of MeshCentral is the database. The database stores all of the user account information, groups and node data, historical power and event, etc. By default MeshCentral uses NeDB (https://github.com/louischatriot/nedb) that is written entirely in NodeJS and is setup automatically when MeshCentral is installed with the npm tool. The file \u201cmeshcentral.db\u201d will be created in the \u201cmeshcentral-data\u201d folder when MeshCentral is first launched. This database works well for small deployments scenarios. Besides NeDB, MeshCentral fully supports MongoDB for larger deployments or deployments that require robust reliability or load-balancing. In this section we will see look at how to export and import the database file with a JSON file and how to configure MongoDB. Database Export \u00b6 User could use a practical approach to migrate from NeDB to MongoDB, by exporting the entire content of the existing NeDB into JSON file, setup the new MongoDB and import that JSON file to create the schemas in MongoDB. To export the database, stop the MeshCentral server and run the server again with \u201c--dbexport\u201d and a JSON file called \u201cmeshcentral.db.json\u201d will be created in the \u201cmeshcentral-data\u201d folder as shown below. Alternatively, user can also specify the full export path for the JSON file as shown below. Database Import \u00b6 Importing the MeshCentral database is useful when transitioning between database softwares (NeDB to/from MongoDB) or when importing the database from MeshCentral1 via migration tool. Important Importing a JSON file will overwrite the entire content of the database. A starting empty database is recommended. When you are ready to import a JSON file into the database, run meshcentral with \u201c--dbimport\" as shown below. If path is not specified, the application will default to use \u201cmeshcentral.db.json\u201d that is in \u201cmeshcentral-data\u201d folder. Alternatively, user can specify the full path of the import JSON as shown below. Viewing the Database \u00b6 For debugging purposes, Meshcentral allow users to have quick preview of certain frequently accessed data in the database with the following options: Option Description --showusers List of all users in the database. --showmeshes List of all meshes in the database. --shownodes List of all nodes in the database --showevents List all events in the database --showpower List all power events in the database. --showall List all records in the database. For example, you can show the list of users with the \u201c--showusers\" MongoDB Setup \u00b6 MongoDB is useful when setting up MeshCentral for two or more peer servers given that all peer servers much have access to the same database. NeDB and MongoDB have similar access interfaces hence the DB migration from one to the other is straight forward. Installing MongoDB depends on its host OS so do check for available download options at mongodb.com. In this guide, we will focus on the 64-bit windows with SSL support installer. After completing the installation step, Stop any instance of Meshcentral that is running locally or in any machine Start a terminal or Windows Command prompt (CMD), Create a folder \u201cc:\\data\\db\u201d Go to the MongoDB bin folder and run \u201cmongod --bind 127.0.0.1\u201d. This execute the database engine and store the database data in the default location \u201c/data/db\u201d path and bind a loopback on the local port \u201c127.0.0.1\u201d. Note : Refer to MongoDB documentation to allow database to run in the background or experiment with alternate configurations. Note : Upon successful execution, MongoDB will wait for connections on its default port 27017. Now run MeshCentral with the command below, it will tell Meshcentral to connect to MongoDB and use \u201cmeshcentral\u201d DB. MongoDB will create this DB if it does not exist. node meshcentral --mongodb mongodb://127.0.0.1:27017/meshcentral Alternatively, to transition an existing meshcentral DB from NeDB and to MongoDB, just run the command below: node meshcentral --dbexport node meshcentral --mongodb mongodb://127.0.0.1:27017/meshcentral --dbimport node meshcentral --mongodb mongodb://127.0.0.1:27017/meshcentral We recommend the user to include MongoDB configuration into the server\u2019s configuration \u201cconfig.json\u201d to avoid specifying the \u201c--mongodb\" each time MeshCentral is executed as shown below { \"settings\": { \"mongodb\": \"mongodb://127.0.0.1:27017/meshcentral\", \"mongodbcol\": \"meshcentral\" } } Note : By default, MeshCentral will create a single collections called \u201cmeshcentral\u201d in the specified database. If user want to specify a different collection name, use \u201c--mongodbcol\" or \u201cmongodbcol\u201d for settings like shown above. If you are using MongoDB with authentication, you can change the URL a little to add the username and password, for example: mongodb://username:password@127.0.0.1:27017/meshcentral You can also provide extra connection parameters like this: mongodb://username:password@127.0.0.1:27017/meshcentral?authMechanism=MONGODB-CR&authSource=db Running State-less \u00b6 By default, MeshCentral will read its configuration information from the \u201cmeshcentral-data\u201d folder. The most important file in that folder being the \u201cconfig.json\u201d file, but the folder also contains certificates, branding images, terms of service and more. After the configuration is read, MeshCentral will connect to its database and continue to start the server. For most user\u2019s this is a perfectly acceptable way to setup the server. However, in some cases, it\u2019s advantageous to setup the server \u201cstate-less\u201d. That is, there is no local configuration files at all and everything is in the database. Two examples of this would be when running MeshCentral is a Docker container where we don\u2019t want the container to have any state or for compliance with security specifications where the database is \u201cencrypted at rest\u201d. In this cases, we will load the configuration files into the database and MeshCentral will only be told how to connect to the database. When loading configuration information into the database, MeshCentral requires that a configuration file password be used to encrypt the configuration files in the database. This provides an additional layer of security on top of any authentication and security already provided by the database, if such security has been setup. To make this happen, we will be using the following command line options from MeshCentral: Command Description --configkey (key) Specifies the encryption password that will be used to read or write the configuration files to the database. --dblistconfigfiles List the names and size of all configuration files in the database. --dbshowconfigfile (filename) Show the content of a specified filename from the database. --configkey is required. --dbdeleteconfigfiles Delete all configuration files from the database. --dbpushconfigfiles (*) or (folder path) Push a set of configuration files into the database, removing any existing files in the process. When * is specified, the \u201cmeshcentral-data\u201d folder up pushed into the database. --configkey is required. --dbpullconfigfiles (folder path) Get all of the configuration files from the database and place them in the specified folder. Files in the target folder may be overwritten. --configkey is required. --loadconfigfromdb (key) Runs MeshCentral server using the configuration files found in the database. The configkey may be specified with this command or --configkey can be used. Once we have MeshCentral running as expected using the \u201cmeshcentral-data\u201d folder, we can simply push that configuration into the database and run using the database alone like this: node ./node_modules/meshcentral --dbpushconfigfiles * --configkey mypassword node ./node_modules/meshcentral --loadconfigfromdb mypassword --mongodb \"mongodb://127.0.0.1:27017/meshcentral\" This first line will load many of the \u201cmeshcentral-data\u201d files into the database. At this point, we can back up the \u201cmeshcentral-data\u201d folder and remove it. Then run the second line to start the server. Here we use MongoDB, but if one uses NeDB, the \u201cmeshcentral.db\u201d file in the \u201cmeshcentral-data\u201d folder will still be needed. Note that MeshCentral does not currently support placing a Let\u2019s Encrypt certificate in the database. Generally, one would use a reverse proxy with Let\u2019s Encrypt support and TLS offload in the reverse proxy and then run MeshCentral in state-less mode in a Docket container. Commandline Options \u00b6 In general, doing --option value is the same as adding \"option\": value in the settings section of the config.json. Here are the most common options found by running meshcentral --help Run as a background service --install/uninstall Install MeshCentral as a background service. --start/stop/restart Control MeshCentral background service. Run standalone, console application --user [username] Always login as [username] if account exists. --port [number] Web server port number. --redirport [number] Creates an additional HTTP server to redirect users to the HTTPS server. --exactports Server must run with correct ports or exit. --noagentupdate Server will not update mesh agent native binaries. --nedbtodb Transfer all NeDB records into current database. --listuserids Show a list of a user identifiers in the database. --cert [name], (country), (org) Create a web server certificate with [name] server name. country and organization can optionally be set. Server recovery commands, use only when MeshCentral is offline. --createaccount [userid] Create a new user account. --resetaccount [userid] Unlock an account, disable 2FA and set a new account password. --adminaccount [userid] Promote account to site administrator. TLS Offloading \u00b6 A good way for MeshCentral to handle a high traffic is to setup a TLS offload device at front of the server that takes care of doing all the TLS negotiation and encryption so that the server could offload this. There are many vendors who offer TLS or SSL offload as a software module (Nginx* or Apache*) so please contact your network administrator for the best solution that suits your setup. As shown in the picture below, TLS traffic will come from the Internet and security will be handled by a device ahead of the server and MeshCentral only has to deal with TCP connections. To make this work, it is important the server is setup with \u201c--tlsoffload\u201d. This indicates the server that TLS is already being taken care of and MeshCentral does not have to deal with it. MeshCentral will continue to listen to port 80, 443 and 4433. However, incoming port 443 (main web port) and 4433 (Intel\u00ae AMT MPS port) will not have TLS but MeshCentral will still put many HTTPS flags in its responses on port 443. By default, if a user accesses http://127.0.0.1:443 without TLS offloader setting, the browser is expected to display warnings. To make this work, TLS offloader device\u2019s ports and functions should be configured correctly like below Port Function Description 80 Directly forwards port 80 to MeshCentral port 80 443 Handle TLS using a web certificate and forward to MeshCentral port 443 4433 Handle TLS using MPS certificate and forward to MeshCentral port 4433 If possible, port 443 should be configured with a legitimate trusted certificate and the public part of the certificate named as \u201cwebserver-cert-public.crt\u201d must be placed inside of \u201cmeshcentral-data\u201d folder of the server. When the server is executed in tlsoffload mode, only the public part of the web certificate is used by the server. For Intel\u00ae AMT MPS port 4433, the certificate files \u201cmpsserver-cert-public.crt\u201d and \u201cmpsserver-cert-public.key\u201d must be copied from the \u201cmeshcentral-data\u201d folder and loaded into the TLS offload module. Note: Please consult the TLS offloader user manual from the respective vendor to configure TLS offloading feature correctly. Let\u2019s Encrypt support \u00b6 MeshCentral makes use of HTTPS to authenticate and encrypt management traffic over the network. By default, a self-signed certificate is used for the MeshCentral HTTPS server. That certificate is not trusted by browsers and so, you get a warning message when visiting the web site. You can solve this but obtaining a free trusted certificate from Let\u2019s Encrypt (https://letsencrypt.org/). There are some limitations and so, it\u2019s best to get familiar with this service before starting. You will also need a valid domain name that you own and that points to your MeshCentral server. Before moving forward with this section, make sure your MeshCentral server is working correctly, has a domain name pointing to it and that the HTTP redirection server on port 80 is enabled and working. MeshCentral\u2019s HTTP port 80 server will be used in the process to prove to Let\u2019s Encrypt that we have control over the domain. At any point, you may try to use https://letsdebug.net/ to see if your domain is setup correctly and/or debug any issues. When ready, add the \u201cletsencrypt\u201d section to the config.json file like this: { \"settings\" : { \"RedirPort\" : 80 , }, \"letsencrypt\" : { \"email\" : \"myemail@myserver.com\" , \"names\" : \"domain1.com,domain2.com\" , \"rsaKeySize\" : 3072 , \"production\" : false }, } The only mandatory field is the email address, please enter a valid one. The names section is a list of domain names the requested certificate will be valid for. This must be a list of DNS names that are already pointing to your server. It\u2019s important to understand you are not requesting these DNS names, rather, Let\u2019s Encrypt will makes requests to prove control over all of these domain name before issuing the certificate. All the domain names you enter must point to the server and HTTP port 80 must be reachable over the internet. If you don\u2019t specify names, the default MeshCentral certificate name is used, that is the configured \u201c--cert [name]\u201d. The RSA key size can only be 2048 or 3072, with the default being 3072. This is the number of bit used for the RSA key in the certificate. Bigger is more secure, but takes more time to compute. Lastly the production key, by default this is false. When set to false, MeshCentral will query the Let\u2019s Encrypt staging server for a certificate. It\u2019s highly recommended to try this first and make sure everything works before getting a real certificate. Keep production to false, run thru the process at least once and make sure everything works. You will get a new certificate installed on the HTTPS server signed by a staging Let\u2019s Encrypt certificate authority. The Let\u2019s Encrypt certificates and files will be created in the \u201cmeshcentral-data\u201d folder. Make sure to keep regular backups of the \u201cmeshcentral-data\u201d folder and all sub-folders. Once you placed the \u201cletsencrypt\u201d section in config.json, restart the server. The request to the Let\u2019s Encrypt server may take a few minutes to a few hours. It\u2019s best to have your DNS server name pointing to your server for over a day before doing this. Once the new certificate is received, the server will automatically restart and browsing to HTTPS on your server will show the new certificate. Here is what it looks like on FireFox: If you successfully setup a Let\u2019s Encrypt certificate using the Let\u2019s Encrypt staging server (\u201cproduction\u201d: false) and everything looks good, stop the server, remove the \u201cletsencrypt\u201d folder in \u201cmeshcentral-data\u201d, change production to \u201ctrue\u201d and start the server again. You should get a real certificate in a few minutes to a few hours. MeshCentral will automatically renew the certificate a few days before it expires. The MeshCentral self-signed certificate will still be present in the \u201cmeshcentral-data\u201d folder, this is normal and there is no need to manually copy the Let\u2019s Encrypt certificate to the \u201cmeshcentral-data\u201d folder. If something goes wrong with the Let\u2019s Encrypt certificate, the server will fall back to using the self-signed one. Note Please be patient with Let\u2019s Encrypt certificate requests and make sure you correctly get a staging certificate before setting production to true. If Let\u2019s Encrypt works for you, please consider donating to them as they provide a critical service to the Internet community. Server IP filtering \u00b6 For improved security, it\u2019s good to limit access to MeshCentral with IP address. For example, we want to allow mesh agents and Intel AMT computers to connect from anywhere, but whitelist IP address for users that we allow to access MeshCentral. MeshCentral provides IP filtering option in the config.json file for each domain. For an example, we can set IP address whitelist for the default domain like as shown below. { \"domains\": { \"\": { \"userallowedip\" : \"1.2.3.4,1.2.3.5\", } } } IP addresses are separated by a comma. As a result, only users coming these IP addresses will be able to see the server\u2019s login page as illustrated below. Other IP addresses will be blocked effectively. Note : When IP address whitelist is effective, Mesh Agent connection from any IP address will be not affected. Email Setup \u00b6 We highly recommend the use of an email server (SMTP) because we could allow MeshCentral to verify user account\u2019s email address by sending a confirmation request to the user to complete the account registration and for password recovery, should a user forget account password as illustrated below A verification email is sent when a new account is created or if the user requests it in the \u201cMy Account\u201d tab. The password recovery flow when \u201cReset Account\u201d is triggered at the login page. Both account verification and password recovery are triggered automatically once SMTP mail server configuration is included into the config.json file. Update the config.json with \u201csmtp\u201d section as shown below and restart the server. { \"smtp\" : { \"host\" : \"smtp.server.com\" , \"port\" : 25 , \"from\" : \"myaddress@server.com\" , \"user\" : \"myaddress@server.com\" , \uf0df Op t io nal \"pass\" : \"mypassword\" , \uf0df Op t io nal \"tls\" : false \uf0df Op t io nal , de fault false } } Please map the host, port values to connect to the right host that provides this SMTP service. For \u201cfrom\u201d value, administrators may put something like donotreply@server.com, but often times it needs to be a valid address since SMTP server will not send out messages with an invalid reply address. Some SMTP servers will require a valid username and password to login to the mail server. This is to prevent unauthorized e-mail correspondence. TLS option can be set to \u2018true\u2019 if the SMTP server requires TLS. One option is to configure MeshCentral work with Google Gmail* by setting \u201chost\u201d with smtp.gmail.com, and \u201cport\u201d with 587. In the config.json file, use user\u2019s Gmail* address for both \u201cfrom\u201d and \u201cuser\u201d and Gmail* password in the \u201cpass\u201d value. You will also need to enable \u201cLess secure app access\u201d in for this Google account. It\u2019s in the account settings, security section: If a Google account is setup with 2-factor authentication, the option to allow less secure applications not be available. Because the Google account password is in the MeshCentral config.json file and that strong authentication can\u2019t be used, it\u2019s preferable to use a dedicated Google account for MeshCentral email. Regardless of what SMTP account is used, MeshCentral will perform a test connection to make sure the server if working as expected when starting. Hence, the user will be notified if Meshcentral and SMTP server has been configured correctly as shown below. Embedding MeshCentral \u00b6 One interesting way to use MeshCentral is to embed its features into another web site. In other words, certain feature of MeshCentral can be selectively embedded into another website such as Remote Desktop or File Transfer. This allows another site to take care of the user accounts and business processes while MeshCentral takes care of remote management. In the example below, a user logs into an existing web site and received a page with MeshCentral remote desktop embedded into it. To make this work, a following key alignment is required: 1. When a user requests the business website, the business web server must return the user a web page containing an iframe with a URL that points to the MeshCentral server. 2. The URL must contain both a login token and embedding options. The login token tells MeshCentral under what MeshCentral account this request should be made. 3. The login token replaces the login screen of MeshCentral. Then, the embedding options can be used to specify no page title, header and footer to be displayed. This way, the page given by MeshCentral will fit nicely into the iframe. In this section we will review both the login token and embedding options mentioned above. Login Token \u00b6 With MeshCentral, it\u2019s possible to login to the main web page without even seeing the login screen. Of course, you can do this by specifying \u201c--nousers\" or \u201c--user admin\u201d when you run the server, but these approach are not secure as it removes user authentication for those accessing the server. With login tokens feature, a token can be generated to be used for a short time to login and skip the login page. This is perfect for embedding MeshCentral usages into other web site and probably for other applications. To enable this feature, configure config.json file to allow login tokens. { \"settings\" : { \"allowLoginToken\" : true , \"allowFraming\" : true } } Set both allowLoginToken and allowFraming to \u2018true\u2019 to use login tokens along with framing MeshCentral within another web page. Next, create a token. Execute MeshCentral with the \u201c--logintoken [userid]\u201d switch and userid value with the example below: The \u201cuserid\u201d is actually a combination of three values - user, domain, and username in a single string \u201cuser/domain/username\u201d. The example above is using a default domain which is empty hence, the userid will be just \u201cuser//admin\u201d to request for login token. Domains are only used if the server in multi-tenancy mode as discussed in previous chapters. The resulting hashed base64 encoded blob can be used as a login token for 1 hour. Simply add the \u201c?login=\u201d followed by the token value generated to the URL of the webserver. For an e.g. https://localhost/?login=23tY7@wNbPoPLDeXVMRmTKKrqVEJ3OkJ. The login page is expected to be skipped and automatically login the user admin. This is just a manual attempt to token based login. Now, to have this work seamlessly with a different website, we should generate a login token key. A token key can be used to generate login tokens whenever needed for MeshCentral. Generate this key with \u201c--loginTokenKey\" switch as shown below The generated masker key must be placed in a secure location within the business website. As illustrated above, we see the business site using the token key to generate a login token and embed it into the response web page. The user\u2019s browser then loads the iframe that includes both the URL with the login token for MeshCentral. MeshCentral can then verify the token and allow the web page to load as expected. Embedding Options \u00b6 There are multiple options available for user to explicitly choose the features that will be loaded from MeshCentral to the business website. The argument in the in the URL can dictate which web page should display and how. The three embedding URL arguments are Viewmode, Hide and Node. Embedding Options / URL Argument Description \"Values Note : For values 10 and above, a node identifier must be specified.\" viewmode \"Indicates the information to show. This is an integer value, possible values are:\" \"1 = Devices tab 2 = Account tab 3 = Events tab 4 = Users tab (Site admins only) 5 = Server files tab 10 = Device general information 11 = Device remote desktop 12 = Device terminal 14 = Device Intel AMT console. 15 = Device Mesh Agent console hide \"Indicates which portion of the web page to hide. This is a bitmask integer hence it will need the sum of values. For .e.g.: To hide all of the values, add 1+2+4+8 and use 15 as the value. 1 = Hide the page header 2 = Hide the page tab 4 = Hide the page footer 8 = Hide the page title 16 = Hide the left tool bar 32 = Hide back buttons node Optional unless Viewmode is set to value of 10 or greater. Indicates which node to show on the screen, For example, if we want to embed the remote desktop page for a given node and hide the header, tabs, footer and page title, we could have this URL: https://localhost/?node=UkSNlz7t...2Sve6Srl6FltDd&viewmode=11&hide=15\" Node or NodeID is a long base64 encoded SHA384 value Note : Typically, the URL for the website is followed by \u201c?\u201d then a set of name=value pairs separated by \u201c&\u201d. Based on the URL https://localhost/?node=UkSNlz7t...2Sve6Srl6FltDd&viewmode=11&hide=15 , the nodeID starts with \u201cUkSNlz7t\u201d. We shortened the value in this example, but it\u2019s normally a long base64 encoded SHA384 value. The Viewmode set to 11 which is the remote desktop page and Hide set to 15 to hide everything. Hence the user may see as illustrated below. Only the remote desktop viewer will be displayed embedded within an iframe. Note : User must set \u201callowFraming\u201d to true in the config.json of the server. This is in addition to the Node, Viewmode and Hide arguments, the login token must be specified to add complex features into another website. Server port aliasing \u00b6 In some cases, you may be setting up a server on a private network that uses non-standard ports, but use a router or firewall in front to perform port mapping. So, even if the server privately uses non-standard ports, the public ports are the standard ports 80 and 443. You have to tell MeshCentral to bind to private ports but pretend it\u2019s using the other standard ports when communicating publically. To make this work, MeshCentral supports port aliasing. For example you can run: node meshcentral --redirport 2001 --port 2002 --aliasport 443 Here, the server binds the HTTP and HTTPS ports to 2001 and 2002, but the server will externally indicate to MeshAgents and browsers that they must connect to port 443. In a different situation, you may want to setup a server so that both Mesh Agents and Intel AMT connect back to the server on port 443. This is useful because some corporation have firewalls that restrict outgoing connections to only port 80 and 443. By default, MeshCentral will be setup to have MeshAgents connection on port 443 and Intel AMT on port 4433. In the following picture we have a usual server running with: node meshcentral --cert Server1 --port 443 --mpsport 4433 We can setup the server so that MeshAgent and Intel AMT will connect on port 443 of two different IP address or names like this: node meshcentral --cert Server1 --mpscert Server2 --port 443 --mpsport 4433 --mpsaliasport 443 In the second example, the server on the right is running HTTPS on port 443 and MPS on port 4433 as usual, but the MPS is now presenting a certificate that has the name \u201cServer2\u201d on it. The server will also configure Intel AMT CIRA to connect to \u201cServer2:443\u201d. A router or firewall that is located in front of the MeshCentral server needs to be configured correctly to forwarding: Server1:443 -> 443 on MeshCentral Server2:443 -> 4433 on MeshCentral The routing of IP and ports by the firewall shown on the picture must be configured separately from MeshCentral using separate software. Typically, routers or firewalls have the proper controls to configure this type of traffic routes. Device Groups with Relay Agent \u00b6 MeshCentral supports the local device group allowing devices that do not have an agent to be managed thru MeshCentral with regular SSH, SFTP, RDP, VNC protocols. Until now, the MeshCentral server had to be in LAN or Hybrid modes to support his device group and the managed devices had to be on the same network as the MeshCentral server. Starting with v1.0.11, users can create a local device group specifying a MeshAgent as a relay. This makes it possible to manage agent-less devices from anywhere on the Internet even if the server is in WAN mode. Simply install a single device with a MeshAgent on a network and create a local device group with that device as the relay. To enable SSH support, add this line to the domain section of your config.json: \"ssh\" : true Video Walkthru Raritan and WebPowerSwitch with Relay \u00b6 In addition to local device groups, the IP-KVM/Power switch device group was also improved to support a MeshAgent as a relay. This is big news for Raritan IP-KVM switch owners as you can now monitor your IP-KVM ports and access them remotely from the Internet. The same can be done with WebPowerSwitch allowing full out-of-band remote access to devices from anywhere in the world. NGINX Reverse-Proxy Setup \u00b6 Video Walkthru \u00b6 Sometimes it\u2019s useful to setup MeshCentral with a reverse-proxy in front of it. This is useful if you need to host many services on a single public IP address, if you want to offload TLS and perform extra web caching. In this section we will setup NGINX, a popular reverse-proxy, in front of MeshCentral. NGNIX is available at: https://www.nginx.com/ In this example, we will: MeshCentral on non-standard ports, but alias HTTPS to port 443. NGINX will be using standard ports 80 and 443. We will have NGINX perform all TLS authentication & encryption. MeshCentral will read the NGINX web certificate so agents will perform correct server authentication. NGINX will be setup with long timeouts, because agents have long standard web socket connections. Let\u2019s get started by configuring MeshCentral with the following values in config.json: { \"settings\" : { \"Cert\" : \"myservername.domain.com\" , \"Port\" : 4430 , \"AliasPort\" : 443 , \"RedirPort\" : 800 , \"AgentPong\" : 300 , \"TlsOffload\" : \"127.0.0.1\" }, \"domains\" : { \"\" : { \"certUrl\" : \"https://127.0.0.1:443/\" } } } With this configuration, MeshCentral will be using port 4430 instead of port 443, but because \u201cTlsOffload\u201d is set, TLS will not be performed on port 4430. The server name is set to \u201cmyservername.domain.com\u201d, so that is the name that MeshCentral will give to agents to connect to. Also, the alias port is set to 443. So agents will be told to connect to \u201cmyservername.domain.com:443\u201d. The \u201cAgentPong\u201d line instructs the server to send data to the agent each 300 seconds and the agent by default will send data to the server every 120 seconds. As long as NGINX timeouts are longer than this, connections should remain open. When agents connect, they will see the NGINX TLS certificate on port 443. MeshCentral needs to know about the NGINX certificate so that it can tell the agents this is the correct certificate they should expect to see. So, \u201ccertUrl\u201d is used to tell MeshCentral where to get the certificates that agents will see when connecting. When NGINX forwards connections to MeshCentral, extra X-Forwarded headers will be added to each request. MeshCentral needs to know if these headers can be trusted or not. By setting \u201cTlsOffload\u201d to \u201c127.0.0.1\u201d, MeshCentral is told to trust these headers when requests come from \u201c127.0.0.1\u201d. In this example, make sure to change \u201c127.0.0.1\u201d to the IP address of NGINX and \u201cCert\u201d to the external DNS name of the NGINX server. Next, we need to configure and launch NGINX. Here is an ngnix.conf to get started: worker_processes 1; events { worker_connections 1024; } http { # HTTP server. In this example, we use a wildcard as server name. server { listen 80; server_name _; location / { proxy_pass http://127.0.0.1:800/; proxy_http_version 1.1; # Inform MeshCentral about the real host, port and protocol proxy_set_header X-Forwarded-Host $host:$server_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } # HTTPS server. In this example, we use a wildcard as server name. server { listen 443 ssl; server_name _; # MeshCentral uses long standing web socket connections, set longer timeouts. proxy_send_timeout 330s; proxy_read_timeout 330s; # We can use the MeshCentral generated certificate & key ssl_certificate webserver-cert-public.crt; ssl_certificate_key webserver-cert-private.key; ssl_session_cache shared:WEBSSL:10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:4430/; proxy_http_version 1.1; # Allows websockets over HTTPS. proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $host; # Inform MeshCentral about the real host, port and protocol proxy_set_header X-Forwarded-Host $host:$server_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } } As indicated in the comments of this NGINX configuration file, we set timeouts to be really long. We forward HTTP port 80 and HTTPS port 443 to the corresponding ports on MeshCentral. In this example, we happen to use the web certificates that where generated by MeshCentral, but any certificate is ok. We also add extra \u201cX-Forward\u201d headers, this tells MeshCentral information that would normally be hidden by NGINX, like the client\u2019s IP address and more. Now we are ready to start NGINX and MeshCentral. You should start NGINX first because MeshCentral will try to fetch the certificate from NGINX upon start. When starting MeshCentral, you should see something like this: MeshCentral HTTP redirection web server running on port 800. Loaded RSA web certificate at https://127.0.0.1:443/, SHA384: d9de9e27a229b5355708a3672fb23237cc994a680b3570d242a91e36b4ae5bc96539e59746e2b71eef3dbdabbf2ae138. MeshCentral Intel(R) AMT server running on myservername.domain.com:4433. MeshCentral HTTP web server running on port 4430, alias port 443. Notice on the second line, MeshCentral will have loaded the web certificate from NGNIX and display a matching hash. That is it, navigating to port 80 and 443 on NGINX should show the MeshCentral web page and agents should connect as expected. CIRA Setup with NGINX \u00b6 We can add on the section above and support reverse proxy for Intel\u00ae AMT Client Initiated more Access (CIRA) connecting that come to the server. Normally, CIRA connections come on port 4433 and use TLS. Since CIRA is a binary protocol, care must be taken to configure NGINX to handle the data as a TCP stream instead of HTTP. At the very bottom of the nginx.conf file, we can add the following: stream { # Internal MPS servers, in this case we use one MeshCentral MPS server is on our own computer. upstream mpsservers { server 127.0.0.1:44330 max_fails=3 fail_timeout=30s; } # We can use the MeshCentral generated MPS certificate & key ssl_certificate mpsserver-cert-public.crt; ssl_certificate_key mpsserver-cert-private.key; ssl_session_cache shared:MPSSSL:10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # MPS server. server { listen 4433 ssl; proxy_pass mpsservers; proxy_next_upstream on; } } NGINX will listen on port 4433, decrypt the connection and forward it to 44330 on the loopback interface. We are going to be used the \u201cmpsserver\u201d certificate that was created by MeshCentral as the TLS server certificate for port 4433. Now, we just have to make a few changes to the MeshCentral config.json file. { \"settings\": { \"Cert\": \"myservername.domain.com\" \"Port\": 4430, \"AliasPort\": 443, \"RedirPort\": 800, \"TlsOffload\": \"127.0.0.1\" \"MpsPort\": 44330, \"MpsAliasPort\": 4433, \"MpsTlsOffload\": true }, \"domains\": { \"\": { \"certUrl\": \"https://127.0.0.1:443/\" } } } In this new config.json, we added 3 lines. First, the MeshCentral Management Presence Server (MPS) is now on port 44330. However, the MpsAliasPort value indicates that externally, port 4433 will be used, so we need to configure Intel AMT to connect to port 4433. Lastly, we want to disable TLS support on port 44330 by setting \u201cMpsTlsOffload\u201d to true. With this configuration, Intel AMT CIRA connections will come in and TLS will be handled by NGINX. With this setup, it\u2019s not possible to configure Intel AMT CIRA to connect using mutual-TLS authentication, only username/password authentication is used. Traefik Reverse-Proxy Setup \u00b6 In this section, we will setup MeshCentral with Traefik, a popular reverse proxy software. This section will be much like the previous section setting up NGNIX but with a different software and configuration file. Traefik is open source and available at: https://traefik.io/ This section covers a really simple Traefik configuration. Traefik is capable of a lot more complex configurations. In this example, we will: MeshCentral on non-standard ports, but alias HTTPS to port 443. Traefik will be using standard ports 80 and 443. We will have Traefik perform all TLS authentication & encryption. MeshCentral will read the NGINX web certificate so agents will perform correct server authentication. First we will start with the MeshCentral configuration, here is a minimal configuration that will work: { \"settings\" : { \"Cert\" : \"myservername.domain.com\" , \"Port\" : 4430 , \"AliasPort\" : 443 , \"RedirPort\" : 800 , \"TlsOffload\" : \"127.0.0.1\" }, \"domains\" : { \"\" : { \"certUrl\" : \"https://127.0.0.1:443/\" , \"agentConfig\" : [ \"webSocketMaskOverride=1\" ], } } } Note the \u201cagentConfig\u201d line : Because Traefik does not support web socket connections that are not \u201cmasked\u201d, we have to tell the Mesh Agents to mask web socket connections using this line. Once set, any new agent will be installed with the web socket masking turned on. Also note that we will be running MeshCentral on port HTTPS/4430 and HTTP/800. However, we also indicate to MeshCentral that HTTPS will really be on port 443 using the \u201cAliasPort\u201d line. The \u201cTlsOffload\u201d line indicates that MeshCentral should not perform TLS on port 4430. And the \u201ccertUrl\u201d line indicates what URL can be used to load the external certificate that will be presented on port 443 in front of MeshCentral. Now that we have MeshCentral setup, let\u2019s take a look at a sample Traefik configuration file. In this case, we will manually configure the entrypoints, frontends and backends within the Traefik configuration file. There is a basic configuration file for Traefik 1.7: [ global ] checkNewVersio n = false se n dA n o n ymousUsage = false [ e ntr yPoi nts ] [ e ntr yPoi nts .h tt p ] address = \":80\" [ e ntr yPoi nts .h tt p.redirec t ] e ntr yPoi nt = \"https\" [ e ntr yPoi nts .h tt ps ] address = \":443\" [ e ntr yPoi nts .h tt ps. tls ] [[ e ntr yPoi nts .h tt ps. tls .cer t i f ica tes ]] cer t File = \"webserver-cert-public.crt\" keyFile = \"webserver-cert-private.key\" [ f ile ] [ backe n ds ] [ backe n ds.backe n d 1 ] [ backe n ds.backe n d 1. heal t hcheck ] pa t h = \"/health.ashx\" i nter val = \"30s\" [ backe n ds.backe n d 1. servers.server 1 ] url = \"http://127.0.0.1:4430\" weigh t = 1 [ fr o nten ds ] [ fr o nten ds. fr o nten d 1 ] e ntr yPoi nts = [ \"https\" ] backe n d = \"backend1\" passHos t Header = true [ fr o nten ds. fr o nten d 1. rou tes ] [ fr o nten ds. fr o nten d 1. rou tes .mai n ] rule = \"Host:myserver.domain.com,localhost\" [ api ] e ntr yPoi nt = \"traefik\" dashboard = true The enterPoints section shows we have two entry points, port 80 will be redirected to port 443. Traefik will perform this redirection so MeshCentral will never see port 80 connections. Port 443 will be setup using the given TLS certificates. In this example, we just used the certificate files generated by MeshCentral in the \u201cmeshcentral-data\u201d folder. You can use the two certificate files as-is. The backends section configures one MeshCentral server on port \u201c4430\u201d. Traefik will additionally check the health of the MeshCentral server periodically, every 30 seconds. The frontends section is what routes the connections coming in the entry points to the backend servers. In this case, the HTTPS entry point is routed to the MeshCentral server is the hostname matches \u201cmyserver.domain.com\u201d or \u201clocalhost\u201d. Finally, the API section creates a web portal on port 8080 for monitoring of Traefik. HAProxy Reverse-Proxy Setup \u00b6 In this section, we will setup MeshCentral with HAProxy, a small popular reverse proxy software. This section will be much like the previous sections setting up NGNIX and Traefik but with a different software and configuration file. HAProxy is free and available at: https://www.haproxy.org/ This section covers a really simple configuration. HAProxy is capable of a lot more complex configurations. In the following example, HAProxy will perform TLS and forward the un-encrypted traffic to MeshCentral on port 444. HAProxy will add extra \u201cX-Forwarded-Host\u201d headers to the HTTP headers so that MeshCentral will know from the IP address the connection comes from. In the following configuration file, we have browser connections on port 80 being redirected to HTTPS port 443. We also have Let\u2019s Encrypt cert bot for getting a real TLS certificate and \u201cmesh.sample.com\u201d being redirected to 127.0.0.1:444. global log /dev/log local0 log /dev/log local1 notice chroot /var/lib/haproxy stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners stats timeout 30s user haproxy group haproxy daemon defaults log global mode http option httplog option dontlognull option forwardfor option http-server-close frontend http bind *:80 redirect scheme https code 301 if !{ ssl_fc } frontend https bind *:443 ssl crt /etc/haproxy/cert.pem http-request add-header X-Forwarded-Proto https acl acmepath path_beg /.well-known/acme-challenge/ acl meshcentralhost hdr(host) -i mesh.sample.com acl meshcentralhost hdr(host) -i mesh.sample.com:443 use_backend acme if acmepath use_backend meshcentral if meshcentralhost backend acme server certbot localhost:54321 backend meshcentral http-request add-header X-Forwarded-Host %[req.hdr(Host)] server meshcentral 127.0.0.1:444 On the MeshCentral side, we are not going to use port 80 and need the main HTTPS port to not perform TLS and listen on port 444. { \"settings\" : { \"Cert\" : \"myservername.domain.com\" , \"Port\" : 444 , \"AliasPort\" : 443 , \"RedirPort\" : 0 , \"TlsOffload\" : \"127.0.0.1\" }, \"domains\" : { \"\" : { \"certUrl\" : \"https://127.0.0.1:443/\" } } } We also specify \u201c127.0.0.1\u201d in TLS offload since we want MeshCentral to make use of the X-Forwarded-Host header that is set by HAProxy. Running in a Production Environment \u00b6 When running MeshCentral is a production environment, administrators should set NodeJS to run in production mode. There is a good article here (http://www.hacksparrow.com/running-express-js-in-production-mode.html) on what this mode is and how to set it. This mode will also boost the speed of the web site on small devices like the Raspberry Pi. To run in production mode, the environment variable \u201cNODE_ENV\u201d must be set to \u201cproduction\u201d. On Linux, this is done like this: export NODE_ENV=production On Windows, it\u2019s done like this: SET NODE_ENV=production Special care must be taken to set the environment variable in such a way that if the server is rebooted, this value is still set. Once set, if you run MeshCentral manually, you will see: MeshCentral HTTP redirection web server running on port 80. MeshCentral v0.2.2-u, Hybrid (LAN + WAN) mode, Production mode. MeshCentral Intel(R) AMT server running on devbox.mesh.meshcentral.com:4433. MeshCentral HTTPS web server running on devbox.mesh.meshcentral.com:443. In production mode, ExpressJS will cache some files in memory making the web server much faster and any exceptions thrown by the ExpressJS will not result in the stack trace being sent to the browser. Two step authentication \u00b6 If the MeshCentral server is setup with a certificate name and not setup to use Windows domain authentication, then users will have the options to use 2-step authentication using the Google Authenticator application or any compatible application. Use of this option should be encouraged for users that manage a lot of critical computers. Once active the users will need to enter their username, password and a time limited token to login. To get this features setup, users will need to go to the \u201cMy Account\u201d tab or the \u201cMy Account\u201d menu in the mobile application. They then select, \u201cAdd 2-stop login\u201d and follow the instructions. Note that if a user performs a password recovery using email, the 2-step authentication is then turned off and will need to be turned on again. This is not idea as someone being able to intercept the user\u2019s email could still log into the web site. Users should make sure to properly protect their email account. Branding & Terms of use \u00b6 Once MeshCentral is setup, you may want to customize the web site with your own brand and terms of use. This is important to personalize the web site to your organization. We also want to customize the web site in such a way that updating to the latest version will keep the branding as-is. Branding \u00b6 You can put you own logo on the top of the web page. To get started, get the file \u201clogoback.png\u201d from the folder \u201cnode_modules/meshcentral/public/images\u201d and copy it to your \u201cmeshcentral-data\u201d folder. In this example, we will change the name of the file \u201clogoback.png\u201d to \u201ctitle-mycompagny.png\u201d. Then use any image editor to change the image and place your logo. Once done, edit the config.json file and set the following values: \"domains\" : { \"\" : { \"Title\" : \"\" , \"Title2\" : \"\" , \"TitlePicture\" : \"title-sample.png\" , }, This will set the title and sub-title text to empty and set the background image to the new title picture file. You can now restart the serve and take a look at the web page. Both the desktop and mobile sites will change. The title image must a PNG image of size 450 x 66. You can also customize the server icon in the \u201cMy Server\u201d tab. By default, it\u2019s a picture of a desktop with a padlock. If, for example, MeshCentral is running on a Raspberry Pi. You may want to put a different picture at this location. Just put a \u201cserver.jpg\u201d file that is 200 x 200 pixels in the \u201cmeshcentral-data\u201d folder. The time MeshCentral page is loaded, you will see the new image. This is great to personalize the look of the server within the web site. Terms of use \u00b6 You can change the terms of use of the web site by adding a \u201cterms.txt\u201d file in the \u201cmeshcentral-data\u201d folder. The file can include HTML markup. Once set, the server does not need to be restarted, the updated terms.txt file will get used the next time it\u2019s requested. For example, placing this in \u201cterms.txt\u201d <br /> This is a <b>test file</b>. Will show this on the terms of use web page. Server Backup & Restore \u00b6 It\u2019s very important that the server be backed up regularly and that a backup be kept offsite. Luckily, performing a full backup of the MeshCentral server is generally easy to do. For all installations make sure to back up the following two folders and all sub-folders. meshcentral-data meshcentral-files If using NeDB that is built into MeshCentral, you are done. If you are running MongoDB, you will need to perform an extra step. In the command shell, run mongodump to archive all of the MongoDB databases. mongodump --archive=backup.archive Then, keep the backup.archive file in a safe place. It\u2019s critical that the content of meshcentral-data be backed up in a secure location and preferably using encryption, this is because it contains certificates that give this server its unique personality. Once agents are installed, they will only connect to this server and no other. If you reinstall MeshCentral, even if it is with the same domain name, agents will not connect to the new server since the server certificates are different. Also, someone with access to a backup of \u201cmeshcentral-data\u201d could impersonate the server. To restore back backup, just install a MeshCentral server, make sure it works correctly. Stop it, wipe the old \u201cmeshcentral-data\u201d and \u201cmeshcentral-files\u201d and put the backup version instead. If using MongoDB, copy the backup.archive back, make sure to clean up any existing \u201cmeshcentral\u201d database, run \u201cmongo\u201d and type: use meshcentral db.dropDatabase() Then exit with Ctrl-C and run: mongorestore --archive=backup.archive This will re-import the database from the backup. You can then start MeshCentral again. Note The two values for backup and restore in the json are only valid for databases backed by NeDB Backup to Google Drive \u00b6 sudo systemctl stop meshcentral.service nano /opt/meshcentral/meshcentral-data/config.json Remove underscored items sudo systemctl start meshcentral.service sudo systemctl status meshcentral.service Log into your MC: Create desktop app Enter the Client ID and Client Secret into MC HashiCorp Vault support \u00b6 MeshCentral has built-in support for HashiCorp Vault so that all configuration and certificates used by MeshCentral are retrieved from a Vault server. Vault is a secret store server and when used with MeshCentral, the MeshCentral server will not be storing any secrets locally. You can get started with Vault here: https://www.vaultproject.io/ Once you got a MeshCentral server working correctly, you can start a simple demonstration Vault server by typing: vault server -dev When you run the server in developer mode, you will see a secret token and unseal key on the screen. These two values will be used in the commands to follow. You can load the configuration file and all certificates from \u201cmeshcentral-data\u201d into Vault by typing this: node node_modules/meshcentral --vaultpushconfigfiles --vault http://127.0.0.1:8200 --token s.cO4\u2026 --unsealkey 7g4w\u2026 --name meshcentral Once all of the files have been written into Vault, you can take a look at the Vault web user interface to see all of the secrets. It will be in \u201csecret/meshcentral\u201d: The \u201cconfig.json\u201d and \u201cterms.txt\u201d files and files in \u201cmeshcentral-data\u201d that end with \u201c.key\u201d, \u201c.crt\u201d, \u201c.jpg\u201d and \u201c.png\u201d will be stored in Vault. You can then run MeshCentral like this: node node_modules/meshcentral --vault http://127.0.0.1:8200 --token s.cO4\u2026 --unsealkey 7g4w\u2026 --name meshcentral MeshCentral will first read all of the files from Vault and get started. An alternative to this is to create a very small config.json file in \u201cmeshcentral-data\u201d that contains only the Vault configuration like this: { \"settings\" : { \"vault\" : { \"endpoint\" : \"http://127.0.0.1:8200\" , \"token\" : \"s.cO4Q\u2026\" , \"unsealkey\" : \"7g4wFC\u2026\" , \"name\" : \"meshcentral\" } } } Once the config.json file is setup, you can just run MeshCentral without any arguments. node node_modules/meshcentral Lastly you can all pull all of the files out of Vault using this command line: node node_modules/meshcentral --vaultpullconfigfiles --vault http://127.0.0.1:8200 --token s.cO4\u2026 --unsealkey 7g4w\u2026 --name meshcentral And delete the Vault secrets using this: node node_modules/meshcentral --vaultdeleteconfigfiles --vault http://127.0.0.1:8200 --token s.cO4\u2026 --unsealkey 7g4w\u2026 --name meshcentral Database Record Encryption \u00b6 Regardless if using the default NeDB database or MongoDB, MeshCentral can optionally encrypt sensitive data that is stored in the database. When enabled, this encryption is applied to user credentials and Intel AMT credentials. The additional encryption does the affect database operations and can be used in addition to additional database security. In the following image, we see on the left a normal user record including user credential hashes and data required for two-factor authentication. On the right side, these values are encrypted using AES-256-GCM in the \u201c_CRYPT\u201d field. Only some data fields are encrypted and the \u201c_CRYPT\u201d entry will only be present when one or more fields are present that need to be secured. To enable this feature, add the \u201cDbRecordsEncryptKey\u201d with a password string to the \u201csettings\u201d section of the config.json like this: { \"settings\" : { \"Port\" : 4430 , \"RedirPort\" : 800 , \"DbRecordsEncryptKey\" : \"MyReallySecretPassword\" } } The provided password will be hashed using SHA384 and the result with be used as an encryption key. When DbRecordsEncryptKey is set, any new or updated records that are written will be encrypted when needed. Existing encrypted records will be read and decrypted as needed. You can force the all entries to be re-written by running: node node_modules/meshcentral --recordencryptionrecode This command will re-write entries in the database that could require added security and force the application of record encryption. You can also specify a key for decryption only like this: { \"settings\" : { \"Port\" : 4430 , \"RedirPort\" : 800 , \"DbRecordsDecryptKey\" : \"MyReallySecretPassword\" } } When set, the key will only be used for decryption and any new or updated records in the database will not be written with record encryption. You can then run this command again to force all records to be rewritten without encryption: node node_modules/meshcentral --recordencryptionrecode It\u2019s really important to keep the encryption key in a safe place along with database backups. If the database is backed up but the record encryption key is lost, it will not be possible to recover the secured data in the database. Also note that database record encryption can and should be used along with other data protection systems. MongoDB free server monitoring \u00b6 If running with MongoDB version 4.x, there is a free database monitoring service that is provided. Just run \u201cmongo\u201d and you may see the following: Type \u201cdb.enableFreemonitoring()\u201d if you want to enable this. You will be given a URL to access the data and can turn it back off at any time. The web page will look something like this: In addition to database specific information, the graphs track CPU, memory and disk usage. This can be useful to track how well the server is responding under load. MeshCentral Single Sign-On (SSO) \u00b6 As with any web application deployed in organization, it\u2019s convenient and more secure for users to have a single set of credentials that can be used across many services. In this section we take a look at how to configure MeshCentral so that you can sign-in using credentials from other services. This allows users to completely skip creating a user account on MeshCentral or having to remember usernames and password for one more web site. There are two single sign-on protocols that are supported in MeshCentral, OAuth2 and SAML. We will take a look at an example for each one. Before you get started, your MeshCentral server must be publicly facing on the internet and have a valid TLS certificate. For example, by setting up Let\u2019s Encrypt. After the web site is working correctly user the steps below. Twitter Authentication \u00b6 Like many other services, Twitter allows its users to login to other web site using Twitter credentials using OAuth2. Start by creating an account on Twitter and logging in. Then navigate to https://developer.twitter.com/en/apps , this is where you can create new applications that are compatible with Twitter. Start by creating a new application and fill in the application form. Give your application and name, description, server URL and more. Make sure to select \u201cEnable Sign in with Twitter\u201d and set the callback URL to \u201chttps://(server.domain.com)/auth-twitter-callback\u201d. This is the URL that Twitter will redirect users to once they are logged in. For example this is what a sample application would look like: Once the new application is created, go to the \u201cKeys and tokens\u201d tab. You will need the \u201cAPI Key\u201d and \u201cAPI secret key\u201d values. In the MeshCentral config.json, place these two values as \u201cclientid\u201d and \u201cclientsecret\u201d of the Twitter section of the \u201cAuthStrategies\u201d. Once done, your config.json should look a bit like this: { \"settings\" : { \"Cert\" : \"myserver.mydomain.com\" , \"Port\" : 443 , \"RedirPort\" : 80 }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"NewAccounts\" : true , \"authStrategies\" : { \"twitter\" : { \"clientid\" : \"xxxxxxxxxxxxxxxxxxxxxxx\" , \"clientsecret\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" } } } } } Note that if you do not allow new accounts, any new users that use Twitter credentials will not be able to login to MeshCentral. One trick is to allow new account, login and change this setting again. Once the config.json is correct, restart the server and you should see the Twitter icon on the login screen. When restarting the MeshCentral server, new modules will need to be installed to support this new feature. Depending on how your server is setup, you may need to restart the server manually to allow the new modules to be installed. Google, GitHub, Reddit Authentication \u00b6 The exact same process as shown in the previous section can be repeated for Google, GitHub and Reddit. In each case, you need to go to each respective credential provider and get a \u201cClientID\u201d and \u201cClientSecret\u201d for each service. You also need to register the correct callback URL for each service. Take a look at the config.json below and note the callback URL that will need to be registered for each service provider. { \"settings\" : { \"Cert\" : \"myserver.mydomain.com\" , \"Port\" : 443 , \"RedirPort\" : 80 }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"NewAccounts\" : true , \"authStrategies\" : { \"twitter\" : { \"__callbackurl\" : \"https://server/auth-twitter-callback\" , \"clientid\" : \"xxxxxxxxxxxxxxxxxxxxxxx\" , \"clientsecret\" : \" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \" }, \"google\" : { \"__callbackurl\" : \"https://server/auth-google-callback\" , \"clientid\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com\" , \"clientsecret\" : \"xxxxxxxxxxxxxxxxxxxxxxx\" }, \"github\" : { \"__callbackurl\" : \"https://server/auth-github-callback\" , \"clientid\" : \"xxxxxxxxxxxxxxxxxxxxxxx\" , \"clientsecret\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" }, \"reddit\" : { \"__callbackurl\" : \"https://server/auth-reddit-callback\" , \"clientid\" : \"xxxxxxxxxxxxxxxxxxxxxxx\" , \"clientsecret\" : \" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \" } } } } } It\u2019s possible to enable all four of these service providers at the same time to offer the most flexibility for users. Note that when using an OAuth service provider, MeshCentral does not offer two-factor authentication since it will be handled by the provider depending on user configuration. Microsoft Azure Active Directory \u00b6 In this section we look at how to setup MeshCentral to Azure Active Directory using OAuth. Like all other sections about setting up single sign-on, make sure your MeshCentral server is already setup on the public Internet with a valid TLS certificate. You can then start by adding a new application registration to the Azure portal. We give our application a name, generally the domain name of the MeshCentral server is a good choice. Then you can setup the redirect URL to https://[servername]/auth-azure-callback. Make sure to type this correctly, all lower case with the full domain name of your MeshCentral server. Once done, there are two values we will need later, the Application ID and Tenant ID. Next, we need to create a secret that will be shared between Azure and MeshCentral. Go to the \u201cCertificates & secrets\u201d section and click \u201cNew client secret\u201d. You then enter a name and for our example, we will opt to never make it expire. We then copy the resulting secret and this will be the 3 rd and final value we need to get MeshCentral setup. Now, we take the application ID, tenant ID and secret and place these values in the MeshCentral config.json like so: { \"settings\" : { \"Cert\" : \"myserver.mydomain.com\" , \"Port\" : 443 , \"RedirPort\" : 80 }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"NewAccounts\" : false , \"authStrategies\" : { \"azure\" : { \"newAccounts\" : true , \"clientid\" : \"be4aadd3-77b8-4e55-af8a-4b8e2d994cb5\" , \"clientsecret\" : \"NP0XXXXXXXXXXXXXXXXXXX\" , \"tenantid\" : \"18910a48-e492-4c49-8043-3449f7964bd6\" } } } } } The \u201cApplication ID\u201d value is placed as \u201cClient ID\u201d in the configuration file. You can also see that in the example above, we have \u201cNewAccounts\u201d set to false in the default MeshCentral domain, but set to true in the Azure section. This indicates that new accounts are not allowed in this domain except if it\u2019s a new user that is authenticating thru Azure. Once done, restart the MeshCentral server. Depending on your setup, you many need to run MeshCentral once manually to allow new required modules to be installed. Once running again, you should see the Azure single sign-on button on the login page. JumpCloud Authentication using SAML \u00b6 While using OAuth may be interesting, it\u2019s more likely that MeshCentral servers used in an enterprise environment will want to use SAML (Security Assertion Markup Language). This is a widely deployed sign-on protocol used in enterprises so that, for example, employees can login to many different web sites using a single set of company credentials. MeshCentral can be one of many web sites that some users may want to log into. In this section, we setup MeshCentral with JumpCloud, an easy to use sign-in provider. You can create an account on JumpCloud for free with up to 10 users allowing you to quickly get setup and test the following setup. In the next section, we look at a generic SAML configuration. Before getting started with this section, make sure your server is on the Internet and publicly available and that it has a valid TLS certificate. You can use Let\u2019s Encrypt to get a valid TLS certificate. Then, start by going to https://jumpcloud.com and creating an administrator account. Once setup, go to \u201cApplications\u201d and click on the big plug sign to create a new application. You will need to create a custom SAML application by clicking the \u201cCustom SAML App\u201d. Then, you can fill in the form with an application name and logo. For the IdP Entity ID, put \u201cjumpcloud\u201d. For the SP Entity ID put \u201cmeshcentral\u201d. For the ACS URL, put the callback URL of your server. In this case it will be \u201chttps://(yourservername)/auth-jumpcloud-callback\u201d Lastly in the attributes section, add 3 user attribute mapping. \u201cfirstname\u201d to \u201cfirstname\u201d \u201clastname\u201d to \u201clastname\u201d \u201cemail\u201d to \u201cemail\u201d The attribute mappings will allow MeshCentral to receive from JumpCloud the first and last name of the user and the email address of the use. If any of these values are changed in the future, MeshCentral will update them the next time the user logs into MeshCentral. Here is an example configuration with red arrows next to important values. Once setup, you will need to allow one or more users to use the new application. One way to do this is to just add your new application to the \u201cAll Users\u201d group. We are now almost done with JumpCloud. The last thing we need to do is download the certificate that JumpCloud will be using to sign the SAML assertions. You can get this certificate by going in the \u201cApplications\u201d tab, click on your new application and select \u201cDownload Certificate\u201d as shown here. Save the certificate as \u201cjumpcloud-saml.pem\u201d and place it in the \u201cmeshcentral-data\u201d folder. You are now ready to configure MeshCentral. Edit the config.json and make it look like this: { \"settings\" : { \"Cert\" : \"myserver.mydomain.com\" , \"Port\" : 443 , \"RedirPort\" : 80 }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"NewAccounts\" : false , \"authStrategies\" : { \"jumpcloud\" : { \"__callbackurl\" : \"https://server/auth-jumpcloud-callback\" , \"NewAccounts\" : true , \"entityid\" : \"meshcentral\" , \"idpurl\" : \"https://sso.jumpcloud.com/saml2/saml2\" , \"cert\" : \"jumpcloud-saml.pem\" } } } } } Take note that the \u201centityid\u201d, \u201cidpurl\u201d and \u201ccert\u201d are values taken from JumpCloud. The callback URL should be configured in JumpCloud as we have done in previous steps. You can see that in the example above, we have \u201cNewAccounts\u201d set to false in the default MeshCentral domain, but set to true in the JumpCloud section. This indicates that new accounts are not allowed in this domain except if it\u2019s a new user that is authenticating thru JumpCloud. You are now ready to restart the MeshCentral server. Extra modules will be needed to support SAML and so, depending on your server configuration, you may need to run MeshCentral manually once to allow the new modules to be installed from NPM. Once restarted, you should see the JumpCloud sign-in button on the login screen. Users can sign-in using the regular username and password or using JumpCloud. Generic SAML setup \u00b6 In this section, we look at configuring SAML with a generic authentication provider. The setup is exactly the same as with JumpCloud in the previous section, but we will be using a different section in the config.json to that a generic login icon is shown on the login page. A generic SAML setup will look like this: { \"settings\" : { \"Cert\" : \"myserver.mydomain.com\" , \"Port\" : 443 , \"RedirPort\" : 80 }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"NewAccounts\" : 1 , \"authStrategies\" : { \"saml\" : { \"__callbackurl\" : \"https://server/auth-saml-callback\" , \"entityid\" : \"meshcentral\" , \"idpurl\" : \"https://server/saml2\" , \"cert\" : \"saml.pem\" } } } } } The callback URL will be of the form \u201chttps://(servername)/auth-saml-callback\u201d. You should set the entityid, idpurl as given by the identity provider. Lastly, place the identity provider certificate file in the \u201cmeshcentral-data\u201d folder and indicate the name of the file in \u201ccert\u201d. Once setup, restart the server and you should see a Single Sign-on button on the login screen. Enabling SAML will require MeshCentral to install extra modules from NPM, so depending on your server configuration, you may need to run MeshCentral once manually. Improvements to MeshCentral \u00b6 In 2007, the first version of MeshCentral was built. We will refer to it as \u201cMeshCentral1\u201d. When MeshCentral1 was designed, HTML5 did not exist and web sockets where not implemented in any of the major browsers. Many design decisions were made at the time that are no longer optimal today. With the advent of the latest MeshCentral, MeshCentral1 is no longer supported and MeshCentral v2 has been significantly redesigned and mostly re-written based of previous version. Here is a list of improvements made in MeshCentral when compared with MeshCentral1: Quick Installation \u2013 By having MeshCentral published on NPM (www.npmjs.com) it\u2019s now easy to download and install MeshCentral on both Linux and Windows*. On Linux* you can use NPM directly (\u201cnpm install meshcentral\u201d) and on Windows you can use the .MSI installer. Cross-Platform Support \u2013 Contrary to MeshCentral1 that only runs on Windows*, MeshCentral can run on any environment that supports NodeJS. This includes Windows*, Linux* and OSX*. Because MeshCentral runs on Linux, it often lowers hosting costs and makes it possible to run MeshCentral in a Docker* container environment. Runs with Little Compute Resources \u2013 Typical MeshCentral1 installation requires a large disk space foot print (approx* 30G of disk space) and is compute intensive even for small deployments. MeshCentral requires little resources to host (70MB) and able to deliver reasonable performance on a 900Mhz CPU with 1GB RAM. Multi-Tenancy and Load Balancing Support \u2013 MeshCentral can handle hosting many server instances at once. Each instance or \u201cdomain\u201d has it\u2019s own administrators, users and computers to manage. The server can handle each instance using a url path \u201cserver.com/customer1\u201d or a DNS name \u201ccustomer1.server.com\u201d. Many customers can be handled by having all the DNS names point to the same server IP address. MeshCentral will take care of serving the right TLS certificate for each connection. Single Executable \u2013 MeshCentral is a single-module or single executable server. All of the components of MeshCentral1 including IIS, Swarm, AJAX, Social, Manageability Servers are all build into one single executable. This makes it super easy to setup and run, it also minimises problems and overhead caused by having many components communicate to each other. When the server is updated, all of the components are updated at once and effective. Web Application Design \u2013 MeshCentral1 has 100\u2019s of web pages and often times a click on a web page causes the browser to load a different web page and this creates more load on the server. With MeshCentral there are only two main web pages: The login page and the main web application. This design is much more responsive since the server now delegates most of the UI workload to the client\u2019s web browser. Real-Time User Interface \u2013 In MeshCentral, the user never has to hit the \u201crefresh\u201d button to update the web page. The web interface is completely real-time and updates as things change. MeshCentral uses websockets to connect to the server and get real-time events. Single Programming Language \u2013 MeshCentral1 used JavaScript on the brower, C# on the server and C for the agent. Use of 3 different programming languages means that developers wanting to implement a new use-case needs to have sufficient skills to change between these 3 languages during the coding session. Makes the code significantly more difficult to understand and maintain. Support for LAN only Mode \u2013 MeshCentral is capable of being setup as \u201cLAN only\u201d mode. In fact, this is the default mode when no static name or IP address is provided. In this mode, MeshAgents perform a multicast search on the network for the server making a static DNS/IP unnecessary. Support for TLS Offloaders \u2013 TLS offloaders are now fully supported. This means that MeshCentral can handle way more network connections and traffic significantly. Support for CIRA User/Pass Login \u2013 MeshCentral now supports both Intel AMT CIRA user/pass login and certificate login. Compared to MeshCentral1 that only supported certificate login, user/pass login is easier to setup and it can also be used for TLS offloaders and CIRA authentication. No Live State Stored in the Database \u2013 One if the big problems with MeshCentral1 is that a lot of the live states (Agent, User and AMT connections and disconnections) needed to be stored in the database. This caused a few problems, first the extra load on the database that was un-necessary, but also that servers did not have real-time state information about other servers (they had to query the database). This resulted in more load on the database and scaling issues. In MeshCentral, all live states are kept in the RAM which boosts performance significantly. Agentless Intel AMT Support \u2013 With MeshCentral1, administrators have to install the MeshAgent software on all computers, even if it was only for used for Intel AMT. MeshCentral supports a new agent-less mesh type that allows administrators to just setup the server strictly for Intel AMT only. Latest Security & Crypto algorithms \u2013 MeshCentral uses all the latest cryptographic algorithm, notably SHA384 and RSA3072 making it more resistant to future quantum computer attacks. This would be very difficult to retrofit into MeshCentralv1 since it would require change of database schema and 1000\u2019s of line of code thus making the server incompatible with the current version version, making migration difficult. Support for Email Verification and Password Recovery \u2013 MeshCentral can be configured with an SMTP server to send out e-mail confirmation messages and password recovery message. This is an important feature that was missing in MeshCentral1. MeshInterceptor Support \u2013 MeshCentral can insert HTTP and Intel AMT redirection credential into a live data stream. This is useful to allow an administrator to securely pass Intel AMT password and control over an Intel AMT computer via web browser without the additional administrator login UI. It\u2019s possible to perform migration to MeshCentral from MeshCentral1 server using a migration package. The MeshCentral Migration Tool will convert your existing user database into a format that can be imported into MeshCentral. In addition to the migration tool, MeshCentral has a special module that will update all MeshAgents from v1 to v2 so the transition should be simple. Additional Resources \u00b6 In addition to this document, there are a growing set of MeshCentral tutorial videos available on YouTube which covers all of the basic at www.meshcommander.com/meshcentral2/tutorials. The tutorial includes videos on how to perform server installation using both the Windows MSI installer and NPM methods. Conclusion \u00b6 MeshCentral is a free, open source and powerful remote management solution that is cross-platform. In this document, we have covered in detail on how to install and configure MeshCentral server to meet specific environment and use-case. MeshCentral works in many environments and situations. MeshCentral is not only simple to install but also takes minimal resources to host which makes it a very good remote management solution. As with any good software, MeshCentral will continue to be updated and evolve. License \u00b6 MeshCentral and this document are both opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0 . Annex 1: Sample Configuration File \u00b6 In this annex, we present a complete sample config.json file. You would put this file in the \u201cmeshcentral-data\u201d folder that is created when MeshCentral is first run. The config.json is completely optional and the server will run with default values with it. All key names in this file are case insensitive. { \"settings\" : { \"MongoDb\" : \"mongodb://127.0.0.1:27017/meshcentral\" , \"MongoDbCol\" : \"meshcentral\" , \"Port\" : 4430 , \"AliasPort\" : 443 , \"RedirPort\" : 800 , \"TlsOffload\" : \"127.0.0.1\" , \"MpsPort\" : 44330 , \"MpsAliasPort\" : 4433 , \"MpsTlsOffload\" : true , \"SessionTime\" : 30 , \"SessionKey\" : \"MyReallySecretPassword\" , \"AllowLoginToken\" : true , \"AllowFraming\" : true , \"WebRTC\" : true , \"ClickOnce\" : true }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"TitlePicture\" : \"title-sample.png\" , \"UserQuota\" : 1048576 , \"MeshQuota\" : 248576 , \"NewAccounts\" : true , \"Footer\" : \"<a href='https://twitter.com/mytwitter'>Twitter</a>\" , \"PasswordRequirements\" : { \"min\" : 8 , \"max\" : 128 , \"upper\" : 1 , \"lower\" : 1 , \"numeric\" : 1 , \"nonalpha\" : 1 } }, \"customer1\" : { \"Dns\" : \"customer1.myserver.com\" , \"Title\" : \"Customer1\" , \"Title2\" : \"TestServer\" , \"NewAccounts\" : 1 , \"Auth\" : \"sspi\" , \"Footer\" : \"Test\" }, \"info\" : { \"share\" : \"C:\\\\ExtraWebSite\" } }, \"letsencrypt\" : { \"email\" : \"myemail@myserver.com \" , \"names\" : \"myserver.com,customer1.myserver.com\" , \"rsaKeySize\" : 3072 , \"production\" : false }, \"peers\" : { \"serverId\" : \"server1\" , \"servers\" : { \"server1\" : { \"url\" : \"wss://192.168.2.133:443/\" }, \"server2\" : { \"url\" : \"wss://192.168.1.106:443/\" } } }, \"smtp\" : { \"host\" : \"smtp.myserver.com\" , \"port\" : 25 , \"from\" : \"myemail@myserver.com\" , \"tls\" : false } } All these values are examples only, this config.json should just be used as an example and none of the values here are real. Annex 2: Tips & Tricks \u00b6 In this annex, we present various suggestions. These are often found by users on the GitHub community and readers are encouraged to participate. The GitHub community is at: https://github.com/Ylianst/MeshCentral/issues Remote Terminal \u00b6 When doing a remote terminal session to a Linux computer, it may be interesting to run the bash shell under a different user. One would typically use the command: su -s /bin/bash myOtherUser However, because bash is not run in interactive mode, the command line prompt may be empty and history keys (up and down), tab and backspace will not work right. The correct command is: su -c '/bin/bash -i' myOtherUser This will run bash in interactive mode and work correctly. SSH and SFTP integration to the Terminal \u00b6 MeshCentral has built-in web-based integration of SSH in the \"Termina\" tab and SFTP in the \"Files\" tab.","title":"MeshCentral2 Guide"},{"location":"meshcentral/#meshcentral2-guide","text":"MeshCentral2 Guide MeshCmd Guide as .pdf as .odt","title":"Meshcentral2 Guide"},{"location":"meshcentral/#video-walkthru","text":"","title":"Video Walkthru"},{"location":"meshcentral/#abstract","text":"This user guide contains all essential information for the user to make full use of MeshCentral, a free open source web-based remote computer management software. The guide provides quick steps to setup administrative groups to remote control and manage computers in local network environments or via the Internet. Latter parts of the document will cover some advanced topics. The reader is expected to already have some of the basic understanding on computer networking, operating system and network security.","title":"Abstract"},{"location":"meshcentral/#introduction","text":"MeshCentral is a free open source web-based remote computer management software. You could setup your own management server on a local network or on the internet and remote control and manage computers that runs either Windows* or Linux* OS. To begin, a base or management server will be required. A management server could be any computing device (PC or VM) that has sufficient compute, storage and reliable network components to host an environment for MeshCentral and deliver good performance during remote management exercise. Whilst there are many configurations available for advanced users, typical server setup would only take just a few minutes to complete. At a high level, there are only four (4) main steps: Setup, Install, Connect and Control. Setup the MeshCentral server on VM or PC Log on to MeshCentral portal with a valid account, creates an administrative mesh to collect all end-points (systems to be managed) Generates an agent and installs it on a target or each end-point that immediately attempts a connection back to MeshCentral server. Controls/manages assets or end-points that are available in respective administrative mesh","title":"Introduction"},{"location":"meshcentral/#server-installation","text":"Because the MeshCentral server is written in NodeJS it can be installed on many operating systems including Windows, Linux. Please refer to the MeshCentral Installer\u2019s Guide available at https://www.meshcommander.com/meshcentral2 for information on how to install the server. The server can be installed both on a local area network for local computer management and in the cloud for management of computers over the Internet. You can also install it on small IoT devices like a Raspberry Pi all the way to big servers. It\u2019s recommended to get started with a test setup to get a feel for this server. Once installed, come back to this document for configuring and using your new server.","title":"Server Installation"},{"location":"meshcentral/#basic-usage","text":"In this section we will cover the basics of MeshCentral in your newly setup server.","title":"Basic Usage"},{"location":"meshcentral/#launch","text":"Start your web browser and access MeshCentral via IP address/URL, http://serverFQDN/. If MeshCentral is running locally, enter http://127.0.0.1/. MeshCentral will redirect the browser to HTTPS if the server was accessed with HTTP. Once on HTTPS you will likely see this message: This is because by default MeshCentral is using a self-signed certificate that is not known to the browser as a \u201ctrusted\u201d or \u201ctrustworthy\u201d certificate. To prevent this warning from recurring, the following chapter will provide useful steps that can be considered. To proceed on Firefox browser, Click on \u201cAdvanced\u201d, \u201cAdd Exception\u201d and \u201cConfirm Security Exception\u201d To proceed on Chrome Browser, Click on \u201cAdvanced\u201d, \u201cProceed to http://serverIP (unsafe)\u201d To proceed on Internet Explorer 11, Click \u201cContinue to this website (not recommended)\u201d Note: You can also get to a device by specifying the device name in the URL by adding ?viewmode=10&gotodevicename=MyComputer to the URL of the MeshCentral web page. The new gotodevicename will find a device with the specified name and navigate to that device\u2019s page. This is perfect for integrating MeshCentral with other solutions but be aware that a computer name is not a unique identifier and so, &gotonode= is always the preferred way to access a device. This feature also works on the mobile web site.","title":"Launch"},{"location":"meshcentral/#create-account","text":"Create an account by clicking \u201cCreate One\u201d and click \u201cCreate Account\u201d once the text fields had been populated correctly.","title":"Create Account"},{"location":"meshcentral/#new-device-group","text":"Once logged in, create a new device group. This is a group of computers that we want to manage. To proceed, Click on \u201cClick here to create a new group of devices\u201d, Key in a suitable \u201cName\u201d, .e.g. \u201cSampleGroup\u201d Leave \u201cType\u201d to default \u201cManage using a software agent\u201d and click \u2018OK\u201d. Note There are two types of groups: Software Agent Group: Commonly used to manage computers. Administrator must install a \u201cremote management agent\u201d on the remote computers. Intel\u00ae AMT Agent-less Group: Exclusive for remote computers that has Intel\u00ae AMT activated and needs to be managed independent of a \u201cremote management agent\u201d.","title":"New device group"},{"location":"meshcentral/#add-device","text":"To add devices into new mesh Click \u201cAdd Agent\u201d, Select the right Operating Systems (Windows* OS) and download the Mesh Agent executable. Copy the Mesh Agent file into remote computers with Windows* OS Run Mesh Agent and Click \u201cinstall\u201d Note Mesh Agent is available for Windows* and Linux*. For Windows*, the mesh agent doesn\u2019t contain any sensitive data and can copied and reused on many Windows* computers. For Linux*, instead of an executable, an installation script is provided to add remote computers. The script checks the type of computer and installs the proper agent automatically.","title":"Add device"},{"location":"meshcentral/#after-agent-install","text":"Once the agents are installed, it will take up to a minute before the computer shows up on the user\u2019s account automatically. Click on each computer to access it and user can rename the each computer with a unique name and icons.","title":"After agent install"},{"location":"meshcentral/#manage-computer","text":"Click on any computer and go into the \u201cDesktop\u201d and \u201cFiles\u201d tabs to remotely manage the computer or perform file transfer. For advance users with console/command line interface experience, go into \u201cTerminal\u201d to perform scripting or quick tasks with CLI tools.","title":"Manage Computer"},{"location":"meshcentral/#desktop-control","text":"Depending on how the agent is connected to the server, there are multiple methods to remote control. Mesh Agent, RDP, and AMT For RDP connections, if you have previously saved the credentials that is usable by all users on the system. If you want to remove those saved credentials that's under the General Tab > Credentials . Click pen to clear them.","title":"Desktop Control"},{"location":"meshcentral/#server-certificate","text":"As seen in the previous chapter, MeshCentral is setup with a self-signed certificate by default and the web browser will issue a warning concerning the validity of the certificate. Users have few ways to handle this certificate warning: Ignore the warning and proceed with an exception in a recurring fashion. However, traffic from the server to the web browser remains encrypted. User must check the validity of the certificate presented by the website and compare with \u201cwebserver-cert-public.crt\u201d file in the \u201cmeshcentral-data\u201d folder of the server. Add webserver\u2019s root certificate into web browser\u2019s trust list. Click on \u201cRoot Certificate\u201d link at the bottom right of login page to download the root certificate of the web server and then add/import this as a trusted certificate into web browser. Some web browser may require a restart before the certificate installation takes effect. If you own a domain name that points to your MeshCentral server, you can get a free trusted certificate using Let\u2019s Encrypt (https://letsencrypt.org/). See the section on Let\u2019s Encrypt in this document for more information on this option. MeshCentral has built-in support for Let\u2019 Encrypt. Important Before adding/importing the certificate, user must check the validity of the certificate presented by the website and compare with \u201croot-cert-public.crt\u201d file in the \u201cmeshcentral-data\u201d folder of the server. For large scale deployments or setup, a legitimate trusted certificate is highly recommended for your web server. This way, any web browser that navigates to this web server will be able to readily verify its authenticity. If a legitimate trusted certificate is available, replace \u201cwebserver-cert-public.crt\u201d and \u201cwebserver-cert-private.key\u201d with your certificate. These files are located in \u201cmeshcentral-data\u201d folder of the server. If intermediate certificates are needed, add the files \u201cwebserver-cert-chain1.crt\u201d, \u201cwebserver-cert-chain2.crt\u201d, \u201cwebserver-cert-chain3.crt\u201d respectively with the intermediate certificates. Note : If you are using TLS offloading, see the section on \u201cTLS Offloading\u201d cover in the latter parts of this document.","title":"Server Certificate"},{"location":"meshcentral/#files-and-folder-structure","text":"It\u2019s important to know the basic file and folder structure from which MeshCentral was installed as shown below Right after running the \u201cnpm install meshcentral\u201d command, the node_module folder will be created which contains meshcentral and all of its dependent modules. When the server executes for the first time, both meshcentral-data and meshcentral-files folders will be created. Important User must periodically backup both meshcentral-data and meshcentral-files which contains all of server\u2019s data. The \u201cmeshcentral-data\u201d folder will contain: meshcentral.db file : The server\u2019s database file which contains all of the user and computer information. This includes account information and other sensitive information. Five .key and .crt files : These are the server\u2019s certificates and private keys. They are used to securely identify the server. The .key files must not be obtained by anyone else since they could be used to impersonate the server. config.json file : This is the server\u2019s configuration file. It first starts with a sample configuration that you can change. In a following section, we will discuss how to edit this file to customize the server. The \u201cmeshcentral-files\u201d folder contains user files that have been uploaded to the server. This folder can be quite large, especially if no user space quota is set in the config.json file. Users can upload a significant amount of files on the server. Important Back-up the \u201cmeshcentral-data\u201d folder since this is the folder needed to reconstruct the server if something goes wrong. Without it, user will to start over. Recommended to apply suitable encryption on both folders given that they contain sensitive data.","title":"Files and Folder Structure"},{"location":"meshcentral/#server-configuration-file","text":"In the \u201cmeshcentral-data\u201d folder, there is a file called config.json that contains the main configuration of the server. A sample configuration file could look like this: { \"settings\": { \"cert\": \"mesh.myserver.com\", \"port\": 8080, \"redirport\": 81 }, \"domains\": { \"\": { \"title\": \"MyServer\", \"title2\": \"Servername\", \"userQuota\": 1048576, \"meshQuota\": 248576, \"newAccounts\" : 1 }, \"Customer1\": { \"title\": \"Customer1\", \"title2\": \"Extra String\", \"newAccounts\" : 0 } }, \"peers\": { \"serverId\" : \"Server1\", \"servers\": { \"Server1\": { \"url\": \"wss://192.168.1.100:443/\" }, \"Server2\": { \"url\": \"wss://192.168.1.101:443/\" } } } } First, we will look at each of the top levels of the configuration file. The tops levels are \u201csettings\u201d, \u201cdomains\u201d, \u201cpeers\u201d, and \u201csmtp\u201d as shown in the table below.","title":"Server Configuration File"},{"location":"meshcentral/#settings","text":"As indicated before, the settings section of the config.json is equivalent to passing arguments to the server at runtime. Below is a list of settings that are available for the user. Settings Option Description Cert Sets the DNS name of the server. If this name is not set, the server will run in \"LAN mode\". When set, the server\"s web certificate will use this name and the server will instruct agents and browsers to connect to that DNS name. You must set a server DNS name to run in \"WAN mode\". MeshCentral will not configure your DNS server. The DNS name must be configured separately. Port This sets the main web port used by the MeshCentral server and it\"s the same port that users and mesh agents will connect to. The default port is 443, but if the port is busy, the next available higher port is used (.e.g. 444) AliasPort Sets the main port that will be used by the server externally. By default is the same as \"Port\" above, but can be set to be different when next. See \"Server port aliasing\" section for more details. RedirPort This is the port for redirecting traffic in the web server. When the server is configured with HTTPS, users that uses HTTP will be redirected to HTTPS. Port 80 is the default port. So, redirection will happen from port 80 to port 443. MpsPort Port for Intel\" AMT Management Presence Server to receive Intel\" AMT CIRA (Client Initiated Remote Access) connections. The default is port 4433. This port is disabled in LAN mode. If user don\"t plan on using Intel\" AMT for management, this port can be left as-is. TLSOffload By default this option is set to \"false\". If set to \"true\", server will run both web port and the Intel AMT MPS port without TLS with the assumption that a TLS offloading is taking care of this task. For further details, see the \"TLS Offloading\" section. This option can also be set to the IP address of the reverse-proxy in order to indicate to MeshCental to only trust HTTP X-Forwarded headers coming from this IP address. See the \"Reverse-Proxy Setup\" section for an example. SelfUpdate When set to \"true\" the server will check for a new version and attempt to self-update automatically a bit after midnight local time every day. For this to work, the server needs to run with sufficient permissions to overwrite its own files. If you run the server with more secure, restricted privileges, this option should not be used. If set to a specific version such as \"0.2.7-g\" when the server will immediately update to the specified version on startup if it\"s not already at this version. SessionKey This is the encryption key used to secure the user\"s login session. It will encrypt the browser cookie. By default, this value is randomly generated each time the server starts. If many servers are used with a load balancer, all servers should use the same session key. In addition, one can set this key so that when the server restarts, users do not need to re-login to the server. Minify Default value is 0, when set to 1 the server will serve \"minified\" web pages, that is, web pages that have all comments, white spaces and other unused characters removed. This reduces the data size of the web pages by about half and reduced the number requests made by the browser. The source code of the web page will not be easily readable, adding \"&nominify=1\" at the end of the URL will override this option. User Specify a username that browsers will be automatically logged in as. Useful to skip the login page and password prompts. Used heavily during development of MeshCentral. NoUsers By default this option is \"false\" and if set to \"true\", server will only accept users from localhost (127.0.0.1) and will not have a login page. Instead, a single user is always logged in. This mode is useful if user opts to setup MeshCentral as a local tool instead of as a multi-user server MpsCert Specifies the official name of the Intel AMT MPS server. If not specified, this is the same as the official server name specified by \"cert\". This option is generally used with MPS aliasing, see the \"Server port aliasing\" section for more information. MpsAliasPort Specify an alias port for the MPS server. See the section on \"Server port aliasing\" for use of this option. ExactPorts If this option is set to \"true\", only the exact port will be used. By default, if a port is in use, the server will try to bind the next available higher port. This is true for the \"port\", \"redirport\" and \"mpsport\" settings. Lanonly Server\"s default mode if not set with \"--cert\" option. If this option is set to \"true\", Intel\" AMT MPS will be disabled, server name and fixed IP option will be hidden. Mesh agents will search for the server using multicast on the network. Wanonly A recommended option when running MeshCentral in the cloud. If set to \"true\", server will run as a cloud service and assumes LAN features are disabled. For this option to work, the server must have a fixed IP or DNS record using the \"--cert\"\" option. In this mode, LAN discovery features are disabled. AllowFraming By default is set to \"false\". If set to \"true\", web pages will be served in a way that allows them to be placed within an iframe of another web page. This is useful when you wish to add MeshCentral features into another website. AllowLoginToken By default is set to \"false\". If set to \"true\", the server allows login tokens to be used in the URL as a replacement for user login. This is useful along with \"allowFraming\" option to embed MeshCentral features into another website. MongoDB Used to specify the MongoDB connection string. If not specified, MeshCentral will use the NeDB database with the file meshcentral.db in the meshcentral-data folder. To setup MongoDB, please refer to the Database section of this document. MongoDBCol Used to specify the MongoDB collection name in the database. By default this value is \"meshcentral\". See Database section for more details on MongoDB setup. DbEncryptKey Specifies a password used to encrypt the database when NeDB is in use. If wanting to encrypt an existing database, use the \"dbexport\" and \"dbimport\" to save and reload the database with the encryption password set. WebRTC Set to \"true\" or \"false\" depending if you want to allow the server to setup WebRTC communication. If WebRTC is setup, management traffic will flow directly between the browser and mesh agent, bypassing the server completely. The default is false now, but will be switched to true when WebRTC is ready for production. ClickOnce Set to \"true\" or \"false\" to allow or disallow browser ClickOnce features. When enabled, browsers running on Windows will be shown extra options to allow RDP and other sessions thru the MeshCentral server. This requires ClickOnce browser support that is built-in to IE and available as add-in to Chrome and Firefox. Default is true. Important Changes in config.json will NOT take effect until server is restarted. Note : We recommend the user to use a non-production server to experiment the setting options above.","title":"Settings"},{"location":"meshcentral/#domains","text":"In the domains section, you can set options for the default domain (\"\") in addition to creating new domains to establish a multi-tenancy server. For standard configuration, the root domain and other domains will be accessible like this: https://servername:8080/ <- default domain https://servername:8080/customer1 <- customer1 domain https://servername:8080/customer2 <- customer2 domain When a user setup many domains, the server considers each domain separately and each domain has separate user accounts, administrators, etc. If a domain has no users, the first created account will be administrator for that domain. Each domain has sub-settings as follows: Sub Settings Description Title & Title2 This are the strings that will be displayed at the banner of the website. By default title is set to \u201cMeshCentral\u201d and title2 is set to a version number UserQuota This is the maximum amount of data in kilobytes that can be placed in the \u201cMy Files\u201d tab for a user account. MeshQuota This is the maximum amount of data in kilobytes that can be placed in the \u201cMy Files\u201d tab for a given mesh NewAccounts If set to zero (0) UserAllowedIP Allows user to set a list of allowed IP addresses. See section on server IP filtering. Auth This mode is often used in corporate environments. When server is running on Windows and this value is set to \u201csspi\u201d, domain control authentication to the website is performed. In this mode, no login screen is displayed and browser will authenticate using the user\u2019s domain credentials. Dns The DNS record for this domain. If specified, the domain is accessed using a DNS record like \u201ccustomer1.servername.com\u201d instead of \u201cservername/customer1\u201d. This feature requires the DNS server to be configured to point this server with a valid DNS record. CertUrl Load the TLS certificate for this domain from this https url. For example \u201chttps://127.0.0.1:123\u201d. This option is useful when used along with the \u201cTlsOffload\u201d option. When MeshCentral is not doing any TLS but has a reverse-proxy or TLS offload device doing this work in front of the server, you can use this to have MeshCentral load the certificate from the server in front of MeshCentral. This is needed because when agents connect, they need to be told that the certificate they saw upon connecting is the correct one. Using this, MeshCentral will know what certificate the agents are expected to see. PasswordRequirements Used to specify the minimum password requirements for user authentication to this domain. By default, no password requirements are enforced but the user will see a password strength indicator that is not backed by any verifiable data. The value must be set to an object, for example: { \"\"min\"\": 8, \"\"max\"\": 128, \"\"upper\"\": 1, \"\"lower\"\": 1, \"\"numeric\"\": 1, \"\"nonalpha\"\": 1 } This indicated that passwords must be at least 8 characters long and have at least one upper case, one lower case, one numeric and one non-alphanumeric character. You can also set the maximum length of the password, however MeshCentral has already a limit of 256 characters. Specifying anything above this will have no effect. Note that password requirements for Intel\u00ae AMT are defined by Intel and so, Intel\u00ae AMT passwords will always be verified using a separate set of requirements. Note : When the DNS value is set for a domain, user can\u2019t access the domain using \u201cservername/customer1\u201d instead it must be accessed with the valid DNS record and the DNS server should be setup to have two or more DNS records pointing to the same IP address. In this mode, the server will serve a different TLS certificate depending on what DNS record is used to access the server. As shown in the example above, we have two names that point to the same IP address. Since the configuration specifies the \u201cdns\u201d value, the second domain is only shown when the right name is used. We use \u201cmeshcentral\u201d and \u201cdevbox\u201d for DNS names, but in practice the user will use fully qualified domain names (FQDN) like \u201cmeshcentral.com\u201d or \u201cdevbox.meshcentral.com\u201d.","title":"Domains"},{"location":"meshcentral/#server-peering","text":"MeshCentral supports server peering. User could setup up many servers to share the task of handling incoming connections from managed clients and consoles. For server peering to function, all servers must have access to the same database, use the same certificates, the same configuration (with the exception of the server name) and servers must be able to communicate with each other behind a load balancer. Hence, the user is expected to have good understanding on networking, server administration and applications to accomplish this setup. This document will not get into the details of setting up a load-balancer. Recommended Before setting up MeshCentral peering, database migration from NeDB database to MongoDB with replication/sharding option enabled is highly recommend. See: Setting up MeshCentral with MongoDB (section 8.4) The setup flow above guides the user to pull together server peering setup with Meshcentral. (2) Shared storage is compulsory to host user files and it must be accessible from all of the servers. If the server is expected for critical work, replicated shared storage should be considered. When Meshcentral is ready for peering setup (5), replicate the \u201cmeshcentral-data\u201d directory on each server and configure the \u201cpeers\u201d section of the config.json file as shown below. { \"peers\": { \"serverId\" : \"Server1\", \"servers\": { \"Server1\": { \"url\": \"wss://192.168.1.100:443/\" }, \"Server2\": { \"url\": \"wss://192.168.1.101:443/\" } } } } The configuration above assumes that server1 has an IP address of \u2018192.168.1.100\u2019 and server2 has \u2018192.168.1.101\u2019 respectively. The \"serverId\" value is a short and unique identifier for each server and it is optional. If it's not specified, the computer hostname is used instead. The \u201cservers\u201d section of the configuration file should have the identifier of the server followed by each websocket URL and port (generally 443) of the peer servers. If the servers are running with \u201c--tlsoffload\u201d, then use \u201cws://\u201d for the URL instead of \u201cwss://\u201d. When the MongoDB is setup for the first time, a unique identifier is generated and written into the DB. To prevent situations where two servers with different database from peering together, during peering process, each server will validate among each other if they have the same unique DB identifier. Peering connection will only succeed if this condition is met. Once peered, all of the servers should act like one single host, no matter which server the user(s) are connected to.","title":"Server Peering"},{"location":"meshcentral/#database","text":"A critical component of MeshCentral is the database. The database stores all of the user account information, groups and node data, historical power and event, etc. By default MeshCentral uses NeDB (https://github.com/louischatriot/nedb) that is written entirely in NodeJS and is setup automatically when MeshCentral is installed with the npm tool. The file \u201cmeshcentral.db\u201d will be created in the \u201cmeshcentral-data\u201d folder when MeshCentral is first launched. This database works well for small deployments scenarios. Besides NeDB, MeshCentral fully supports MongoDB for larger deployments or deployments that require robust reliability or load-balancing. In this section we will see look at how to export and import the database file with a JSON file and how to configure MongoDB.","title":"Database"},{"location":"meshcentral/#database-export","text":"User could use a practical approach to migrate from NeDB to MongoDB, by exporting the entire content of the existing NeDB into JSON file, setup the new MongoDB and import that JSON file to create the schemas in MongoDB. To export the database, stop the MeshCentral server and run the server again with \u201c--dbexport\u201d and a JSON file called \u201cmeshcentral.db.json\u201d will be created in the \u201cmeshcentral-data\u201d folder as shown below. Alternatively, user can also specify the full export path for the JSON file as shown below.","title":"Database Export"},{"location":"meshcentral/#database-import","text":"Importing the MeshCentral database is useful when transitioning between database softwares (NeDB to/from MongoDB) or when importing the database from MeshCentral1 via migration tool. Important Importing a JSON file will overwrite the entire content of the database. A starting empty database is recommended. When you are ready to import a JSON file into the database, run meshcentral with \u201c--dbimport\" as shown below. If path is not specified, the application will default to use \u201cmeshcentral.db.json\u201d that is in \u201cmeshcentral-data\u201d folder. Alternatively, user can specify the full path of the import JSON as shown below.","title":"Database Import"},{"location":"meshcentral/#viewing-the-database","text":"For debugging purposes, Meshcentral allow users to have quick preview of certain frequently accessed data in the database with the following options: Option Description --showusers List of all users in the database. --showmeshes List of all meshes in the database. --shownodes List of all nodes in the database --showevents List all events in the database --showpower List all power events in the database. --showall List all records in the database. For example, you can show the list of users with the \u201c--showusers\"","title":"Viewing the Database"},{"location":"meshcentral/#mongodb-setup","text":"MongoDB is useful when setting up MeshCentral for two or more peer servers given that all peer servers much have access to the same database. NeDB and MongoDB have similar access interfaces hence the DB migration from one to the other is straight forward. Installing MongoDB depends on its host OS so do check for available download options at mongodb.com. In this guide, we will focus on the 64-bit windows with SSL support installer. After completing the installation step, Stop any instance of Meshcentral that is running locally or in any machine Start a terminal or Windows Command prompt (CMD), Create a folder \u201cc:\\data\\db\u201d Go to the MongoDB bin folder and run \u201cmongod --bind 127.0.0.1\u201d. This execute the database engine and store the database data in the default location \u201c/data/db\u201d path and bind a loopback on the local port \u201c127.0.0.1\u201d. Note : Refer to MongoDB documentation to allow database to run in the background or experiment with alternate configurations. Note : Upon successful execution, MongoDB will wait for connections on its default port 27017. Now run MeshCentral with the command below, it will tell Meshcentral to connect to MongoDB and use \u201cmeshcentral\u201d DB. MongoDB will create this DB if it does not exist. node meshcentral --mongodb mongodb://127.0.0.1:27017/meshcentral Alternatively, to transition an existing meshcentral DB from NeDB and to MongoDB, just run the command below: node meshcentral --dbexport node meshcentral --mongodb mongodb://127.0.0.1:27017/meshcentral --dbimport node meshcentral --mongodb mongodb://127.0.0.1:27017/meshcentral We recommend the user to include MongoDB configuration into the server\u2019s configuration \u201cconfig.json\u201d to avoid specifying the \u201c--mongodb\" each time MeshCentral is executed as shown below { \"settings\": { \"mongodb\": \"mongodb://127.0.0.1:27017/meshcentral\", \"mongodbcol\": \"meshcentral\" } } Note : By default, MeshCentral will create a single collections called \u201cmeshcentral\u201d in the specified database. If user want to specify a different collection name, use \u201c--mongodbcol\" or \u201cmongodbcol\u201d for settings like shown above. If you are using MongoDB with authentication, you can change the URL a little to add the username and password, for example: mongodb://username:password@127.0.0.1:27017/meshcentral You can also provide extra connection parameters like this: mongodb://username:password@127.0.0.1:27017/meshcentral?authMechanism=MONGODB-CR&authSource=db","title":"MongoDB Setup"},{"location":"meshcentral/#running-state-less","text":"By default, MeshCentral will read its configuration information from the \u201cmeshcentral-data\u201d folder. The most important file in that folder being the \u201cconfig.json\u201d file, but the folder also contains certificates, branding images, terms of service and more. After the configuration is read, MeshCentral will connect to its database and continue to start the server. For most user\u2019s this is a perfectly acceptable way to setup the server. However, in some cases, it\u2019s advantageous to setup the server \u201cstate-less\u201d. That is, there is no local configuration files at all and everything is in the database. Two examples of this would be when running MeshCentral is a Docker container where we don\u2019t want the container to have any state or for compliance with security specifications where the database is \u201cencrypted at rest\u201d. In this cases, we will load the configuration files into the database and MeshCentral will only be told how to connect to the database. When loading configuration information into the database, MeshCentral requires that a configuration file password be used to encrypt the configuration files in the database. This provides an additional layer of security on top of any authentication and security already provided by the database, if such security has been setup. To make this happen, we will be using the following command line options from MeshCentral: Command Description --configkey (key) Specifies the encryption password that will be used to read or write the configuration files to the database. --dblistconfigfiles List the names and size of all configuration files in the database. --dbshowconfigfile (filename) Show the content of a specified filename from the database. --configkey is required. --dbdeleteconfigfiles Delete all configuration files from the database. --dbpushconfigfiles (*) or (folder path) Push a set of configuration files into the database, removing any existing files in the process. When * is specified, the \u201cmeshcentral-data\u201d folder up pushed into the database. --configkey is required. --dbpullconfigfiles (folder path) Get all of the configuration files from the database and place them in the specified folder. Files in the target folder may be overwritten. --configkey is required. --loadconfigfromdb (key) Runs MeshCentral server using the configuration files found in the database. The configkey may be specified with this command or --configkey can be used. Once we have MeshCentral running as expected using the \u201cmeshcentral-data\u201d folder, we can simply push that configuration into the database and run using the database alone like this: node ./node_modules/meshcentral --dbpushconfigfiles * --configkey mypassword node ./node_modules/meshcentral --loadconfigfromdb mypassword --mongodb \"mongodb://127.0.0.1:27017/meshcentral\" This first line will load many of the \u201cmeshcentral-data\u201d files into the database. At this point, we can back up the \u201cmeshcentral-data\u201d folder and remove it. Then run the second line to start the server. Here we use MongoDB, but if one uses NeDB, the \u201cmeshcentral.db\u201d file in the \u201cmeshcentral-data\u201d folder will still be needed. Note that MeshCentral does not currently support placing a Let\u2019s Encrypt certificate in the database. Generally, one would use a reverse proxy with Let\u2019s Encrypt support and TLS offload in the reverse proxy and then run MeshCentral in state-less mode in a Docket container.","title":"Running State-less"},{"location":"meshcentral/#commandline-options","text":"In general, doing --option value is the same as adding \"option\": value in the settings section of the config.json. Here are the most common options found by running meshcentral --help Run as a background service --install/uninstall Install MeshCentral as a background service. --start/stop/restart Control MeshCentral background service. Run standalone, console application --user [username] Always login as [username] if account exists. --port [number] Web server port number. --redirport [number] Creates an additional HTTP server to redirect users to the HTTPS server. --exactports Server must run with correct ports or exit. --noagentupdate Server will not update mesh agent native binaries. --nedbtodb Transfer all NeDB records into current database. --listuserids Show a list of a user identifiers in the database. --cert [name], (country), (org) Create a web server certificate with [name] server name. country and organization can optionally be set. Server recovery commands, use only when MeshCentral is offline. --createaccount [userid] Create a new user account. --resetaccount [userid] Unlock an account, disable 2FA and set a new account password. --adminaccount [userid] Promote account to site administrator.","title":"Commandline Options"},{"location":"meshcentral/#tls-offloading","text":"A good way for MeshCentral to handle a high traffic is to setup a TLS offload device at front of the server that takes care of doing all the TLS negotiation and encryption so that the server could offload this. There are many vendors who offer TLS or SSL offload as a software module (Nginx* or Apache*) so please contact your network administrator for the best solution that suits your setup. As shown in the picture below, TLS traffic will come from the Internet and security will be handled by a device ahead of the server and MeshCentral only has to deal with TCP connections. To make this work, it is important the server is setup with \u201c--tlsoffload\u201d. This indicates the server that TLS is already being taken care of and MeshCentral does not have to deal with it. MeshCentral will continue to listen to port 80, 443 and 4433. However, incoming port 443 (main web port) and 4433 (Intel\u00ae AMT MPS port) will not have TLS but MeshCentral will still put many HTTPS flags in its responses on port 443. By default, if a user accesses http://127.0.0.1:443 without TLS offloader setting, the browser is expected to display warnings. To make this work, TLS offloader device\u2019s ports and functions should be configured correctly like below Port Function Description 80 Directly forwards port 80 to MeshCentral port 80 443 Handle TLS using a web certificate and forward to MeshCentral port 443 4433 Handle TLS using MPS certificate and forward to MeshCentral port 4433 If possible, port 443 should be configured with a legitimate trusted certificate and the public part of the certificate named as \u201cwebserver-cert-public.crt\u201d must be placed inside of \u201cmeshcentral-data\u201d folder of the server. When the server is executed in tlsoffload mode, only the public part of the web certificate is used by the server. For Intel\u00ae AMT MPS port 4433, the certificate files \u201cmpsserver-cert-public.crt\u201d and \u201cmpsserver-cert-public.key\u201d must be copied from the \u201cmeshcentral-data\u201d folder and loaded into the TLS offload module. Note: Please consult the TLS offloader user manual from the respective vendor to configure TLS offloading feature correctly.","title":"TLS Offloading"},{"location":"meshcentral/#lets-encrypt-support","text":"MeshCentral makes use of HTTPS to authenticate and encrypt management traffic over the network. By default, a self-signed certificate is used for the MeshCentral HTTPS server. That certificate is not trusted by browsers and so, you get a warning message when visiting the web site. You can solve this but obtaining a free trusted certificate from Let\u2019s Encrypt (https://letsencrypt.org/). There are some limitations and so, it\u2019s best to get familiar with this service before starting. You will also need a valid domain name that you own and that points to your MeshCentral server. Before moving forward with this section, make sure your MeshCentral server is working correctly, has a domain name pointing to it and that the HTTP redirection server on port 80 is enabled and working. MeshCentral\u2019s HTTP port 80 server will be used in the process to prove to Let\u2019s Encrypt that we have control over the domain. At any point, you may try to use https://letsdebug.net/ to see if your domain is setup correctly and/or debug any issues. When ready, add the \u201cletsencrypt\u201d section to the config.json file like this: { \"settings\" : { \"RedirPort\" : 80 , }, \"letsencrypt\" : { \"email\" : \"myemail@myserver.com\" , \"names\" : \"domain1.com,domain2.com\" , \"rsaKeySize\" : 3072 , \"production\" : false }, } The only mandatory field is the email address, please enter a valid one. The names section is a list of domain names the requested certificate will be valid for. This must be a list of DNS names that are already pointing to your server. It\u2019s important to understand you are not requesting these DNS names, rather, Let\u2019s Encrypt will makes requests to prove control over all of these domain name before issuing the certificate. All the domain names you enter must point to the server and HTTP port 80 must be reachable over the internet. If you don\u2019t specify names, the default MeshCentral certificate name is used, that is the configured \u201c--cert [name]\u201d. The RSA key size can only be 2048 or 3072, with the default being 3072. This is the number of bit used for the RSA key in the certificate. Bigger is more secure, but takes more time to compute. Lastly the production key, by default this is false. When set to false, MeshCentral will query the Let\u2019s Encrypt staging server for a certificate. It\u2019s highly recommended to try this first and make sure everything works before getting a real certificate. Keep production to false, run thru the process at least once and make sure everything works. You will get a new certificate installed on the HTTPS server signed by a staging Let\u2019s Encrypt certificate authority. The Let\u2019s Encrypt certificates and files will be created in the \u201cmeshcentral-data\u201d folder. Make sure to keep regular backups of the \u201cmeshcentral-data\u201d folder and all sub-folders. Once you placed the \u201cletsencrypt\u201d section in config.json, restart the server. The request to the Let\u2019s Encrypt server may take a few minutes to a few hours. It\u2019s best to have your DNS server name pointing to your server for over a day before doing this. Once the new certificate is received, the server will automatically restart and browsing to HTTPS on your server will show the new certificate. Here is what it looks like on FireFox: If you successfully setup a Let\u2019s Encrypt certificate using the Let\u2019s Encrypt staging server (\u201cproduction\u201d: false) and everything looks good, stop the server, remove the \u201cletsencrypt\u201d folder in \u201cmeshcentral-data\u201d, change production to \u201ctrue\u201d and start the server again. You should get a real certificate in a few minutes to a few hours. MeshCentral will automatically renew the certificate a few days before it expires. The MeshCentral self-signed certificate will still be present in the \u201cmeshcentral-data\u201d folder, this is normal and there is no need to manually copy the Let\u2019s Encrypt certificate to the \u201cmeshcentral-data\u201d folder. If something goes wrong with the Let\u2019s Encrypt certificate, the server will fall back to using the self-signed one. Note Please be patient with Let\u2019s Encrypt certificate requests and make sure you correctly get a staging certificate before setting production to true. If Let\u2019s Encrypt works for you, please consider donating to them as they provide a critical service to the Internet community.","title":"Let\u2019s Encrypt support"},{"location":"meshcentral/#server-ip-filtering","text":"For improved security, it\u2019s good to limit access to MeshCentral with IP address. For example, we want to allow mesh agents and Intel AMT computers to connect from anywhere, but whitelist IP address for users that we allow to access MeshCentral. MeshCentral provides IP filtering option in the config.json file for each domain. For an example, we can set IP address whitelist for the default domain like as shown below. { \"domains\": { \"\": { \"userallowedip\" : \"1.2.3.4,1.2.3.5\", } } } IP addresses are separated by a comma. As a result, only users coming these IP addresses will be able to see the server\u2019s login page as illustrated below. Other IP addresses will be blocked effectively. Note : When IP address whitelist is effective, Mesh Agent connection from any IP address will be not affected.","title":"Server IP filtering"},{"location":"meshcentral/#email-setup","text":"We highly recommend the use of an email server (SMTP) because we could allow MeshCentral to verify user account\u2019s email address by sending a confirmation request to the user to complete the account registration and for password recovery, should a user forget account password as illustrated below A verification email is sent when a new account is created or if the user requests it in the \u201cMy Account\u201d tab. The password recovery flow when \u201cReset Account\u201d is triggered at the login page. Both account verification and password recovery are triggered automatically once SMTP mail server configuration is included into the config.json file. Update the config.json with \u201csmtp\u201d section as shown below and restart the server. { \"smtp\" : { \"host\" : \"smtp.server.com\" , \"port\" : 25 , \"from\" : \"myaddress@server.com\" , \"user\" : \"myaddress@server.com\" , \uf0df Op t io nal \"pass\" : \"mypassword\" , \uf0df Op t io nal \"tls\" : false \uf0df Op t io nal , de fault false } } Please map the host, port values to connect to the right host that provides this SMTP service. For \u201cfrom\u201d value, administrators may put something like donotreply@server.com, but often times it needs to be a valid address since SMTP server will not send out messages with an invalid reply address. Some SMTP servers will require a valid username and password to login to the mail server. This is to prevent unauthorized e-mail correspondence. TLS option can be set to \u2018true\u2019 if the SMTP server requires TLS. One option is to configure MeshCentral work with Google Gmail* by setting \u201chost\u201d with smtp.gmail.com, and \u201cport\u201d with 587. In the config.json file, use user\u2019s Gmail* address for both \u201cfrom\u201d and \u201cuser\u201d and Gmail* password in the \u201cpass\u201d value. You will also need to enable \u201cLess secure app access\u201d in for this Google account. It\u2019s in the account settings, security section: If a Google account is setup with 2-factor authentication, the option to allow less secure applications not be available. Because the Google account password is in the MeshCentral config.json file and that strong authentication can\u2019t be used, it\u2019s preferable to use a dedicated Google account for MeshCentral email. Regardless of what SMTP account is used, MeshCentral will perform a test connection to make sure the server if working as expected when starting. Hence, the user will be notified if Meshcentral and SMTP server has been configured correctly as shown below.","title":"Email Setup"},{"location":"meshcentral/#embedding-meshcentral","text":"One interesting way to use MeshCentral is to embed its features into another web site. In other words, certain feature of MeshCentral can be selectively embedded into another website such as Remote Desktop or File Transfer. This allows another site to take care of the user accounts and business processes while MeshCentral takes care of remote management. In the example below, a user logs into an existing web site and received a page with MeshCentral remote desktop embedded into it. To make this work, a following key alignment is required: 1. When a user requests the business website, the business web server must return the user a web page containing an iframe with a URL that points to the MeshCentral server. 2. The URL must contain both a login token and embedding options. The login token tells MeshCentral under what MeshCentral account this request should be made. 3. The login token replaces the login screen of MeshCentral. Then, the embedding options can be used to specify no page title, header and footer to be displayed. This way, the page given by MeshCentral will fit nicely into the iframe. In this section we will review both the login token and embedding options mentioned above.","title":"Embedding MeshCentral"},{"location":"meshcentral/#login-token","text":"With MeshCentral, it\u2019s possible to login to the main web page without even seeing the login screen. Of course, you can do this by specifying \u201c--nousers\" or \u201c--user admin\u201d when you run the server, but these approach are not secure as it removes user authentication for those accessing the server. With login tokens feature, a token can be generated to be used for a short time to login and skip the login page. This is perfect for embedding MeshCentral usages into other web site and probably for other applications. To enable this feature, configure config.json file to allow login tokens. { \"settings\" : { \"allowLoginToken\" : true , \"allowFraming\" : true } } Set both allowLoginToken and allowFraming to \u2018true\u2019 to use login tokens along with framing MeshCentral within another web page. Next, create a token. Execute MeshCentral with the \u201c--logintoken [userid]\u201d switch and userid value with the example below: The \u201cuserid\u201d is actually a combination of three values - user, domain, and username in a single string \u201cuser/domain/username\u201d. The example above is using a default domain which is empty hence, the userid will be just \u201cuser//admin\u201d to request for login token. Domains are only used if the server in multi-tenancy mode as discussed in previous chapters. The resulting hashed base64 encoded blob can be used as a login token for 1 hour. Simply add the \u201c?login=\u201d followed by the token value generated to the URL of the webserver. For an e.g. https://localhost/?login=23tY7@wNbPoPLDeXVMRmTKKrqVEJ3OkJ. The login page is expected to be skipped and automatically login the user admin. This is just a manual attempt to token based login. Now, to have this work seamlessly with a different website, we should generate a login token key. A token key can be used to generate login tokens whenever needed for MeshCentral. Generate this key with \u201c--loginTokenKey\" switch as shown below The generated masker key must be placed in a secure location within the business website. As illustrated above, we see the business site using the token key to generate a login token and embed it into the response web page. The user\u2019s browser then loads the iframe that includes both the URL with the login token for MeshCentral. MeshCentral can then verify the token and allow the web page to load as expected.","title":"Login Token"},{"location":"meshcentral/#embedding-options","text":"There are multiple options available for user to explicitly choose the features that will be loaded from MeshCentral to the business website. The argument in the in the URL can dictate which web page should display and how. The three embedding URL arguments are Viewmode, Hide and Node. Embedding Options / URL Argument Description \"Values Note : For values 10 and above, a node identifier must be specified.\" viewmode \"Indicates the information to show. This is an integer value, possible values are:\" \"1 = Devices tab 2 = Account tab 3 = Events tab 4 = Users tab (Site admins only) 5 = Server files tab 10 = Device general information 11 = Device remote desktop 12 = Device terminal 14 = Device Intel AMT console. 15 = Device Mesh Agent console hide \"Indicates which portion of the web page to hide. This is a bitmask integer hence it will need the sum of values. For .e.g.: To hide all of the values, add 1+2+4+8 and use 15 as the value. 1 = Hide the page header 2 = Hide the page tab 4 = Hide the page footer 8 = Hide the page title 16 = Hide the left tool bar 32 = Hide back buttons node Optional unless Viewmode is set to value of 10 or greater. Indicates which node to show on the screen, For example, if we want to embed the remote desktop page for a given node and hide the header, tabs, footer and page title, we could have this URL: https://localhost/?node=UkSNlz7t...2Sve6Srl6FltDd&viewmode=11&hide=15\" Node or NodeID is a long base64 encoded SHA384 value Note : Typically, the URL for the website is followed by \u201c?\u201d then a set of name=value pairs separated by \u201c&\u201d. Based on the URL https://localhost/?node=UkSNlz7t...2Sve6Srl6FltDd&viewmode=11&hide=15 , the nodeID starts with \u201cUkSNlz7t\u201d. We shortened the value in this example, but it\u2019s normally a long base64 encoded SHA384 value. The Viewmode set to 11 which is the remote desktop page and Hide set to 15 to hide everything. Hence the user may see as illustrated below. Only the remote desktop viewer will be displayed embedded within an iframe. Note : User must set \u201callowFraming\u201d to true in the config.json of the server. This is in addition to the Node, Viewmode and Hide arguments, the login token must be specified to add complex features into another website.","title":"Embedding Options"},{"location":"meshcentral/#server-port-aliasing","text":"In some cases, you may be setting up a server on a private network that uses non-standard ports, but use a router or firewall in front to perform port mapping. So, even if the server privately uses non-standard ports, the public ports are the standard ports 80 and 443. You have to tell MeshCentral to bind to private ports but pretend it\u2019s using the other standard ports when communicating publically. To make this work, MeshCentral supports port aliasing. For example you can run: node meshcentral --redirport 2001 --port 2002 --aliasport 443 Here, the server binds the HTTP and HTTPS ports to 2001 and 2002, but the server will externally indicate to MeshAgents and browsers that they must connect to port 443. In a different situation, you may want to setup a server so that both Mesh Agents and Intel AMT connect back to the server on port 443. This is useful because some corporation have firewalls that restrict outgoing connections to only port 80 and 443. By default, MeshCentral will be setup to have MeshAgents connection on port 443 and Intel AMT on port 4433. In the following picture we have a usual server running with: node meshcentral --cert Server1 --port 443 --mpsport 4433 We can setup the server so that MeshAgent and Intel AMT will connect on port 443 of two different IP address or names like this: node meshcentral --cert Server1 --mpscert Server2 --port 443 --mpsport 4433 --mpsaliasport 443 In the second example, the server on the right is running HTTPS on port 443 and MPS on port 4433 as usual, but the MPS is now presenting a certificate that has the name \u201cServer2\u201d on it. The server will also configure Intel AMT CIRA to connect to \u201cServer2:443\u201d. A router or firewall that is located in front of the MeshCentral server needs to be configured correctly to forwarding: Server1:443 -> 443 on MeshCentral Server2:443 -> 4433 on MeshCentral The routing of IP and ports by the firewall shown on the picture must be configured separately from MeshCentral using separate software. Typically, routers or firewalls have the proper controls to configure this type of traffic routes.","title":"Server port aliasing"},{"location":"meshcentral/#device-groups-with-relay-agent","text":"MeshCentral supports the local device group allowing devices that do not have an agent to be managed thru MeshCentral with regular SSH, SFTP, RDP, VNC protocols. Until now, the MeshCentral server had to be in LAN or Hybrid modes to support his device group and the managed devices had to be on the same network as the MeshCentral server. Starting with v1.0.11, users can create a local device group specifying a MeshAgent as a relay. This makes it possible to manage agent-less devices from anywhere on the Internet even if the server is in WAN mode. Simply install a single device with a MeshAgent on a network and create a local device group with that device as the relay. To enable SSH support, add this line to the domain section of your config.json: \"ssh\" : true Video Walkthru","title":"Device Groups with Relay Agent"},{"location":"meshcentral/#raritan-and-webpowerswitch-with-relay","text":"In addition to local device groups, the IP-KVM/Power switch device group was also improved to support a MeshAgent as a relay. This is big news for Raritan IP-KVM switch owners as you can now monitor your IP-KVM ports and access them remotely from the Internet. The same can be done with WebPowerSwitch allowing full out-of-band remote access to devices from anywhere in the world.","title":"Raritan and WebPowerSwitch with Relay"},{"location":"meshcentral/#nginx-reverse-proxy-setup","text":"","title":"NGINX Reverse-Proxy Setup"},{"location":"meshcentral/#video-walkthru_1","text":"Sometimes it\u2019s useful to setup MeshCentral with a reverse-proxy in front of it. This is useful if you need to host many services on a single public IP address, if you want to offload TLS and perform extra web caching. In this section we will setup NGINX, a popular reverse-proxy, in front of MeshCentral. NGNIX is available at: https://www.nginx.com/ In this example, we will: MeshCentral on non-standard ports, but alias HTTPS to port 443. NGINX will be using standard ports 80 and 443. We will have NGINX perform all TLS authentication & encryption. MeshCentral will read the NGINX web certificate so agents will perform correct server authentication. NGINX will be setup with long timeouts, because agents have long standard web socket connections. Let\u2019s get started by configuring MeshCentral with the following values in config.json: { \"settings\" : { \"Cert\" : \"myservername.domain.com\" , \"Port\" : 4430 , \"AliasPort\" : 443 , \"RedirPort\" : 800 , \"AgentPong\" : 300 , \"TlsOffload\" : \"127.0.0.1\" }, \"domains\" : { \"\" : { \"certUrl\" : \"https://127.0.0.1:443/\" } } } With this configuration, MeshCentral will be using port 4430 instead of port 443, but because \u201cTlsOffload\u201d is set, TLS will not be performed on port 4430. The server name is set to \u201cmyservername.domain.com\u201d, so that is the name that MeshCentral will give to agents to connect to. Also, the alias port is set to 443. So agents will be told to connect to \u201cmyservername.domain.com:443\u201d. The \u201cAgentPong\u201d line instructs the server to send data to the agent each 300 seconds and the agent by default will send data to the server every 120 seconds. As long as NGINX timeouts are longer than this, connections should remain open. When agents connect, they will see the NGINX TLS certificate on port 443. MeshCentral needs to know about the NGINX certificate so that it can tell the agents this is the correct certificate they should expect to see. So, \u201ccertUrl\u201d is used to tell MeshCentral where to get the certificates that agents will see when connecting. When NGINX forwards connections to MeshCentral, extra X-Forwarded headers will be added to each request. MeshCentral needs to know if these headers can be trusted or not. By setting \u201cTlsOffload\u201d to \u201c127.0.0.1\u201d, MeshCentral is told to trust these headers when requests come from \u201c127.0.0.1\u201d. In this example, make sure to change \u201c127.0.0.1\u201d to the IP address of NGINX and \u201cCert\u201d to the external DNS name of the NGINX server. Next, we need to configure and launch NGINX. Here is an ngnix.conf to get started: worker_processes 1; events { worker_connections 1024; } http { # HTTP server. In this example, we use a wildcard as server name. server { listen 80; server_name _; location / { proxy_pass http://127.0.0.1:800/; proxy_http_version 1.1; # Inform MeshCentral about the real host, port and protocol proxy_set_header X-Forwarded-Host $host:$server_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } # HTTPS server. In this example, we use a wildcard as server name. server { listen 443 ssl; server_name _; # MeshCentral uses long standing web socket connections, set longer timeouts. proxy_send_timeout 330s; proxy_read_timeout 330s; # We can use the MeshCentral generated certificate & key ssl_certificate webserver-cert-public.crt; ssl_certificate_key webserver-cert-private.key; ssl_session_cache shared:WEBSSL:10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:4430/; proxy_http_version 1.1; # Allows websockets over HTTPS. proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $host; # Inform MeshCentral about the real host, port and protocol proxy_set_header X-Forwarded-Host $host:$server_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } } As indicated in the comments of this NGINX configuration file, we set timeouts to be really long. We forward HTTP port 80 and HTTPS port 443 to the corresponding ports on MeshCentral. In this example, we happen to use the web certificates that where generated by MeshCentral, but any certificate is ok. We also add extra \u201cX-Forward\u201d headers, this tells MeshCentral information that would normally be hidden by NGINX, like the client\u2019s IP address and more. Now we are ready to start NGINX and MeshCentral. You should start NGINX first because MeshCentral will try to fetch the certificate from NGINX upon start. When starting MeshCentral, you should see something like this: MeshCentral HTTP redirection web server running on port 800. Loaded RSA web certificate at https://127.0.0.1:443/, SHA384: d9de9e27a229b5355708a3672fb23237cc994a680b3570d242a91e36b4ae5bc96539e59746e2b71eef3dbdabbf2ae138. MeshCentral Intel(R) AMT server running on myservername.domain.com:4433. MeshCentral HTTP web server running on port 4430, alias port 443. Notice on the second line, MeshCentral will have loaded the web certificate from NGNIX and display a matching hash. That is it, navigating to port 80 and 443 on NGINX should show the MeshCentral web page and agents should connect as expected.","title":"Video Walkthru"},{"location":"meshcentral/#cira-setup-with-nginx","text":"We can add on the section above and support reverse proxy for Intel\u00ae AMT Client Initiated more Access (CIRA) connecting that come to the server. Normally, CIRA connections come on port 4433 and use TLS. Since CIRA is a binary protocol, care must be taken to configure NGINX to handle the data as a TCP stream instead of HTTP. At the very bottom of the nginx.conf file, we can add the following: stream { # Internal MPS servers, in this case we use one MeshCentral MPS server is on our own computer. upstream mpsservers { server 127.0.0.1:44330 max_fails=3 fail_timeout=30s; } # We can use the MeshCentral generated MPS certificate & key ssl_certificate mpsserver-cert-public.crt; ssl_certificate_key mpsserver-cert-private.key; ssl_session_cache shared:MPSSSL:10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # MPS server. server { listen 4433 ssl; proxy_pass mpsservers; proxy_next_upstream on; } } NGINX will listen on port 4433, decrypt the connection and forward it to 44330 on the loopback interface. We are going to be used the \u201cmpsserver\u201d certificate that was created by MeshCentral as the TLS server certificate for port 4433. Now, we just have to make a few changes to the MeshCentral config.json file. { \"settings\": { \"Cert\": \"myservername.domain.com\" \"Port\": 4430, \"AliasPort\": 443, \"RedirPort\": 800, \"TlsOffload\": \"127.0.0.1\" \"MpsPort\": 44330, \"MpsAliasPort\": 4433, \"MpsTlsOffload\": true }, \"domains\": { \"\": { \"certUrl\": \"https://127.0.0.1:443/\" } } } In this new config.json, we added 3 lines. First, the MeshCentral Management Presence Server (MPS) is now on port 44330. However, the MpsAliasPort value indicates that externally, port 4433 will be used, so we need to configure Intel AMT to connect to port 4433. Lastly, we want to disable TLS support on port 44330 by setting \u201cMpsTlsOffload\u201d to true. With this configuration, Intel AMT CIRA connections will come in and TLS will be handled by NGINX. With this setup, it\u2019s not possible to configure Intel AMT CIRA to connect using mutual-TLS authentication, only username/password authentication is used.","title":"CIRA Setup with NGINX"},{"location":"meshcentral/#traefik-reverse-proxy-setup","text":"In this section, we will setup MeshCentral with Traefik, a popular reverse proxy software. This section will be much like the previous section setting up NGNIX but with a different software and configuration file. Traefik is open source and available at: https://traefik.io/ This section covers a really simple Traefik configuration. Traefik is capable of a lot more complex configurations. In this example, we will: MeshCentral on non-standard ports, but alias HTTPS to port 443. Traefik will be using standard ports 80 and 443. We will have Traefik perform all TLS authentication & encryption. MeshCentral will read the NGINX web certificate so agents will perform correct server authentication. First we will start with the MeshCentral configuration, here is a minimal configuration that will work: { \"settings\" : { \"Cert\" : \"myservername.domain.com\" , \"Port\" : 4430 , \"AliasPort\" : 443 , \"RedirPort\" : 800 , \"TlsOffload\" : \"127.0.0.1\" }, \"domains\" : { \"\" : { \"certUrl\" : \"https://127.0.0.1:443/\" , \"agentConfig\" : [ \"webSocketMaskOverride=1\" ], } } } Note the \u201cagentConfig\u201d line : Because Traefik does not support web socket connections that are not \u201cmasked\u201d, we have to tell the Mesh Agents to mask web socket connections using this line. Once set, any new agent will be installed with the web socket masking turned on. Also note that we will be running MeshCentral on port HTTPS/4430 and HTTP/800. However, we also indicate to MeshCentral that HTTPS will really be on port 443 using the \u201cAliasPort\u201d line. The \u201cTlsOffload\u201d line indicates that MeshCentral should not perform TLS on port 4430. And the \u201ccertUrl\u201d line indicates what URL can be used to load the external certificate that will be presented on port 443 in front of MeshCentral. Now that we have MeshCentral setup, let\u2019s take a look at a sample Traefik configuration file. In this case, we will manually configure the entrypoints, frontends and backends within the Traefik configuration file. There is a basic configuration file for Traefik 1.7: [ global ] checkNewVersio n = false se n dA n o n ymousUsage = false [ e ntr yPoi nts ] [ e ntr yPoi nts .h tt p ] address = \":80\" [ e ntr yPoi nts .h tt p.redirec t ] e ntr yPoi nt = \"https\" [ e ntr yPoi nts .h tt ps ] address = \":443\" [ e ntr yPoi nts .h tt ps. tls ] [[ e ntr yPoi nts .h tt ps. tls .cer t i f ica tes ]] cer t File = \"webserver-cert-public.crt\" keyFile = \"webserver-cert-private.key\" [ f ile ] [ backe n ds ] [ backe n ds.backe n d 1 ] [ backe n ds.backe n d 1. heal t hcheck ] pa t h = \"/health.ashx\" i nter val = \"30s\" [ backe n ds.backe n d 1. servers.server 1 ] url = \"http://127.0.0.1:4430\" weigh t = 1 [ fr o nten ds ] [ fr o nten ds. fr o nten d 1 ] e ntr yPoi nts = [ \"https\" ] backe n d = \"backend1\" passHos t Header = true [ fr o nten ds. fr o nten d 1. rou tes ] [ fr o nten ds. fr o nten d 1. rou tes .mai n ] rule = \"Host:myserver.domain.com,localhost\" [ api ] e ntr yPoi nt = \"traefik\" dashboard = true The enterPoints section shows we have two entry points, port 80 will be redirected to port 443. Traefik will perform this redirection so MeshCentral will never see port 80 connections. Port 443 will be setup using the given TLS certificates. In this example, we just used the certificate files generated by MeshCentral in the \u201cmeshcentral-data\u201d folder. You can use the two certificate files as-is. The backends section configures one MeshCentral server on port \u201c4430\u201d. Traefik will additionally check the health of the MeshCentral server periodically, every 30 seconds. The frontends section is what routes the connections coming in the entry points to the backend servers. In this case, the HTTPS entry point is routed to the MeshCentral server is the hostname matches \u201cmyserver.domain.com\u201d or \u201clocalhost\u201d. Finally, the API section creates a web portal on port 8080 for monitoring of Traefik.","title":"Traefik Reverse-Proxy Setup"},{"location":"meshcentral/#haproxy-reverse-proxy-setup","text":"In this section, we will setup MeshCentral with HAProxy, a small popular reverse proxy software. This section will be much like the previous sections setting up NGNIX and Traefik but with a different software and configuration file. HAProxy is free and available at: https://www.haproxy.org/ This section covers a really simple configuration. HAProxy is capable of a lot more complex configurations. In the following example, HAProxy will perform TLS and forward the un-encrypted traffic to MeshCentral on port 444. HAProxy will add extra \u201cX-Forwarded-Host\u201d headers to the HTTP headers so that MeshCentral will know from the IP address the connection comes from. In the following configuration file, we have browser connections on port 80 being redirected to HTTPS port 443. We also have Let\u2019s Encrypt cert bot for getting a real TLS certificate and \u201cmesh.sample.com\u201d being redirected to 127.0.0.1:444. global log /dev/log local0 log /dev/log local1 notice chroot /var/lib/haproxy stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners stats timeout 30s user haproxy group haproxy daemon defaults log global mode http option httplog option dontlognull option forwardfor option http-server-close frontend http bind *:80 redirect scheme https code 301 if !{ ssl_fc } frontend https bind *:443 ssl crt /etc/haproxy/cert.pem http-request add-header X-Forwarded-Proto https acl acmepath path_beg /.well-known/acme-challenge/ acl meshcentralhost hdr(host) -i mesh.sample.com acl meshcentralhost hdr(host) -i mesh.sample.com:443 use_backend acme if acmepath use_backend meshcentral if meshcentralhost backend acme server certbot localhost:54321 backend meshcentral http-request add-header X-Forwarded-Host %[req.hdr(Host)] server meshcentral 127.0.0.1:444 On the MeshCentral side, we are not going to use port 80 and need the main HTTPS port to not perform TLS and listen on port 444. { \"settings\" : { \"Cert\" : \"myservername.domain.com\" , \"Port\" : 444 , \"AliasPort\" : 443 , \"RedirPort\" : 0 , \"TlsOffload\" : \"127.0.0.1\" }, \"domains\" : { \"\" : { \"certUrl\" : \"https://127.0.0.1:443/\" } } } We also specify \u201c127.0.0.1\u201d in TLS offload since we want MeshCentral to make use of the X-Forwarded-Host header that is set by HAProxy.","title":"HAProxy Reverse-Proxy Setup"},{"location":"meshcentral/#running-in-a-production-environment","text":"When running MeshCentral is a production environment, administrators should set NodeJS to run in production mode. There is a good article here (http://www.hacksparrow.com/running-express-js-in-production-mode.html) on what this mode is and how to set it. This mode will also boost the speed of the web site on small devices like the Raspberry Pi. To run in production mode, the environment variable \u201cNODE_ENV\u201d must be set to \u201cproduction\u201d. On Linux, this is done like this: export NODE_ENV=production On Windows, it\u2019s done like this: SET NODE_ENV=production Special care must be taken to set the environment variable in such a way that if the server is rebooted, this value is still set. Once set, if you run MeshCentral manually, you will see: MeshCentral HTTP redirection web server running on port 80. MeshCentral v0.2.2-u, Hybrid (LAN + WAN) mode, Production mode. MeshCentral Intel(R) AMT server running on devbox.mesh.meshcentral.com:4433. MeshCentral HTTPS web server running on devbox.mesh.meshcentral.com:443. In production mode, ExpressJS will cache some files in memory making the web server much faster and any exceptions thrown by the ExpressJS will not result in the stack trace being sent to the browser.","title":"Running in a Production Environment"},{"location":"meshcentral/#two-step-authentication","text":"If the MeshCentral server is setup with a certificate name and not setup to use Windows domain authentication, then users will have the options to use 2-step authentication using the Google Authenticator application or any compatible application. Use of this option should be encouraged for users that manage a lot of critical computers. Once active the users will need to enter their username, password and a time limited token to login. To get this features setup, users will need to go to the \u201cMy Account\u201d tab or the \u201cMy Account\u201d menu in the mobile application. They then select, \u201cAdd 2-stop login\u201d and follow the instructions. Note that if a user performs a password recovery using email, the 2-step authentication is then turned off and will need to be turned on again. This is not idea as someone being able to intercept the user\u2019s email could still log into the web site. Users should make sure to properly protect their email account.","title":"Two step authentication"},{"location":"meshcentral/#branding-terms-of-use","text":"Once MeshCentral is setup, you may want to customize the web site with your own brand and terms of use. This is important to personalize the web site to your organization. We also want to customize the web site in such a way that updating to the latest version will keep the branding as-is.","title":"Branding &amp; Terms of use"},{"location":"meshcentral/#branding","text":"You can put you own logo on the top of the web page. To get started, get the file \u201clogoback.png\u201d from the folder \u201cnode_modules/meshcentral/public/images\u201d and copy it to your \u201cmeshcentral-data\u201d folder. In this example, we will change the name of the file \u201clogoback.png\u201d to \u201ctitle-mycompagny.png\u201d. Then use any image editor to change the image and place your logo. Once done, edit the config.json file and set the following values: \"domains\" : { \"\" : { \"Title\" : \"\" , \"Title2\" : \"\" , \"TitlePicture\" : \"title-sample.png\" , }, This will set the title and sub-title text to empty and set the background image to the new title picture file. You can now restart the serve and take a look at the web page. Both the desktop and mobile sites will change. The title image must a PNG image of size 450 x 66. You can also customize the server icon in the \u201cMy Server\u201d tab. By default, it\u2019s a picture of a desktop with a padlock. If, for example, MeshCentral is running on a Raspberry Pi. You may want to put a different picture at this location. Just put a \u201cserver.jpg\u201d file that is 200 x 200 pixels in the \u201cmeshcentral-data\u201d folder. The time MeshCentral page is loaded, you will see the new image. This is great to personalize the look of the server within the web site.","title":"Branding"},{"location":"meshcentral/#terms-of-use","text":"You can change the terms of use of the web site by adding a \u201cterms.txt\u201d file in the \u201cmeshcentral-data\u201d folder. The file can include HTML markup. Once set, the server does not need to be restarted, the updated terms.txt file will get used the next time it\u2019s requested. For example, placing this in \u201cterms.txt\u201d <br /> This is a <b>test file</b>. Will show this on the terms of use web page.","title":"Terms of use"},{"location":"meshcentral/#server-backup-restore","text":"It\u2019s very important that the server be backed up regularly and that a backup be kept offsite. Luckily, performing a full backup of the MeshCentral server is generally easy to do. For all installations make sure to back up the following two folders and all sub-folders. meshcentral-data meshcentral-files If using NeDB that is built into MeshCentral, you are done. If you are running MongoDB, you will need to perform an extra step. In the command shell, run mongodump to archive all of the MongoDB databases. mongodump --archive=backup.archive Then, keep the backup.archive file in a safe place. It\u2019s critical that the content of meshcentral-data be backed up in a secure location and preferably using encryption, this is because it contains certificates that give this server its unique personality. Once agents are installed, they will only connect to this server and no other. If you reinstall MeshCentral, even if it is with the same domain name, agents will not connect to the new server since the server certificates are different. Also, someone with access to a backup of \u201cmeshcentral-data\u201d could impersonate the server. To restore back backup, just install a MeshCentral server, make sure it works correctly. Stop it, wipe the old \u201cmeshcentral-data\u201d and \u201cmeshcentral-files\u201d and put the backup version instead. If using MongoDB, copy the backup.archive back, make sure to clean up any existing \u201cmeshcentral\u201d database, run \u201cmongo\u201d and type: use meshcentral db.dropDatabase() Then exit with Ctrl-C and run: mongorestore --archive=backup.archive This will re-import the database from the backup. You can then start MeshCentral again. Note The two values for backup and restore in the json are only valid for databases backed by NeDB","title":"Server Backup &amp; Restore"},{"location":"meshcentral/#backup-to-google-drive","text":"sudo systemctl stop meshcentral.service nano /opt/meshcentral/meshcentral-data/config.json Remove underscored items sudo systemctl start meshcentral.service sudo systemctl status meshcentral.service Log into your MC: Create desktop app Enter the Client ID and Client Secret into MC","title":"Backup to Google Drive"},{"location":"meshcentral/#hashicorp-vault-support","text":"MeshCentral has built-in support for HashiCorp Vault so that all configuration and certificates used by MeshCentral are retrieved from a Vault server. Vault is a secret store server and when used with MeshCentral, the MeshCentral server will not be storing any secrets locally. You can get started with Vault here: https://www.vaultproject.io/ Once you got a MeshCentral server working correctly, you can start a simple demonstration Vault server by typing: vault server -dev When you run the server in developer mode, you will see a secret token and unseal key on the screen. These two values will be used in the commands to follow. You can load the configuration file and all certificates from \u201cmeshcentral-data\u201d into Vault by typing this: node node_modules/meshcentral --vaultpushconfigfiles --vault http://127.0.0.1:8200 --token s.cO4\u2026 --unsealkey 7g4w\u2026 --name meshcentral Once all of the files have been written into Vault, you can take a look at the Vault web user interface to see all of the secrets. It will be in \u201csecret/meshcentral\u201d: The \u201cconfig.json\u201d and \u201cterms.txt\u201d files and files in \u201cmeshcentral-data\u201d that end with \u201c.key\u201d, \u201c.crt\u201d, \u201c.jpg\u201d and \u201c.png\u201d will be stored in Vault. You can then run MeshCentral like this: node node_modules/meshcentral --vault http://127.0.0.1:8200 --token s.cO4\u2026 --unsealkey 7g4w\u2026 --name meshcentral MeshCentral will first read all of the files from Vault and get started. An alternative to this is to create a very small config.json file in \u201cmeshcentral-data\u201d that contains only the Vault configuration like this: { \"settings\" : { \"vault\" : { \"endpoint\" : \"http://127.0.0.1:8200\" , \"token\" : \"s.cO4Q\u2026\" , \"unsealkey\" : \"7g4wFC\u2026\" , \"name\" : \"meshcentral\" } } } Once the config.json file is setup, you can just run MeshCentral without any arguments. node node_modules/meshcentral Lastly you can all pull all of the files out of Vault using this command line: node node_modules/meshcentral --vaultpullconfigfiles --vault http://127.0.0.1:8200 --token s.cO4\u2026 --unsealkey 7g4w\u2026 --name meshcentral And delete the Vault secrets using this: node node_modules/meshcentral --vaultdeleteconfigfiles --vault http://127.0.0.1:8200 --token s.cO4\u2026 --unsealkey 7g4w\u2026 --name meshcentral","title":"HashiCorp Vault support"},{"location":"meshcentral/#database-record-encryption","text":"Regardless if using the default NeDB database or MongoDB, MeshCentral can optionally encrypt sensitive data that is stored in the database. When enabled, this encryption is applied to user credentials and Intel AMT credentials. The additional encryption does the affect database operations and can be used in addition to additional database security. In the following image, we see on the left a normal user record including user credential hashes and data required for two-factor authentication. On the right side, these values are encrypted using AES-256-GCM in the \u201c_CRYPT\u201d field. Only some data fields are encrypted and the \u201c_CRYPT\u201d entry will only be present when one or more fields are present that need to be secured. To enable this feature, add the \u201cDbRecordsEncryptKey\u201d with a password string to the \u201csettings\u201d section of the config.json like this: { \"settings\" : { \"Port\" : 4430 , \"RedirPort\" : 800 , \"DbRecordsEncryptKey\" : \"MyReallySecretPassword\" } } The provided password will be hashed using SHA384 and the result with be used as an encryption key. When DbRecordsEncryptKey is set, any new or updated records that are written will be encrypted when needed. Existing encrypted records will be read and decrypted as needed. You can force the all entries to be re-written by running: node node_modules/meshcentral --recordencryptionrecode This command will re-write entries in the database that could require added security and force the application of record encryption. You can also specify a key for decryption only like this: { \"settings\" : { \"Port\" : 4430 , \"RedirPort\" : 800 , \"DbRecordsDecryptKey\" : \"MyReallySecretPassword\" } } When set, the key will only be used for decryption and any new or updated records in the database will not be written with record encryption. You can then run this command again to force all records to be rewritten without encryption: node node_modules/meshcentral --recordencryptionrecode It\u2019s really important to keep the encryption key in a safe place along with database backups. If the database is backed up but the record encryption key is lost, it will not be possible to recover the secured data in the database. Also note that database record encryption can and should be used along with other data protection systems.","title":"Database Record Encryption"},{"location":"meshcentral/#mongodb-free-server-monitoring","text":"If running with MongoDB version 4.x, there is a free database monitoring service that is provided. Just run \u201cmongo\u201d and you may see the following: Type \u201cdb.enableFreemonitoring()\u201d if you want to enable this. You will be given a URL to access the data and can turn it back off at any time. The web page will look something like this: In addition to database specific information, the graphs track CPU, memory and disk usage. This can be useful to track how well the server is responding under load.","title":"MongoDB free server monitoring"},{"location":"meshcentral/#meshcentral-single-sign-on-sso","text":"As with any web application deployed in organization, it\u2019s convenient and more secure for users to have a single set of credentials that can be used across many services. In this section we take a look at how to configure MeshCentral so that you can sign-in using credentials from other services. This allows users to completely skip creating a user account on MeshCentral or having to remember usernames and password for one more web site. There are two single sign-on protocols that are supported in MeshCentral, OAuth2 and SAML. We will take a look at an example for each one. Before you get started, your MeshCentral server must be publicly facing on the internet and have a valid TLS certificate. For example, by setting up Let\u2019s Encrypt. After the web site is working correctly user the steps below.","title":"MeshCentral Single Sign-On (SSO)"},{"location":"meshcentral/#twitter-authentication","text":"Like many other services, Twitter allows its users to login to other web site using Twitter credentials using OAuth2. Start by creating an account on Twitter and logging in. Then navigate to https://developer.twitter.com/en/apps , this is where you can create new applications that are compatible with Twitter. Start by creating a new application and fill in the application form. Give your application and name, description, server URL and more. Make sure to select \u201cEnable Sign in with Twitter\u201d and set the callback URL to \u201chttps://(server.domain.com)/auth-twitter-callback\u201d. This is the URL that Twitter will redirect users to once they are logged in. For example this is what a sample application would look like: Once the new application is created, go to the \u201cKeys and tokens\u201d tab. You will need the \u201cAPI Key\u201d and \u201cAPI secret key\u201d values. In the MeshCentral config.json, place these two values as \u201cclientid\u201d and \u201cclientsecret\u201d of the Twitter section of the \u201cAuthStrategies\u201d. Once done, your config.json should look a bit like this: { \"settings\" : { \"Cert\" : \"myserver.mydomain.com\" , \"Port\" : 443 , \"RedirPort\" : 80 }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"NewAccounts\" : true , \"authStrategies\" : { \"twitter\" : { \"clientid\" : \"xxxxxxxxxxxxxxxxxxxxxxx\" , \"clientsecret\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" } } } } } Note that if you do not allow new accounts, any new users that use Twitter credentials will not be able to login to MeshCentral. One trick is to allow new account, login and change this setting again. Once the config.json is correct, restart the server and you should see the Twitter icon on the login screen. When restarting the MeshCentral server, new modules will need to be installed to support this new feature. Depending on how your server is setup, you may need to restart the server manually to allow the new modules to be installed.","title":"Twitter Authentication"},{"location":"meshcentral/#google-github-reddit-authentication","text":"The exact same process as shown in the previous section can be repeated for Google, GitHub and Reddit. In each case, you need to go to each respective credential provider and get a \u201cClientID\u201d and \u201cClientSecret\u201d for each service. You also need to register the correct callback URL for each service. Take a look at the config.json below and note the callback URL that will need to be registered for each service provider. { \"settings\" : { \"Cert\" : \"myserver.mydomain.com\" , \"Port\" : 443 , \"RedirPort\" : 80 }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"NewAccounts\" : true , \"authStrategies\" : { \"twitter\" : { \"__callbackurl\" : \"https://server/auth-twitter-callback\" , \"clientid\" : \"xxxxxxxxxxxxxxxxxxxxxxx\" , \"clientsecret\" : \" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \" }, \"google\" : { \"__callbackurl\" : \"https://server/auth-google-callback\" , \"clientid\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com\" , \"clientsecret\" : \"xxxxxxxxxxxxxxxxxxxxxxx\" }, \"github\" : { \"__callbackurl\" : \"https://server/auth-github-callback\" , \"clientid\" : \"xxxxxxxxxxxxxxxxxxxxxxx\" , \"clientsecret\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" }, \"reddit\" : { \"__callbackurl\" : \"https://server/auth-reddit-callback\" , \"clientid\" : \"xxxxxxxxxxxxxxxxxxxxxxx\" , \"clientsecret\" : \" xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \" } } } } } It\u2019s possible to enable all four of these service providers at the same time to offer the most flexibility for users. Note that when using an OAuth service provider, MeshCentral does not offer two-factor authentication since it will be handled by the provider depending on user configuration.","title":"Google, GitHub, Reddit Authentication"},{"location":"meshcentral/#microsoft-azure-active-directory","text":"In this section we look at how to setup MeshCentral to Azure Active Directory using OAuth. Like all other sections about setting up single sign-on, make sure your MeshCentral server is already setup on the public Internet with a valid TLS certificate. You can then start by adding a new application registration to the Azure portal. We give our application a name, generally the domain name of the MeshCentral server is a good choice. Then you can setup the redirect URL to https://[servername]/auth-azure-callback. Make sure to type this correctly, all lower case with the full domain name of your MeshCentral server. Once done, there are two values we will need later, the Application ID and Tenant ID. Next, we need to create a secret that will be shared between Azure and MeshCentral. Go to the \u201cCertificates & secrets\u201d section and click \u201cNew client secret\u201d. You then enter a name and for our example, we will opt to never make it expire. We then copy the resulting secret and this will be the 3 rd and final value we need to get MeshCentral setup. Now, we take the application ID, tenant ID and secret and place these values in the MeshCentral config.json like so: { \"settings\" : { \"Cert\" : \"myserver.mydomain.com\" , \"Port\" : 443 , \"RedirPort\" : 80 }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"NewAccounts\" : false , \"authStrategies\" : { \"azure\" : { \"newAccounts\" : true , \"clientid\" : \"be4aadd3-77b8-4e55-af8a-4b8e2d994cb5\" , \"clientsecret\" : \"NP0XXXXXXXXXXXXXXXXXXX\" , \"tenantid\" : \"18910a48-e492-4c49-8043-3449f7964bd6\" } } } } } The \u201cApplication ID\u201d value is placed as \u201cClient ID\u201d in the configuration file. You can also see that in the example above, we have \u201cNewAccounts\u201d set to false in the default MeshCentral domain, but set to true in the Azure section. This indicates that new accounts are not allowed in this domain except if it\u2019s a new user that is authenticating thru Azure. Once done, restart the MeshCentral server. Depending on your setup, you many need to run MeshCentral once manually to allow new required modules to be installed. Once running again, you should see the Azure single sign-on button on the login page.","title":"Microsoft Azure Active Directory"},{"location":"meshcentral/#jumpcloud-authentication-using-saml","text":"While using OAuth may be interesting, it\u2019s more likely that MeshCentral servers used in an enterprise environment will want to use SAML (Security Assertion Markup Language). This is a widely deployed sign-on protocol used in enterprises so that, for example, employees can login to many different web sites using a single set of company credentials. MeshCentral can be one of many web sites that some users may want to log into. In this section, we setup MeshCentral with JumpCloud, an easy to use sign-in provider. You can create an account on JumpCloud for free with up to 10 users allowing you to quickly get setup and test the following setup. In the next section, we look at a generic SAML configuration. Before getting started with this section, make sure your server is on the Internet and publicly available and that it has a valid TLS certificate. You can use Let\u2019s Encrypt to get a valid TLS certificate. Then, start by going to https://jumpcloud.com and creating an administrator account. Once setup, go to \u201cApplications\u201d and click on the big plug sign to create a new application. You will need to create a custom SAML application by clicking the \u201cCustom SAML App\u201d. Then, you can fill in the form with an application name and logo. For the IdP Entity ID, put \u201cjumpcloud\u201d. For the SP Entity ID put \u201cmeshcentral\u201d. For the ACS URL, put the callback URL of your server. In this case it will be \u201chttps://(yourservername)/auth-jumpcloud-callback\u201d Lastly in the attributes section, add 3 user attribute mapping. \u201cfirstname\u201d to \u201cfirstname\u201d \u201clastname\u201d to \u201clastname\u201d \u201cemail\u201d to \u201cemail\u201d The attribute mappings will allow MeshCentral to receive from JumpCloud the first and last name of the user and the email address of the use. If any of these values are changed in the future, MeshCentral will update them the next time the user logs into MeshCentral. Here is an example configuration with red arrows next to important values. Once setup, you will need to allow one or more users to use the new application. One way to do this is to just add your new application to the \u201cAll Users\u201d group. We are now almost done with JumpCloud. The last thing we need to do is download the certificate that JumpCloud will be using to sign the SAML assertions. You can get this certificate by going in the \u201cApplications\u201d tab, click on your new application and select \u201cDownload Certificate\u201d as shown here. Save the certificate as \u201cjumpcloud-saml.pem\u201d and place it in the \u201cmeshcentral-data\u201d folder. You are now ready to configure MeshCentral. Edit the config.json and make it look like this: { \"settings\" : { \"Cert\" : \"myserver.mydomain.com\" , \"Port\" : 443 , \"RedirPort\" : 80 }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"NewAccounts\" : false , \"authStrategies\" : { \"jumpcloud\" : { \"__callbackurl\" : \"https://server/auth-jumpcloud-callback\" , \"NewAccounts\" : true , \"entityid\" : \"meshcentral\" , \"idpurl\" : \"https://sso.jumpcloud.com/saml2/saml2\" , \"cert\" : \"jumpcloud-saml.pem\" } } } } } Take note that the \u201centityid\u201d, \u201cidpurl\u201d and \u201ccert\u201d are values taken from JumpCloud. The callback URL should be configured in JumpCloud as we have done in previous steps. You can see that in the example above, we have \u201cNewAccounts\u201d set to false in the default MeshCentral domain, but set to true in the JumpCloud section. This indicates that new accounts are not allowed in this domain except if it\u2019s a new user that is authenticating thru JumpCloud. You are now ready to restart the MeshCentral server. Extra modules will be needed to support SAML and so, depending on your server configuration, you may need to run MeshCentral manually once to allow the new modules to be installed from NPM. Once restarted, you should see the JumpCloud sign-in button on the login screen. Users can sign-in using the regular username and password or using JumpCloud.","title":"JumpCloud Authentication using SAML"},{"location":"meshcentral/#generic-saml-setup","text":"In this section, we look at configuring SAML with a generic authentication provider. The setup is exactly the same as with JumpCloud in the previous section, but we will be using a different section in the config.json to that a generic login icon is shown on the login page. A generic SAML setup will look like this: { \"settings\" : { \"Cert\" : \"myserver.mydomain.com\" , \"Port\" : 443 , \"RedirPort\" : 80 }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"NewAccounts\" : 1 , \"authStrategies\" : { \"saml\" : { \"__callbackurl\" : \"https://server/auth-saml-callback\" , \"entityid\" : \"meshcentral\" , \"idpurl\" : \"https://server/saml2\" , \"cert\" : \"saml.pem\" } } } } } The callback URL will be of the form \u201chttps://(servername)/auth-saml-callback\u201d. You should set the entityid, idpurl as given by the identity provider. Lastly, place the identity provider certificate file in the \u201cmeshcentral-data\u201d folder and indicate the name of the file in \u201ccert\u201d. Once setup, restart the server and you should see a Single Sign-on button on the login screen. Enabling SAML will require MeshCentral to install extra modules from NPM, so depending on your server configuration, you may need to run MeshCentral once manually.","title":"Generic SAML setup"},{"location":"meshcentral/#improvements-to-meshcentral","text":"In 2007, the first version of MeshCentral was built. We will refer to it as \u201cMeshCentral1\u201d. When MeshCentral1 was designed, HTML5 did not exist and web sockets where not implemented in any of the major browsers. Many design decisions were made at the time that are no longer optimal today. With the advent of the latest MeshCentral, MeshCentral1 is no longer supported and MeshCentral v2 has been significantly redesigned and mostly re-written based of previous version. Here is a list of improvements made in MeshCentral when compared with MeshCentral1: Quick Installation \u2013 By having MeshCentral published on NPM (www.npmjs.com) it\u2019s now easy to download and install MeshCentral on both Linux and Windows*. On Linux* you can use NPM directly (\u201cnpm install meshcentral\u201d) and on Windows you can use the .MSI installer. Cross-Platform Support \u2013 Contrary to MeshCentral1 that only runs on Windows*, MeshCentral can run on any environment that supports NodeJS. This includes Windows*, Linux* and OSX*. Because MeshCentral runs on Linux, it often lowers hosting costs and makes it possible to run MeshCentral in a Docker* container environment. Runs with Little Compute Resources \u2013 Typical MeshCentral1 installation requires a large disk space foot print (approx* 30G of disk space) and is compute intensive even for small deployments. MeshCentral requires little resources to host (70MB) and able to deliver reasonable performance on a 900Mhz CPU with 1GB RAM. Multi-Tenancy and Load Balancing Support \u2013 MeshCentral can handle hosting many server instances at once. Each instance or \u201cdomain\u201d has it\u2019s own administrators, users and computers to manage. The server can handle each instance using a url path \u201cserver.com/customer1\u201d or a DNS name \u201ccustomer1.server.com\u201d. Many customers can be handled by having all the DNS names point to the same server IP address. MeshCentral will take care of serving the right TLS certificate for each connection. Single Executable \u2013 MeshCentral is a single-module or single executable server. All of the components of MeshCentral1 including IIS, Swarm, AJAX, Social, Manageability Servers are all build into one single executable. This makes it super easy to setup and run, it also minimises problems and overhead caused by having many components communicate to each other. When the server is updated, all of the components are updated at once and effective. Web Application Design \u2013 MeshCentral1 has 100\u2019s of web pages and often times a click on a web page causes the browser to load a different web page and this creates more load on the server. With MeshCentral there are only two main web pages: The login page and the main web application. This design is much more responsive since the server now delegates most of the UI workload to the client\u2019s web browser. Real-Time User Interface \u2013 In MeshCentral, the user never has to hit the \u201crefresh\u201d button to update the web page. The web interface is completely real-time and updates as things change. MeshCentral uses websockets to connect to the server and get real-time events. Single Programming Language \u2013 MeshCentral1 used JavaScript on the brower, C# on the server and C for the agent. Use of 3 different programming languages means that developers wanting to implement a new use-case needs to have sufficient skills to change between these 3 languages during the coding session. Makes the code significantly more difficult to understand and maintain. Support for LAN only Mode \u2013 MeshCentral is capable of being setup as \u201cLAN only\u201d mode. In fact, this is the default mode when no static name or IP address is provided. In this mode, MeshAgents perform a multicast search on the network for the server making a static DNS/IP unnecessary. Support for TLS Offloaders \u2013 TLS offloaders are now fully supported. This means that MeshCentral can handle way more network connections and traffic significantly. Support for CIRA User/Pass Login \u2013 MeshCentral now supports both Intel AMT CIRA user/pass login and certificate login. Compared to MeshCentral1 that only supported certificate login, user/pass login is easier to setup and it can also be used for TLS offloaders and CIRA authentication. No Live State Stored in the Database \u2013 One if the big problems with MeshCentral1 is that a lot of the live states (Agent, User and AMT connections and disconnections) needed to be stored in the database. This caused a few problems, first the extra load on the database that was un-necessary, but also that servers did not have real-time state information about other servers (they had to query the database). This resulted in more load on the database and scaling issues. In MeshCentral, all live states are kept in the RAM which boosts performance significantly. Agentless Intel AMT Support \u2013 With MeshCentral1, administrators have to install the MeshAgent software on all computers, even if it was only for used for Intel AMT. MeshCentral supports a new agent-less mesh type that allows administrators to just setup the server strictly for Intel AMT only. Latest Security & Crypto algorithms \u2013 MeshCentral uses all the latest cryptographic algorithm, notably SHA384 and RSA3072 making it more resistant to future quantum computer attacks. This would be very difficult to retrofit into MeshCentralv1 since it would require change of database schema and 1000\u2019s of line of code thus making the server incompatible with the current version version, making migration difficult. Support for Email Verification and Password Recovery \u2013 MeshCentral can be configured with an SMTP server to send out e-mail confirmation messages and password recovery message. This is an important feature that was missing in MeshCentral1. MeshInterceptor Support \u2013 MeshCentral can insert HTTP and Intel AMT redirection credential into a live data stream. This is useful to allow an administrator to securely pass Intel AMT password and control over an Intel AMT computer via web browser without the additional administrator login UI. It\u2019s possible to perform migration to MeshCentral from MeshCentral1 server using a migration package. The MeshCentral Migration Tool will convert your existing user database into a format that can be imported into MeshCentral. In addition to the migration tool, MeshCentral has a special module that will update all MeshAgents from v1 to v2 so the transition should be simple.","title":"Improvements to MeshCentral"},{"location":"meshcentral/#additional-resources","text":"In addition to this document, there are a growing set of MeshCentral tutorial videos available on YouTube which covers all of the basic at www.meshcommander.com/meshcentral2/tutorials. The tutorial includes videos on how to perform server installation using both the Windows MSI installer and NPM methods.","title":"Additional Resources"},{"location":"meshcentral/#conclusion","text":"MeshCentral is a free, open source and powerful remote management solution that is cross-platform. In this document, we have covered in detail on how to install and configure MeshCentral server to meet specific environment and use-case. MeshCentral works in many environments and situations. MeshCentral is not only simple to install but also takes minimal resources to host which makes it a very good remote management solution. As with any good software, MeshCentral will continue to be updated and evolve.","title":"Conclusion"},{"location":"meshcentral/#license","text":"MeshCentral and this document are both opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0 .","title":"License"},{"location":"meshcentral/#annex-1-sample-configuration-file","text":"In this annex, we present a complete sample config.json file. You would put this file in the \u201cmeshcentral-data\u201d folder that is created when MeshCentral is first run. The config.json is completely optional and the server will run with default values with it. All key names in this file are case insensitive. { \"settings\" : { \"MongoDb\" : \"mongodb://127.0.0.1:27017/meshcentral\" , \"MongoDbCol\" : \"meshcentral\" , \"Port\" : 4430 , \"AliasPort\" : 443 , \"RedirPort\" : 800 , \"TlsOffload\" : \"127.0.0.1\" , \"MpsPort\" : 44330 , \"MpsAliasPort\" : 4433 , \"MpsTlsOffload\" : true , \"SessionTime\" : 30 , \"SessionKey\" : \"MyReallySecretPassword\" , \"AllowLoginToken\" : true , \"AllowFraming\" : true , \"WebRTC\" : true , \"ClickOnce\" : true }, \"domains\" : { \"\" : { \"Title\" : \"MyServer\" , \"Title2\" : \"Servername\" , \"TitlePicture\" : \"title-sample.png\" , \"UserQuota\" : 1048576 , \"MeshQuota\" : 248576 , \"NewAccounts\" : true , \"Footer\" : \"<a href='https://twitter.com/mytwitter'>Twitter</a>\" , \"PasswordRequirements\" : { \"min\" : 8 , \"max\" : 128 , \"upper\" : 1 , \"lower\" : 1 , \"numeric\" : 1 , \"nonalpha\" : 1 } }, \"customer1\" : { \"Dns\" : \"customer1.myserver.com\" , \"Title\" : \"Customer1\" , \"Title2\" : \"TestServer\" , \"NewAccounts\" : 1 , \"Auth\" : \"sspi\" , \"Footer\" : \"Test\" }, \"info\" : { \"share\" : \"C:\\\\ExtraWebSite\" } }, \"letsencrypt\" : { \"email\" : \"myemail@myserver.com \" , \"names\" : \"myserver.com,customer1.myserver.com\" , \"rsaKeySize\" : 3072 , \"production\" : false }, \"peers\" : { \"serverId\" : \"server1\" , \"servers\" : { \"server1\" : { \"url\" : \"wss://192.168.2.133:443/\" }, \"server2\" : { \"url\" : \"wss://192.168.1.106:443/\" } } }, \"smtp\" : { \"host\" : \"smtp.myserver.com\" , \"port\" : 25 , \"from\" : \"myemail@myserver.com\" , \"tls\" : false } } All these values are examples only, this config.json should just be used as an example and none of the values here are real.","title":"Annex 1: Sample Configuration File"},{"location":"meshcentral/#annex-2-tips-tricks","text":"In this annex, we present various suggestions. These are often found by users on the GitHub community and readers are encouraged to participate. The GitHub community is at: https://github.com/Ylianst/MeshCentral/issues","title":"Annex 2: Tips &amp; Tricks"},{"location":"meshcentral/#remote-terminal","text":"When doing a remote terminal session to a Linux computer, it may be interesting to run the bash shell under a different user. One would typically use the command: su -s /bin/bash myOtherUser However, because bash is not run in interactive mode, the command line prompt may be empty and history keys (up and down), tab and backspace will not work right. The correct command is: su -c '/bin/bash -i' myOtherUser This will run bash in interactive mode and work correctly.","title":"Remote Terminal"},{"location":"meshcentral/#ssh-and-sftp-integration-to-the-terminal","text":"MeshCentral has built-in web-based integration of SSH in the \"Termina\" tab and SFTP in the \"Files\" tab.","title":"SSH and SFTP integration to the Terminal"},{"location":"meshcentral/assistant/","text":"MeshCentral Assistant \u00b6 Initial Setup \u00b6 Agent Invite Code \u00b6 \"domains\" : { \"\" : { \"agentInviteCodes\" : true } } Agent Invitation Link \u00b6 For web page customization: Alongside meshcentral-data create a folder called meshcentral-web Create a views folder in it and copy the file node_modules/meshcentral/views/invite.handlebars into it. That copy will be served instead of the default one, you can customize as you want.","title":"Assistant"},{"location":"meshcentral/assistant/#meshcentral-assistant","text":"","title":"MeshCentral Assistant"},{"location":"meshcentral/assistant/#initial-setup","text":"","title":"Initial Setup"},{"location":"meshcentral/assistant/#agent-invite-code","text":"\"domains\" : { \"\" : { \"agentInviteCodes\" : true } }","title":"Agent Invite Code"},{"location":"meshcentral/assistant/#agent-invitation-link","text":"For web page customization: Alongside meshcentral-data create a folder called meshcentral-web Create a views folder in it and copy the file node_modules/meshcentral/views/invite.handlebars into it. That copy will be served instead of the default one, you can customize as you want.","title":"Agent Invitation Link"},{"location":"meshcentral/codesigning/","text":"Authenticode-JS Video \u00b6 Nodejs Code Signing module MeshCentral comes with authenticode.js, you can run it like this: node node_modules/meshcentral/authenticode-js and you will get MeshCentral Authenticode Tool. Usage: node authenticode.js [command] [options] Commands: info: Show information about an executable. --exe [file] Required executable to view information. --json Show information in JSON format. sign: Sign an executable. --exe [file] Required executable to sign. --out [file] Resulting signed executable. --pem [pemfile] Certificate & private key to sign the executable with. --desc [description] Description string to embbed into signature. --url [url] URL to embbed into signature. --hash [method] Default is SHA384, possible value: MD5, SHA224, SHA256, SHA384 or SHA512. --time [url] The time signing server URL. --proxy [url] The HTTP proxy to use to contact the time signing server, must start with http:// unsign: Remove the signature from the executable. --exe [file] Required executable to un-sign. --out [file] Resulting executable with signature removed. createcert: Create a code signging self-signed certificate and key. --out [pemfile] Required certificate file to create. --cn [value] Required certificate common name. --country [value] Certificate country name. --state [value] Certificate state name. --locality [value] Certificate locality name. --org [value] Certificate organization name. --ou [value] Certificate organization unit name. --serial [value] Certificate serial number. timestamp: Add a signed timestamp to an already signed executable. --exe [file] Required executable to sign. --out [file] Resulting signed executable. --time [url] The time signing server URL. --proxy [url] The HTTP proxy to use to contact the time signing server, must start with http:// Note that certificate PEM files must first have the signing certificate, followed by all certificates that form the trust chain. When doing sign/unsign, you can also change resource properties of the generated file. --filedescription [value] --fileversion [value] --internalname [value] --legalcopyright [value] --originalfilename [value] --productname [value] --productversion [value] Automatic Agent Code Signing \u00b6 If you want to self-sign the mesh agent so you can whitelist the software in your AV, and lock it to your server and organization. Note If you generate your private key on windows with use BEGIN PRIVATE KEY and openssl needs BEGIN RSA PRIVATE KEY you can convert your private key to rsa private key using openssl rsa -in server.key -out server_new.key","title":"Code Signing"},{"location":"meshcentral/codesigning/#authenticode-js-video","text":"Nodejs Code Signing module MeshCentral comes with authenticode.js, you can run it like this: node node_modules/meshcentral/authenticode-js and you will get MeshCentral Authenticode Tool. Usage: node authenticode.js [command] [options] Commands: info: Show information about an executable. --exe [file] Required executable to view information. --json Show information in JSON format. sign: Sign an executable. --exe [file] Required executable to sign. --out [file] Resulting signed executable. --pem [pemfile] Certificate & private key to sign the executable with. --desc [description] Description string to embbed into signature. --url [url] URL to embbed into signature. --hash [method] Default is SHA384, possible value: MD5, SHA224, SHA256, SHA384 or SHA512. --time [url] The time signing server URL. --proxy [url] The HTTP proxy to use to contact the time signing server, must start with http:// unsign: Remove the signature from the executable. --exe [file] Required executable to un-sign. --out [file] Resulting executable with signature removed. createcert: Create a code signging self-signed certificate and key. --out [pemfile] Required certificate file to create. --cn [value] Required certificate common name. --country [value] Certificate country name. --state [value] Certificate state name. --locality [value] Certificate locality name. --org [value] Certificate organization name. --ou [value] Certificate organization unit name. --serial [value] Certificate serial number. timestamp: Add a signed timestamp to an already signed executable. --exe [file] Required executable to sign. --out [file] Resulting signed executable. --time [url] The time signing server URL. --proxy [url] The HTTP proxy to use to contact the time signing server, must start with http:// Note that certificate PEM files must first have the signing certificate, followed by all certificates that form the trust chain. When doing sign/unsign, you can also change resource properties of the generated file. --filedescription [value] --fileversion [value] --internalname [value] --legalcopyright [value] --originalfilename [value] --productname [value] --productversion [value]","title":"Authenticode-JS Video"},{"location":"meshcentral/codesigning/#automatic-agent-code-signing","text":"If you want to self-sign the mesh agent so you can whitelist the software in your AV, and lock it to your server and organization. Note If you generate your private key on windows with use BEGIN PRIVATE KEY and openssl needs BEGIN RSA PRIVATE KEY you can convert your private key to rsa private key using openssl rsa -in server.key -out server_new.key","title":"Automatic Agent Code Signing"},{"location":"meshcentral/config/","text":"Configuration Options \u00b6 All possible configuration of MeshCentral can be found in this file: https://github.com/Ylianst/MeshCentral/blob/master/meshcentral-config-schema.json See description for information about each item. { \"id\" : \"https://raw.githubusercontent.com/Ylianst/MeshCentral/master/meshcentral-config-schema.json\" , \"$schema\" : \"http://json-schema.org/draft-04/schema#\" , \"description\" : \"MeshCentral configuration file schema\" , \"type\" : \"object\" , \"properties\" : { \"settings\" : { \"type\" : \"object\" , \"properties\" : { \"cert\" : { \"type\" : \"string\" , \"description\" : \"Set this to the primary DNS name of this MeshCentral server.\" }, \"mongoDb\" : { \"type\" : \"string\" , \"default\" : null }, \"mongoDbName\" : { \"type\" : \"string\" }, \"mongoDbChangeStream\" : { \"type\" : \"boolean\" , \"default\" : false }, \"mongoDbBulkOperations\" : { \"type\" : \"boolean\" , \"default\" : false }, \"mariaDB\" : { \"type\" : \"object\" , \"description\" : \"Add this section to connect MeshCentral to a MariaDB database instance.\" , \"properties\" : { \"host\" : { \"type\" : \"string\" , \"description\" : \"MariaDB hostname\" }, \"user\" : { \"type\" : \"string\" , \"description\" : \"MariaDB username\" }, \"port\" : { \"type\" : \"number\" , \"description\" : \"MariaDB port number\" }, \"password\" : { \"type\" : \"string\" , \"description\" : \"MariaDB password\" }, \"connectionLimit\" : { \"type\" : \"number\" , \"description\" : \"MariaDB connection limit\" }, \"database\" : { \"type\" : \"string\" , \"default\" : \"meshcentral\" , \"description\" : \"Name of MariaDB database used\" }, \"awsrds\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Set true to resolve LOCK TABLE permissions on AWS RDS.\" }, \"ssl\" : { \"type\" : \"object\" , \"description\" : \"SSL Options. Set to true (boolean) for default options.\" , \"properties\" : { \"caCertPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the CA certificate. Required for self-signed certificates\" }, \"clientCertPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the client certificate. Required for two-way SSL Authentication\" }, \"clientKeyPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the client key. Required for two-way SSL Authentication\" }, \"dontCheckServerIdentity\" : { \"type\" : \"boolean\" , \"description\" : \"Set true to not check the server hostname during verification\" } } } } }, \"mySQL\" : { \"type\" : \"object\" , \"description\" : \"Add this section to connect MeshCentral to a MySQL database instance.\" , \"properties\" : { \"host\" : { \"type\" : \"string\" , \"description\" : \"MySQL hostname\" }, \"port\" : { \"type\" : \"number\" , \"description\" : \"MySQL port number\" }, \"user\" : { \"type\" : \"string\" , \"description\" : \"MySQL username\" }, \"password\" : { \"type\" : \"string\" , \"description\" : \"MySQL password\" }, \"database\" : { \"type\" : \"string\" , \"default\" : \"meshcentral\" , \"description\" : \"Name of MySQL database used\" }, \"awsrds\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Set true to resolve LOCK TABLE permissions on AWS RDS.\" }, \"ssl\" : { \"type\" : \"object\" , \"description\" : \"SSL Options. Set to true (boolean) for default options.\" , \"properties\" : { \"caCertPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the CA certificate. Required for self-signed certificates\" }, \"clientCertPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the client certificate. Required for two-way SSL Authentication\" }, \"clientKeyPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the client key. Required for two-way SSL Authentication\" }, \"dontCheckServerIdentity\" : { \"type\" : \"boolean\" , \"description\" : \"Set true to not check the server hostname during verification\" } } } } }, \"postgres\" : { \"type\" : \"object\" , \"description\" : \"Add this section to connect MeshCentral to a PostgreSQL database instance.\" , \"properties\" : { \"host\" : { \"type\" : \"string\" , \"description\" : \"PostgreSQL hostname\" }, \"user\" : { \"type\" : \"string\" , \"description\" : \"PostgreSQL username\" }, \"port\" : { \"type\" : \"number\" , \"description\" : \"PostgreSQL port number\" }, \"password\" : { \"type\" : \"string\" , \"description\" : \"PostgreSQL password\" }, \"database\" : { \"type\" : \"string\" , \"default\" : \"meshcentral\" , \"description\" : \"Name of PostgreSQL database used\" } } }, \"WANonly\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, only MeshCentral WAN features are enabled and agents will connect to the server using a well known DNS name.\" }, \"LANonly\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, only MeshCentral LAN features are enabled and agents will find the server using multicast LAN packets.\" }, \"maintenanceMode\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled the server is in maintenance mode, only administrators can login. Use the maintenance command in server console to change.\" }, \"certificatePrivateKeyPassword\" : { \"type\" : \"array\" , \"default\" : null , \"description\" : \"List of passwords used to decrypt PKCK#8 .key files that are in the meshcentral-data folder.\" }, \"sessionTime\" : { \"type\" : \"integer\" , \"default\" : 60 , \"description\" : \"Duration of a session cookie in minutes. Changing this affects how often the session needs to be automatically refreshed.\" }, \"sessionKey\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Password used to encrypt the MeshCentral web session cookies. If null, a random one is generated each time the server starts.\" }, \"sessionSameSite\" : { \"type\" : \"string\" , \"default\" : \"lax\" , \"enum\" : [ \"strict\" , \"lax\" , \"none\" ] }, \"dbEncryptKey\" : { \"type\" : \"string\" }, \"dbRecordsEncryptKey\" : { \"type\" : \"string\" , \"default\" : null }, \"dbRecordsDecryptKey\" : { \"type\" : \"string\" , \"default\" : null }, \"dbExpire\" : { \"type\" : \"object\" , \"properties\" : { \"events\" : { \"type\" : \"integer\" , \"default\" : 1728000 , \"description\" : \"Amount of time in seconds that events are kept in the database.\" }, \"powerevents\" : { \"type\" : \"integer\" , \"default\" : 864000 , \"description\" : \"Amount of time in seconds that device power events are kept in the database.\" }, \"statsevents\" : { \"type\" : \"integer\" , \"default\" : 2592000 , \"description\" : \"Amount of time in seconds that server statistics are kept in the database.\" } } }, \"port\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"default\" : 443 , \"description\" : \"Ths port of the main HTTPS server.\" }, \"portBind\" : { \"type\" : \"string\" , \"description\" : \"When set, bind the HTTPS main port to a specific network address.\" }, \"aliasPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"default\" : null , \"description\" : \"The actual main port as seen externally on the Internet, this setting is often used when a reverse-proxy is used.\" }, \"redirPort\" : { \"type\" : \"integer\" , \"minimum\" : 0 , \"maximum\" : 65535 , \"default\" : 80 , \"description\" : \"This is a HTTP web server port that mostly redirects users to the HTTPS port but does provide some other servces, 0 will turn this port off.\" }, \"redirPortBind\" : { \"type\" : \"string\" , \"description\" : \"When set, bind the HTTP redirection port to a specific network address.\" }, \"redirAliasPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"description\" : \"The actual redirection port as seen externally on the Internet, this setting is often used when a reverse-proxy is used.\" }, \"relayPort\" : { \"type\" : \"integer\" , \"minimum\" : 0 , \"maximum\" : 65535 , \"default\" : 0 , \"description\" : \"When set, a web relay web server is bound to this port and will allow user access to remote web sites.\" }, \"relayAliasPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"default\" : null , \"description\" : \"The actual relay port as seen externally on the Internet, this setting is often used when a reverse-proxy is used.\" }, \"relayDNS\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"When set, relayPort valie is ignored. Set this to a DNS name the points to this server. When the server is accessed using the DNS name, the main web server port is used as a web relay port.\" }, \"agentPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"description\" : \"When set, enabled a new HTTPS server port that only accepts agent connections.\" }, \"agentPortBind\" : { \"type\" : \"string\" , \"description\" : \"When set, binds the agent port to a specific network interface.\" }, \"agentAliasPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"description\" : \"When set, indicates the actual publically visible agent-only port. If not set, the AgentPort value is used.\" }, \"agentAliasDNS\" : { \"type\" : \"string\" , \"format\" : \"hostname\" , \"description\" : \"When set, specified the DNS name used by agents to connect to the agent-only port.\" }, \"agentPortTls\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Indicates if the agent-only port must perform TLS, this should be set to false if TLS is performed in front of this server.\" }, \"agentLogDump\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Automatically downloads all agent error logs into meshcentral-data/agenterrorlogs.txt.\" }, \"agentCoreDump\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Automatically activates and transfers any agent crash dump files to the server in meshcentral-data/coredumps.\" }, \"agentCoreDumpUsers\" : { \"type\" : \"array\" , \"description\" : \"List of non-administrator users that have access to mesh agent crash dumps.\" }, \"agentSignLock\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When code signing an agent using authenticode, lock the agent to only allow connection to this server. (This is in testing, the default value will change to true in the future).\" }, \"agentTimeStampServer\" : { \"type\" : [ \"boolean\" , \"string\" ], \"default\" : \"http://timestamp.comodoca.com/authenticode\" , \"description\" : \"The time stamping server to use when code signing Windows executables. When set to false, the executables are not time stamped.\" }, \"agentTimeStampProxy\" : { \"type\" : [ \"boolean\" , \"string\" ], \"description\" : \"The HTTP proxy to use when contacting the time stamping server, if false, no proxy is used. By default, the npmproxy value is used.\" }, \"ignoreAgentHashCheck\" : { \"type\" : [ \"boolean\" , \"string\" ], \"default\" : false , \"description\" : \"When true, the agent no longer checked the TLS certificate of the server. This should be used for debugging only. You can also set this to a comma seperated list of IP addresses to ignore, for example: \\\"192.168.2.100,192.168.1.0/24\\\".\" }, \"exactPorts\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, MeshCentral will only grab the required TCP listening ports or fail. It will not try to use the next available port of it's busy.\" }, \"allowLoginToken\" : { \"type\" : \"boolean\" , \"default\" : false }, \"StrictTransportSecurity\" : { \"type\" : [ \"boolean\" , \"string\" ], \"default\" : null , \"description\" : \"Controls the Strict-Transport-Security header, default is 1 year. Set to false to remove, true to force enable, or string to set a custom value. If set to null, MeshCentral will enable if a trusted certificate is set.\" }, \"allowFraming\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, the MeshCentral web site can be embedded within another website's iframe.\" }, \"cookieIpCheck\" : { \"type\" : [ \"string\" , \"boolean\" ], \"default\" : \"lax\" , \"enum\" : [ \"strict\" , \"lax\" , \"none\" ] }, \"cookieEncoding\" : { \"type\" : \"string\" , \"enum\" : [ \"hex\" , \"base64\" ], \"default\" : \"base64\" , \"description\" : \"Encoding format of cookies in the HTTP headers, this is typically Base64 but some reverse proxies will require HEX.\" }, \"webRTC\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, allows use of WebRTC to allow direct network traffic between the agent and browser.\" }, \"nice404\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"By default, a nice looking 404 error page is displayed when needed. Set this to false to disable it.\" }, \"selfUpdate\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When true, this server will attempt to self-update everyday after midnight.\" }, \"cleanNpmCacheOnUpdate\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When true, run \\\"npm cache clean --force\\\" to reclame disk space.\" }, \"browserPing\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"description\" : \"When specified, sends data to the browser at x seconds interval and expects a response from the browser.\" }, \"browserPong\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"description\" : \"When specified, sends data to the browser at x seconds interval.\" }, \"agentsInRam\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Loads all agent binaries in RAM for faster agent updates.\" }, \"agentPing\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"description\" : \"When specified, sends data to the agent at x seconds interval and expects a response from the agent.\" }, \"agentPong\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"description\" : \"When specified, sends data to the agent at x seconds interval.\" }, \"amtManager\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When enabled, MeshCentral will automatically monitor and manage Intel AMT devices.\" }, \"orphanAgentUser\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"If an agent attempts to connect to a unknown device group, automatically create a new device group and grant access to the specified user. Example: admin\" }, \"agentIdleTimeout\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"default\" : 150 , \"description\" : \"How much time in seconds with no traffic from an agent before dropping the agent connection.\" }, \"webPageLengthRandomization\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Adds a random length string to generated web pages to mitigate a BREACH attack.\" }, \"compression\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Enables GZIP compression for web requests.\" }, \"wsCompression\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enables server-side, websocket per-message deflate compression.\" }, \"agentWsCompression\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Enables agent-side, websocket per-message deflate compression. wscompression must also be true for this to work.\" }, \"noAgentUpdate\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"Set to 1 to present the server from updating any agent.\" }, \"agentUpdateSystem\" : { \"type\" : \"integer\" , \"default\" : 1 , \"description\" : \"When set to 2, all agents that need to be updated will use the meshcore.js update system. With the default value of 1, the native update system is used.\" }, \"temporaryAgentUpdate\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to not allow temporary agents to be updated.\" }, \"amtScanner\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable Intel AMT scanning on the local network, this is already disabled in WAN mode.\" }, \"meshScanner\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable agent multicast scanning on the local network, this is already disabled in WAN mode.\" }, \"meshErrorLogPath\" : { \"type\" : \"string\" }, \"npmPath\" : { \"type\" : \"string\" }, \"npmProxy\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"allowHighQualityDesktop\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When false, users will only be able to set remote desktop image quality to 60%, this can reduce server bandwidth usage.\" }, \"webPush\" : { \"type\" : \"object\" , \"description\" : \"When set with a valid email address, enables the MeshCentral web push notification feature. Allows administrators to send browser notifications to users even if they are not looking at the MeshCentral web site.\" , \"additionalProperties\" : false , \"properties\" : { \"email\" : { \"type\" : \"string\" , \"description\" : \"Server administrator email given to the FireFox and Chrome push notification services.\" } }, \"required\" : [ \"email\" ] }, \"RunOnServerStarted\" : { \"type\" : \"boolean\" , \"default\" : null , \"description\" : \"Execute this when the server startup is completed. The first parameter will be the server version.\" }, \"RunOnServerUpdated\" : { \"type\" : \"boolean\" , \"default\" : null , \"description\" : \"Execute this when the server has been updated. The first parameter will be the server version.\" }, \"RunOnServerError\" : { \"type\" : \"boolean\" , \"default\" : null , \"description\" : \"Execute this when the server has to restart due to an error. The first parameter will be the server version.\" }, \"publicPushNotifications\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When true, this server uses MeshCentral.com a push notification relay for Android notifications. Push notifications work even if the Android app is not open.\" }, \"desktopMultiplex\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When true, enabled a server modules that efficiently splits a remote desktop stream to multiple browsers. Also allows slow browsers to not slow down the session for fast ones, this comes at the cost of extra server memory and processing for all remote desktop sessions.\" }, \"ipBlockedUserRedirect\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"If set, a user from a banned IP address will be redirected to this URL.\" }, \"userAllowedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, only users from allowed IP address ranges can connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"userBlockedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, users from these denied IP address ranges will not be able to connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"agentAllowedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, only agents from allowed IP address ranges can connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"agentBlockedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, agents from these denied IP address ranges will not be able to connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"authLog\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"File path and name of the authentication log to be created. This log can be parsed by Fail2ban.\" }, \"InterUserMessaging\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" }, \"description\" : \"Users in this list are allowed to send and receive inter-user messages. This can be used to implement bots or other software where MeshCentral is used as data transport. See \\\"interuser\\\" websocket command in the code.\" }, \"manageAllDeviceGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" }, \"description\" : \"Users in this list are allowed to see and manage all device groups within their domain.\" }, \"manageCrossDomain\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" }, \"description\" : \"Users in this list are allowed to manage all users in all domains.\" }, \"localDiscovery\" : { \"type\" : \"object\" , \"description\" : \"When this server is in LAN mode, you may discover this server using a multicast discovery tool. When discovery happens, the name and info fields are sent back to the discovery tool.\" , \"additionalProperties\" : false , \"properties\" : { \"name\" : { \"type\" : \"string\" }, \"info\" : { \"type\" : \"string\" }, \"key\" : { \"type\" : \"string\" , \"description\" : \"When set, encrypts all LAN discovery traffic to agents and tools using this key. This is only useful in LAN/Hybrid mode when agents and tools user multicast to find the server.\" } }, \"required\" : [ \"name\" , \"info\" ] }, \"tlsOffload\" : { \"type\" : [ \"boolean\" , \"string\" ], \"default\" : false , \"description\" : \"When true, indicates that a TLS offloader is in front of the MeshCentral server. More typically, set this to the IP address of the reverse proxy or TLS offloader so that IP forwarding headers will be trusted. For example: \\\"127.0.0.1,192.168.1.100\\\".\" }, \"trustedProxy\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Trust forwarded headers from these IPs or domains. Providing the magic string \\\"CloudFlare\\\" will cause the server to download the IP address list of trusted CloudFlare proxies directly from CloudFlare on each server start. For example: \\\"127.0.0.1,proxy.example.com,CloudFlare\\\".\" }, \"mpsPort\" : { \"type\" : \"integer\" , \"minimum\" : 0 , \"maximum\" : 65535 , \"default\" : 4433 , \"description\" : \"The Management Presence Server (MPS), this is the server that received Intel AMT Client Initiated Remote Access (CIRA) connections.\" }, \"mpsPortBind\" : { \"type\" : \"string\" , \"default\" : null }, \"mpsAliasPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"default\" : null }, \"mpsAliasHost\" : { \"type\" : \"string\" , \"default\" : null }, \"mpsTlsOffload\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, indicate that TLS is being performed by a device in front of MeshCentral.\" }, \"mpsHighSecurity\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, the MPS server will only accept TLS 1.2 and 1.3 connections. Older Intel AMT devices will not be able to connect.\" }, \"no2FactorAuth\" : { \"type\" : \"boolean\" , \"default\" : false }, \"log\" : { \"type\" : \"string\" , \"default\" : null }, \"syslog\" : { \"type\" : \"string\" , \"default\" : null }, \"syslogauth\" : { \"type\" : \"string\" , \"default\" : null }, \"syslogjson\" : { \"type\" : \"string\" , \"default\" : null }, \"syslogtcp\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Send syslog events over the network (RFC3164) to a target hostname:port. For example: localhost:514\" }, \"webrtcConfig\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"The STUN servers used for WebRTC, if not specified the Google and Mozilla servers and used when the server is not in LAN mode.\" , \"properties\" : { \"iceServers\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"urls\" : { \"type\" : \"string\" } }, \"required\" : [ \"urls\" ] } } }, \"required\" : [ \"iceServers\" ] }, \"autoBackup\" : { \"type\" : \"object\" , \"properties\" : { \"mongoDumpPath\" : { \"type\" : \"string\" }, \"mysqlDumpPath\" : { \"type\" : \"string\" }, \"backupIntervalHours\" : { \"type\" : \"integer\" }, \"keepLastDaysBackup\" : { \"type\" : \"integer\" }, \"zipPassword\" : { \"type\" : \"string\" }, \"backupPath\" : { \"type\" : \"string\" }, \"googleDrive\" : { \"type\" : \"object\" , \"description\" : \"Enabled automated upload of the server backups to a Google Drive account, once enabled you need to go in \\\"My Server\\\" tab as administrator to associate the account.\" , \"properties\" : { \"folderName\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral-Backups\" , \"description\" : \"The name of the folder to create in the Google Drive account.\" }, \"maxFiles\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"The maximum number of files to keep in the Google Drive folder, older files will be removed if needed.\" } } }, \"webDAV\" : { \"type\" : \"object\" , \"description\" : \"Enabled automated upload of the server backups to a WebDAV account.\" , \"properties\" : { \"url\" : { \"type\" : \"string\" , \"description\" : \"WebDAV account URL.\" }, \"username\" : { \"type\" : \"string\" , \"description\" : \"WebDAV account username.\" }, \"password\" : { \"type\" : \"string\" , \"description\" : \"WebDAV account password.\" }, \"folderName\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral-Backups\" , \"description\" : \"The name of the folder to create in the WebDAV account.\" }, \"maxFiles\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"The maximum number of files to keep in the WebDAV folder, older files will be removed if needed.\" } } } } }, \"redirects\" : { \"type\" : \"object\" }, \"maxInvalidLogin\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"This section described a policy for how many times an IP address is allowed to attempt to login incorrectly. By default it's 10 times in 10 minutes, but this can be changed here.\" , \"properties\" : { \"exclude\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Ranges of IP addresses that are not subject to invalid login limitations. For example: 192.168.1.0/24,172.16.0.1\" }, \"time\" : { \"type\" : \"integer\" , \"default\" : 10 , \"description\" : \"Time in minutes over which the a maximum number of invalid login attempts is allowed from an IP address.\" }, \"count\" : { \"type\" : \"integer\" , \"default\" : 10 , \"description\" : \"Maximum number of invalid login attempts from an IP address in the time period.\" }, \"coolofftime\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Additional time in minute that login attempts will be denied once the invalid login limit is reached.\" } } }, \"maxInvalid2fa\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"This section described a policy for how many times an IP address is allowed to attempt to perform two-factor authentication (2FA) incorrectly. By default it's 10 times in 10 minutes, but this can be changed here.\" , \"properties\" : { \"exclude\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Ranges of IP addresses that are not subject to invalid 2FA limitations. For example: 192.168.1.0/24,172.16.0.1\" }, \"time\" : { \"type\" : \"integer\" , \"default\" : 10 , \"description\" : \"Time in minutes over which the a maximum number of invalid 2FA attempts is allowed from an IP address.\" }, \"count\" : { \"type\" : \"integer\" , \"default\" : 10 , \"description\" : \"Maximum number of invalid 2FA attempts from an IP address in the time period.\" }, \"coolofftime\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Additional time in minute that 2FA attempts will be denied once the invalid 2FA limit is reached.\" } } }, \"amtProvisioningServer\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"required\" : [ \"deviceGroup\" , \"newMebxPassword\" , \"trustedFqdn\" , \"ip\" ], \"description\" : \"When present, this section will enable the Intel AMT provisioning server on the local network. This is used for Intel AMT bare-metal ACM activation.\" , \"properties\" : { \"port\" : { \"type\" : \"number\" , \"default\" : 9971 , \"description\" : \"Port number that provisioning server will listen to.\" }, \"deviceGroup\" : { \"type\" : \"string\" , \"description\" : \"The agent-less device group to add Intel AMT devices to once they are activated. Must be of format: mesh/domain/id\" }, \"newMebxPassword\" : { \"type\" : \"string\" , \"description\" : \"The MEBX password to set during activation. This password must be at least 8 characters long and have 1 lower, 1 upper, 1 alpha-numeric and 1 non-alpha numeric character.\" }, \"trustedFqdn\" : { \"type\" : \"string\" , \"description\" : \"The trusted FQDN or provisioning server value the remote device will have. This can be set in MEBx or using the DHCP server option 15 on the local network.\" }, \"ip\" : { \"type\" : \"string\" , \"description\" : \"The IP address of this server. This address will be used when creating the USB setup.bin file to indicate what IP address to send the hello data to.\" } } }, \"plugins\" : { \"type\" : \"object\" , \"properties\" : { \"enabled\" : { \"type\" : \"boolean\" } }, \"required\" : [ \"enabled\" ] } } }, \"domaindefaults\" : { \"$ref\" : \"#/properties/domains/items\" }, \"domains\" : { \"type\" : \"object\" , \"items\" : { \"type\" : \"object\" , \"properties\" : { \"siteStyle\" : { \"type\" : \"integer\" , \"default\" : 2 , \"description\" : \"Valid numbers are 1 and 2, changes the style of the login page and some secondary pages.\" }, \"title\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral\" , \"description\" : \"The title of this web site. All web pages will have this title.\" }, \"title2\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Secondary title text that is placed on the upper right on the title on many web pages.\" }, \"titlePicture\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Web site .png logo file that is 450x66 in size placed in meshcentral-data that is used on the top of many pages.\" }, \"loginPicture\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Web site .png logo file placed in meshcentral-data that used on the login page when sitestyle is 2.\" }, \"rootRedirect\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Redirects HTTP root requests to this URL. When in use, direct users to /login to see the normal login page.\" }, \"mobileSite\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, this setting will disable the mobile site.\" }, \"unknownUserRootRedirect\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Redirects HTTP root requests to this URL only where user is not already logged in. When in use, direct users to /login to see the normal login page.\" }, \"nightMode\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"0 = User selects day/night mode, 1 = Always night mode, 2 = Always day mode\" }, \"userQuota\" : { \"type\" : \"integer\" }, \"meshQuota\" : { \"type\" : \"integer\" }, \"loginKey\" : { \"type\" : [ \"string\" , \"array\" ], \"items\" : { \"type\" : \"string\" }, \"default\" : null , \"description\" : \"Requires that users add the value ?key=xxx in the URL in order to see the web site.\" }, \"agentKey\" : { \"type\" : [ \"string\" , \"array\" ], \"items\" : { \"type\" : \"string\" }, \"default\" : null , \"description\" : \"Requires that agents add the value ?key=xxx in the URL in order to connect. This is not automatic and needs to be manually added in the meshagent.msh file.\" }, \"ipkvm\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Set to true to enable IP KVM device support in this domain.\" }, \"minify\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, the server will send reduced sided web pages.\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, allow new user accounts to be created from the login page.\" }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"userNameIsEmail\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, the username of each account is also the email address of the account.\" }, \"newAccountEmailDomains\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"newAccountsRights\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"welcomeText\" : { \"type\" : \"string\" , \"description\" : \"Text that will be shown on the login screen.\" }, \"welcomePicture\" : { \"type\" : \"string\" , \"description\" : \"Name of the PNG or JPEG file that will be shown on the login screen. Put this file in the meshcentral-data folder and place the file name here.\" }, \"welcomePictureFullScreen\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, the welcomePicture will show as a fullscreen background on the login screen.\" }, \"meshMessengerTitle\" : { \"type\" : \"string\" , \"default\" : \"MeshMessenger\" , \"description\" : \"Text that will be displayed on the top of the messenger window when no username or device name is displayed.\" }, \"meshMessengerPicture\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Name of a .png image file that is placed in meshcentral-data that is displayed on the top of the messenger web page. When null, the default image is displayed.\" }, \"hide\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"Sum of: 1 = Hide header, 2 = Hide tab, 4 = Hide footer, 8 = Hide title, 16 = Hide left bar, 32 = Hide back buttons\" }, \"footer\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"This is a HTML string displayed at the bottom of the web page when a user is logged in.\" }, \"loginfooter\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"This is a HTML string displayed at the bottom of the web page when a user is not logged in.\" }, \"allowSavingDeviceCredentials\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allow users to save SSH, RDP, VNC device credentials on the server that can be used by any other user.\" }, \"guestDeviceSharing\" : { \"type\" : [ \"boolean\" , \"object\" ], \"default\" : true , \"description\" : \"When set to false, the desktop/terminal sharing link feature is not available.\" , \"properties\" : { \"maxSessionTime\" : { \"type\" : \"number\" , \"description\" : \"When set, limits the maximum length of a guest session, in minutes.\" } } }, \"autoRemoveInactiveDevices\" : { \"type\" : \"integer\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 2000 , \"description\" : \"Number of days a device can be inactive before it's removed. 0 disables this feature. Device group setting will override this value.\" }, \"deviceSearchBarServerAndClientName\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, the devices search box will match on both the server name and client name of a device.\" }, \"agentSelfGuestSharing\" : { \"type\" : [ \"boolean\" , \"object\" ], \"default\" : false , \"description\" : \"When set to true, MeshCentral Asssitant can create it's own guest sharing links.\" , \"properties\" : { \"expire\" : { \"type\" : \"number\" , \"description\" : \"When set, limits the self-created guest sharing link to this number of minutes.\" } } }, \"preConfiguredRemoteInput\" : { \"type\" : \"array\" , \"default\" : null , \"description\" : \"When set, you can right click on the input button in the desktop tab and instantly remotely type one of these pre-configured strings.\" , \"items\" : { \"type\" : \"object\" , \"required\" : [ \"name\" , \"value\" ], \"properties\" : { \"name\" : { \"description\" : \"Name of the text string.\" , \"type\" : \"string\" }, \"value\" : { \"description\" : \"Text string that will be remotely typed when selected.\" , \"type\" : \"string\" } } } }, \"altMessenging\" : { \"type\" : \"object\" , \"properties\" : { \"name\" : { \"type\" : \"string\" , \"description\" : \"Name of the alternative messaging service, for example: \\\"Jitsi\\\" \" }, \"url\" : { \"type\" : \"string\" , \"description\" : \"URL to the alternative messaging services, for example: \\\"https://meet.jit.si/myserver-{0}\\\"\" }, \"localurl\" : { \"type\" : \"string\" , \"description\" : \"If specified, this is the URL that is used on the administrator side, for example: \\\"https://meet.jit.si/myserver-{0}\\\"\" } }, \"required\" : [ \"name\" , \"url\" ] }, \"deviceMeshRouterLinks\" : { \"rdp\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Display a RDP link in the device tab when supported.\" }, \"ssh\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Display a SSH link in the device tab when supported.\" }, \"scp\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Display a SCP link in the device tab when supported.\" }, \"extralinks\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"required\" : [ \"name\" , \"protocol\" , \"port\" ], \"properties\" : { \"name\" : { \"description\" : \"Name of the link to be displayed on the web site.\" , \"type\" : \"string\" }, \"protocol\" : { \"description\" : \"Protocol. Valid values are: custom,http,https,rdp,ssh,scp,mcrdesktop,mcrfiles.\" , \"type\" : \"string\" }, \"port\" : { \"description\" : \"The port on the remote device.\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 65535 , \"type\" : \"integer\" }, \"ip\" : { \"description\" : \"Target IP address. If not specified, the target of the connection is the remote device running the MeshAgent.\" , \"type\" : \"string\" }, \"localport\" : { \"description\" : \"The local port MeshCentral Router would bind to. By default, a random available port is used.\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 65535 , \"type\" : \"integer\" }, \"filter\" : { \"description\" : \"Array of node/<domain>/<id> or mesh/<domain>/<id> or tag:<tag> strings. When set, the link will only show up for the specified devices, device groups or device tag.\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } } } } }, \"certUrl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"https url when to get the TLS certificate that MeshAgent's will see when connecting to this server. This setting is used when a reverse proxy like NGINX is used in front of MeshCentral.\" }, \"myServer\" : { \"type\" : [ \"object\" , \"boolean\" ], \"additionalProperties\" : false , \"properties\" : { \"Backup\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to backup the server from the My Server tab. This option can only enabled when the NeDB databse is in use. For other databases, this option disabled and the setting is ignored.\" }, \"Restore\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to restore the server from the My Server tab. This option can only enabled when the NeDB databse is in use. For other databases, this option disabled and the setting is ignored.\" }, \"Upgrade\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to update the server from the My Server tab.\" }, \"ErrorLog\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to see the server crash log the server from the My Server tab.\" }, \"Console\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to access the server console from the My Server tab.\" }, \"Trace\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to access the server trace tab from from the My Server tab.\" } } }, \"passwordRequirements\" : { \"type\" : \"object\" , \"properties\" : { \"min\" : { \"type\" : \"integer\" , \"description\" : \"Minimum number of characters allowed for the account password.\" }, \"max\" : { \"type\" : \"integer\" , \"description\" : \"Maximum number of characters allowed for the account password.\" }, \"upper\" : { \"type\" : \"integer\" , \"description\" : \"Minimum number of upper case characters required in the password.\" }, \"lower\" : { \"type\" : \"integer\" , \"description\" : \"Minimum number of lower case characters required in the password.\" }, \"numeric\" : { \"type\" : \"integer\" , \"description\" : \"Minimum number of numeric characters required in the password.\" }, \"nonalpha\" : { \"type\" : \"integer\" , \"description\" : \"Minimum number of non-alpha-numeric characters required in the password.\" }, \"reset\" : { \"type\" : \"integer\" , \"description\" : \"Number of days after which the user is required to change the account password.\" }, \"email2factor\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable email 2FA.\" }, \"sms2factor\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable SMS 2FA.\" }, \"push2factor\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable push notification 2FA.\" }, \"otp2factor\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable one-time-password 2FA.\" }, \"backupcode2factor\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable 2FA backup codes.\" }, \"single2factorWarning\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable single 2FA warning.\" }, \"lock2factor\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, prevents any changes to 2FA.\" }, \"force2factor\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Requires that all accounts setup 2FA.\" }, \"skip2factor\" : { \"type\" : \"string\" , \"description\" : \"IP addresses where 2FA login is skipped, for example: 127.0.0.1,192.168.2.0/24\" }, \"oldPasswordBan\" : { \"type\" : \"integer\" , \"description\" : \"Number of old passwords the server should remember and not allow the user to switch back to.\" }, \"banCommonPasswords\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Uses WildLeek to block use of the 10000 most commonly used passwords.\" }, \"loginTokens\" : { \"type\" : [ \"boolean\" , \"array\" ], \"default\" : true , \"description\" : \"Allows users to create alternative username/passwords for their account. Set to false to disallow all users, or set to a userid array to only all some users.\" }, \"twoFactorTimeout\" : { \"type\" : \"integer\" , \"default\" : 300 , \"description\" : \"Maximum about of time the to wait for a 2FA token on the login page in seconds.\" }, \"autofido2fa\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"If true and user account has FIDO key setup, 2FA login screen will automatically request FIDO 2FA.\" }, \"maxfidokeys\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of FIDO/YubikeyOTP hardware 2FA keys that can be setup in a user account.\" }, \"allowaccountreset\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"If set to false, the account reset option on the login screen will not be available to users.\" } } }, \"twoFactorCookieDurationDays\" : { \"type\" : \"integer\" , \"default\" : 30 , \"description\" : \"Number of days that a user is allowed to remember this device for when completing 2FA. Set this to 0 to remove this option.\" }, \"auth\" : { \"type\" : \"string\" , \"default\" : null , \"enum\" : [ null , \"sspi\" , \"ldap\" ], \"description\" : \"Type of user authentication to use, this can be SSPI on Windows or LDAP. If not set, username/password is used.\" }, \"ldapUserKey\" : { \"type\" : \"string\" }, \"ldapUserName\" : { \"type\" : \"string\" }, \"ldapUserEmail\" : { \"type\" : \"string\" }, \"ldapUserRealName\" : { \"type\" : \"string\" }, \"ldapUserPhoneNumber\" : { \"type\" : \"string\" }, \"ldapOptions\" : { \"type\" : \"object\" , \"description\" : \"LDAP options passed to ldapauth-fork\" }, \"agentInviteCodes\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enabled a feature where you can set one or more invitation codes in a device group. You can then give a invitation link to users who can use it to download the agent.\" }, \"agentNoProxy\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, all newly installed MeshAgents will be instructed to no use a HTTP/HTTPS proxy even if one is configured on the remote system\" }, \"agentTag\" : { \"type\" : \"object\" , \"description\" : \"This section is used to indicate if parts of the meshagent.tag file should be used to set server-side device properties.\" , \"additionalProperties\" : false , \"properties\" : { \"ServerName\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"Action taken if one of the lines in meshagent.tag contains ~ServerName:name. 0=Ignore, 1=Set.\" }, \"ServerDesc\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"Action taken if one of the lines in meshagent.tag contains ~ServerDesc:desc. 0=Ignore, 1=Set, 2=SetIfEmpty.\" }, \"ServerTags\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"Action taken if one of the lines in meshagent.tag contains ~ServerTags:tag1,tag2,tag3. 0=Ignore, 1=Set, 2=SetIfEmpty, 3=Append.\" } } }, \"geoLocation\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enables the geo-location feature and device location map in the user interface, this feature is not being worked on.\" }, \"novnc\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When enabled, activates the built-in web-based VNC client.\" }, \"mstsc\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, activates the built-in web-based RDP client.\" }, \"ssh\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, activates the built-in web-based SSH client.\" }, \"webEmailsPath\" : { \"type\" : \"string\" , \"description\" : \"Path where to find custom email templates for this domain.\" }, \"customUI\" : { \"type\" : \"object\" }, \"consentMessages\" : { \"type\" : \"object\" , \"description\" : \"This section is used to customize user consent prompts, these show up when asking if a remote session is allowed or not.\" , \"additionalProperties\" : false , \"properties\" : { \"Title\" : { \"type\" : \"string\" }, \"Desktop\" : { \"type\" : \"string\" }, \"Terminal\" : { \"type\" : \"string\" }, \"Files\" : { \"type\" : \"string\" }, \"consentTimeout\" : { \"type\" : \"integer\" , \"default\" : 30 , \"description\" : \"How long in seconds to show the user consent dialog box.\" }, \"autoAcceptOnTimeout\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"If true, user consent is accepted after the timeout.\" } } }, \"notificationMessages\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"This section is user to customize user notifications when a remote desktop, terminal or file session is connected to a remote system.\" , \"properties\" : { \"Title\" : { \"type\" : \"string\" }, \"Desktop\" : { \"type\" : \"string\" }, \"Terminal\" : { \"type\" : \"string\" }, \"Files\" : { \"type\" : \"string\" } } }, \"agentCustomization\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Use this section to customize the agent branding.\" , \"properties\" : { \"displayName\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral Agent\" , \"description\" : \"The name of the agent as displayed to the user.\" }, \"description\" : { \"type\" : \"string\" , \"default\" : \"Mesh Agent background service\" , \"description\" : \"The description of the agent as displayed to the user.\" }, \"companyName\" : { \"type\" : \"string\" , \"default\" : \"Mesh Agent\" , \"description\" : \"This will be used as the path to install the agent, by default this is 'Mesh Agent' in Windows and 'meshagent' in other OS's.\" }, \"serviceName\" : { \"type\" : \"string\" , \"default\" : \"Mesh Agent\" , \"description\" : \"The name of the background service, by default this is 'Mesh Agent' in Windows and 'meshagent' in other OS's but should be set to an all lower case, no space string.\" }, \"installText\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Text string to show in the agent installation dialog box.\" }, \"image\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The filename of a image file in .png format located in meshcentral-data to display in the MeshCentral Agent installation dialog, image should be square and from 64x64 to 200x200.\" }, \"fileName\" : { \"type\" : \"string\" , \"default\" : \"meshagent\" , \"description\" : \"The agent filename.\" }, \"foregroundColor\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Foreground text color, valid values are RBG in format 0,0,0 to 255,255,255 or format #000000 to #FFFFFF.\" }, \"backgroundColor\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Background color, valid values are RBG in format 0,0,0 to 255,255,255 or format #000000 to #FFFFFF.\" } } }, \"agentFileInfo\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Use this section to set resource metadata of the Windows agents prior to signing. In Windows, you can right-click and select properties to view these values.\" , \"properties\" : { \"fileDescription\" : { \"type\" : \"string\" , \"description\" : \"Executable file description.\" }, \"fileVersion\" : { \"type\" : \"string\" , \"description\" : \"Executable file version, generally in the form of 1.2.3.4.\" }, \"internalName\" : { \"type\" : \"string\" , \"description\" : \"Executable internal name.\" }, \"legalCopyright\" : { \"type\" : \"string\" , \"description\" : \"Executable legal copyright.\" }, \"originalFilename\" : { \"type\" : \"string\" , \"description\" : \"Executable original file name.\" }, \"productName\" : { \"type\" : \"string\" , \"description\" : \"Executable product name.\" }, \"productVersion\" : { \"type\" : \"string\" , \"description\" : \"Executable product version, generally in the form of 1.2.3.4.\" } } }, \"assistantCustomization\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Use this section to customize the MeshCentral Assistant.\" , \"properties\" : { \"title\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral Assistant\" , \"description\" : \"Name to show as MeshCentral Assistant dialog title.\" }, \"image\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The filename of a image file in .png format located in meshcentral-data to display in MeshCentral Assistant, image should be square and from 64x64 to 128x128.\" }, \"fileName\" : { \"type\" : \"string\" , \"default\" : \"meshagent\" , \"description\" : \"The MeshCentral Assistant filename.\" } } }, \"androidCustomization\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Use this section to customize the MeshCentral Agent for Android.\" , \"properties\" : { \"title\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral Agent\" , \"description\" : \"Displayed on top of the MeshCentral Agent for Android.\" }, \"subtitle\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Subtitle displayed until the title on the toolbar.\" }, \"image\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The filename of a image file in .png format located in meshcentral-data to display in MeshCentral Agent for Android, image should be square and from 64x64 to 128x128.\" } } }, \"ipBlockedUserRedirect\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"If set, a user from a banned IP address will be redirected to this URL.\" }, \"userRequiredHttpHeader\" : { \"type\" : \"object\" , \"default\" : null , \"description\" : \"When set, requires that a browser request have set HTTP header to allow user login. Example: \\\"{ \\\"Sec-Fetch-Dest\\\": \\\"iframe\\\" }\\\"\" }, \"userAllowedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, only users from allowed IP address ranges can connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"userBlockedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, users from these denied IP address ranges will not be able to connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"agentAllowedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, only agents from allowed IP address ranges can connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"agentBlockedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, agents from these denied IP address ranges will not be able to connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"userSessionIdleTimeout\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"When set, idle users will be disconnected after a set amounts of minutes.\" }, \"userConsentFlags\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Use this section to require user consent for this domain.\" , \"properties\" : { \"desktopnotify\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable desktop notification for this domain.\" }, \"terminalnotify\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable terminal notification for this domain.\" }, \"filenotify\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable files notification for this domain.\" }, \"desktopprompt\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable desktop prompt for this domain.\" }, \"terminalprompt\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable terminal user prompt for this domain.\" }, \"fileprompt\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable files prompt for this domain.\" }, \"desktopprivacybar\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable remote desktop privacy bar for this domain.\" } } }, \"urlSwitching\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When users navigate thru the web interface, the URL on top will change to point to the current screen. This allows a user to refresh or bookmark the URL and come back to the correct screen. Setting false here will disable this feature.\" }, \"desktopPrivacyBarText\" : { \"type\" : \"string\" , \"description\" : \"This is the text that will be shown in the remote desktop privacy bar. You can use {0} to display the account realname or {1} to display the account identifier in the string.\" }, \"limits\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"MaxDevices\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of devices in this domain.\" }, \"MaxUserAccounts\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of devices in this domain.\" }, \"MaxUserSessions\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of user sessions that can connect to this server for this domain.\" }, \"MaxAgentSessions\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of agents that can connect to this server for this domain.\" }, \"MaxSingleUserSessions\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of sessions a single user can have. Each time a user opens a new browser tab or opens a new browser on a different computer, a new user session is created.\" } } }, \"terminal\" : { \"type\" : \"object\" , \"description\" : \"Values that affect the terminal feature\" , \"properties\" : { \"linuxShell\" : { \"type\" : \"string\" , \"enum\" : [ \"any\" , \"root\" , \"user\" , \"login\" ], \"default\" : \"any\" , \"description\" : \"Indicate what terminal options are available when the user clicks the right mouse button on the terminal connect button.\" }, \"launchCommand\" : { \"type\" : \"object\" , \"description\" : \"Indicate what string the agent must write to the shell after starting a terminal session\" , \"linux\" : { \"type\" : \"string\" , \"default\" : \" alias ls=\\\\'ls --color=auto\\\\';clear\\\\n\" , \"description\" : \"String to write after opening a Linux terminal.\" }, \"darwin\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"String to write after opening a macOS terminal.\" }, \"freebsd\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"String to write after opening a FreeBSD terminal.\" } } } }, \"desktop\" : { \"type\" : \"object\" , \"description\" : \"Values that affect the remote desktop feature\" , \"properties\" : { \"viewonly\" : { \"type\" : \"boolean\" , \"description\" : \"When set to true, the remote desktop feature is view only.\" , \"default\" : \"false\" } } }, \"amtScanOptions\" : { \"description\" : \"List of local network Intel AMT scanning options offered in the user interface. For example [\\\"LabNetwork 192.168.15.0/23\\\", \\\"SalesNetwork 192.168.8.0/24\\\"].\" , \"type\" : \"array\" , \"default\" : null , \"items\" : { \"type\" : \"string\" } }, \"amtManager\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Information passed to the AMT manager module that impacts all Intel AMT device managed within this domain.\" , \"properties\" : { \"TlsConnections\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, MeshCentral will use TLS to connect to Intel AMT, this is not recommanded.\" }, \"TlsAcmActivation\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to false, MeshCentral will not attempt a TLS ACM activation on Intel AMT v14+\" }, \"AdminAccounts\" : { \"description\" : \"List of username and passwords to try when connecting to Intel AMT.\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"required\" : [ \"pass\" ], \"properties\" : { \"user\" : { \"description\" : \"Intel AMT administrator username.\" , \"type\" : \"string\" , \"default\" : \"admin\" }, \"pass\" : { \"description\" : \"Intel AMT administrator password.\" , \"type\" : \"string\" } } } }, \"EnvironmentDetection\" : { \"description\" : \"List of up to 4 domain suffixes to configure in Intel AMT when activating CIRA.\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" , \"minItems\" : 1 , \"maxItems\" : 4 , \"uniqueItems\" : true } }, \"TlsRootCert\" : { \"description\" : \"Specifies a certificate and private key to use to issue Intel AMT TLS certificates. By default the MeshCentral self-signed root certificate is used.\" , \"type\" : \"object\" , \"properties\" : { \"certpfx\" : { \"description\" : \"Name of the certificate file that is in .p12 or .pfx format in meshcentral-data, use this with certpfxpass.\" , \"type\" : \"string\" }, \"certpfxpass\" : { \"description\" : \"Password for the file specified in certpfx.\" , \"type\" : \"string\" }, \"certfile\" : { \"description\" : \"Name of the certificate file in PEM format located in meshcentral-data. Using this with keyfile.\" , \"type\" : \"string\" }, \"keyfile\" : { \"description\" : \"Name of the private key file in PEM format located in meshcentral-data. Using this with certfile.\" , \"type\" : \"string\" } } }, \"WifiProfiles\" : { \"description\" : \"List of WIFI profiles to setup in any managed Intel AMT device with a WIFI network interface.\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"required\" : [ \"ssid\" ], \"properties\" : { \"name\" : { \"description\" : \"WIFI profile name, if not specified the SSID is used.\" , \"type\" : \"string\" }, \"ssid\" : { \"description\" : \"SSID of the WIFI station.\" , \"type\" : \"string\" }, \"authentication\" : { \"description\" : \"WIFI authentication.\" , \"type\" : \"string\" , \"enum\" : [ \"wpa-psk\" , \"wpa2-psk\" , \"wpa-8021x\" , \"wpa2-802.1x\" , \"wpa3-sae-802.1x\" , \"wpa3-owe-802.1x\" ], \"default\" : \"wpa2-psk\" }, \"encryption\" : { \"description\" : \"WIFI encryption.\" , \"type\" : \"string\" , \"enum\" : [ \"ccmp-aes\" , \"tkip-rc4\" ], \"default\" : \"ccmp-aes\" }, \"password\" : { \"description\" : \"Password on the WIFI station\" , \"type\" : \"string\" , \"minLength\" : 8 , \"maxLength\" : 63 }, \"802.1x\" : { \"description\" : \"802.1x settings for this WIFI profile. Only required if the WIFI authentication type has 802.1x\" , \"default\" : null , \"type\" : \"object\" , \"additionalProperties\" : false , \"required\" : [ \"authenticationProtocol\" ], \"properties\" : { \"authenticationProtocol\" : { \"description\" : \"Identifies the authentication protocol used to authenticate the access requestor to the AAA server.\" , \"type\" : [ \"integer\" , \"string\" ], \"enum\" : [ \"EAP-TLS\" , \"EAP-TTLS/MSCHAPv2\" , \"PEAPv0/EAP-MSCHAPv2\" , \"PEAPv1/EAP-GTC\" , \"EAP-FAST/MSCHAPv2\" , \"EAP-FAST/GTC\" , \"EAP-MD5\" , \"EAP-PSK\" , \"EAP-SIM\" , \"EAP-AKA\" , \"EAP-FAST/TLS\" , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] }, \"serverCertificateNameComparison\" : { \"type\" : [ \"integer\" , \"string\" ], \"default\" : \"FullName\" , \"description\" : \"Determines the comparison algorithm used between the ServerCertificateName value and the subject name field of the certificate presented by the AAA server.\" , \"enum\" : [ \"FullName\" , \"DomainSuffix\" , 2 , 3 ] }, \"serverCertificateName\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The name compared against the subject name field in the certificate provided by the AAA server.\" , \"maxLength\" : 80 }, \"availableInS0\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Indicates the activity setting of the 802.1X module in H0 state\" }, \"protectedAccessCredentialHex\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"A credential used by the supplicant and AAA server to establish a mutually authenticated encrypted tunnel for confidential user authentication.\" , \"maxLength\" : 64 }, \"pacPassword\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Optional password to extract the PAC (Protected Access Credential) information from the PAC data.\" , \"maxLength\" : 256 }, \"domain\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The domain within which Username is unique.\" , \"maxLength\" : 128 }, \"username\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Within the domain specified by Domain, Identifies the user that is requesting access to the network.\" , \"maxLength\" : 128 }, \"password\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The password associated with the user identified by Username and Domain.\" , \"maxLength\" : 32 }, \"roamingIdentity\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"A string presented to the authentication server in 802.1x protocol exchange\" , \"maxLength\" : 80 }, \"pxeTimeoutInSeconds\" : { \"type\" : \"integer\" , \"default\" : 120 , \"description\" : \"Timeout in seconds, in which the Intel(R) AMT will hold an authenticated 802.1X session.\" } } } } } }, \"802.1x\" : { \"description\" : \"802.1x settings for the Intel AMT Wired interface. If set to false, any existing 802.1x wired profile will be removed from Intel AMT.\" , \"default\" : null , \"type\" : [ \"object\" , \"boolean\" ], \"additionalProperties\" : false , \"required\" : [ \"authenticationProtocol\" ], \"properties\" : { \"authenticationProtocol\" : { \"description\" : \"Identifies the authentication protocol used to authenticate the access requestor to the AAA server.\" , \"type\" : [ \"integer\" , \"string\" ], \"enum\" : [ \"EAP-TLS\" , \"EAP-TTLS/MSCHAPv2\" , \"PEAPv0/EAP-MSCHAPv2\" , \"PEAPv1/EAP-GTC\" , \"EAP-FAST/MSCHAPv2\" , \"EAP-FAST/GTC\" , \"EAP-MD5\" , \"EAP-PSK\" , \"EAP-SIM\" , \"EAP-AKA\" , \"EAP-FAST/TLS\" , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] }, \"serverCertificateNameComparison\" : { \"type\" : [ \"integer\" , \"string\" ], \"description\" : \"Determines the comparison algorithm used between the ServerCertificateName value and the subject name field of the certificate presented by the AAA server.\" , \"enum\" : [ \"FullName\" , \"DomainSuffix\" , 2 , 3 ] }, \"serverCertificateName\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The name compared against the subject name field in the certificate provided by the AAA server.\" , \"maxLength\" : 80 }, \"availableInS0\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Indicates the activity setting of the 802.1X module in H0 state\" }, \"protectedAccessCredentialHex\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"A credential used by the supplicant and AAA server to establish a mutually authenticated encrypted tunnel for confidential user authentication.\" , \"maxLength\" : 64 }, \"pacPassword\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Optional password to extract the PAC (Protected Access Credential) information from the PAC data.\" , \"maxLength\" : 256 }, \"domain\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The domain within which Username is unique.\" , \"maxLength\" : 128 }, \"username\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Within the domain specified by Domain, Identifies the user that is requesting access to the network.\" , \"maxLength\" : 128 }, \"password\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The password associated with the user identified by Username and Domain.\" , \"maxLength\" : 32 }, \"roamingIdentity\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"A string presented to the authentication server in 802.1x protocol exchange\" , \"maxLength\" : 80 }, \"pxeTimeoutInSeconds\" : { \"type\" : \"integer\" , \"default\" : 120 , \"description\" : \"Timeout in seconds, in which the Intel(R) AMT will hold an authenticated 802.1X session.\" } } } } }, \"amtAcmActivation\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"log\" : { \"type\" : \"string\" }, \"certs\" : { \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"certfiles\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"keyfile\" : { \"type\" : \"string\" } }, \"required\" : [ \"certfiles\" , \"keyfile\" ] } } }, \"required\" : [ \"certs\" ] }, \"redirects\" : { \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" }, \"description\" : \"This is used to create HTTP redirections. For example setting \\\"redirects\\\": { \\\"example\\\":\\\"https://example.com\\\" } will make it so that anyone accessing /example on the server will get redirected to the specified URL.\" }, \"yubikey\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"id\" : { \"type\" : \"string\" }, \"secret\" : { \"type\" : \"string\" }, \"proxy\" : { \"type\" : \"string\" , \"format\" : \"uri\" } }, \"required\" : [ \"id\" , \"secret\" ] }, \"httpHeaders\" : { \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } }, \"agentConfig\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" }, \"default\" : null , \"description\" : \"Key and values to add to the MeshAgent .msh file\" }, \"assistantConfig\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" }, \"default\" : null , \"description\" : \"Key and values to add to the MeshCentral Assistant .msh file\" }, \"clipboardGet\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When false, users can't set the clipboard of a remove device.\" }, \"clipboardSet\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When false, users can't get the clipboard of a remove device.\" }, \"localSessionRecording\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When false, removes the local recording feature on remote desktop.\" }, \"sessionRecording\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"onlySelectedUsers\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, only device users with the session recording feature turned on will be recorded. When false, all users are recorded.\" }, \"onlySelectedUserGroups\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, only device user groups with the session recording feature turned on will be recorded. When false, all users are recorded.\" }, \"onlySelectedDeviceGroups\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, only device groups with the session recording feature turned on will be recorded. When false, all devices are recorded.\" }, \"filepath\" : { \"type\" : \"string\" , \"description\" : \"The file path where recording files are kept.\" }, \"index\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"If true, automatically index remote desktop recordings so that the plays can skip to any place in the file.\" }, \"maxRecordings\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of recording files to keep.\" }, \"maxRecordingDays\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of days to keep a recording.\" }, \"maxRecordingSizeMegabytes\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of recordings in megabytes. Once exceed, remove the oldest recordings.\" }, \"protocols\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"integer\" }, \"description\" : \"This is an array: 1 = Terminal, 2 = Desktop, 5 = Files, 100 = Intel AMT WSMAN, 101 = Intel AMT Redirection, 200 = Messenger\" } }, \"required\" : [ \"protocols\" ] }, \"showPasswordLogin\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, hides the username and password prompt on login screen.\" }, \"sendgrid\" : { \"title\" : \"SendGrid.com Email server\" , \"description\" : \"Connects MeshCentral to the SendGrid email server, allows MeshCentral to send email messages for 2FA or user notification.\" , \"type\" : \"object\" , \"properties\" : { \"from\" : { \"type\" : \"string\" , \"format\" : \"email\" , \"description\" : \"Email address used in the messages from field.\" }, \"apikey\" : { \"type\" : \"string\" , \"description\" : \"The SendGrid API key.\" }, \"verifyemail\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, the email format and DNS MX record are not checked.\" } }, \"required\" : [ \"from\" , \"apikey\" ] }, \"smtp\" : { \"title\" : \"SMTP email server\" , \"description\" : \"Connects MeshCentral to a SMTP email server, allows MeshCentral to send email messages for 2FA or user notification.\" , \"type\" : \"object\" , \"properties\" : { \"name\" : { \"type\" : \"string\" , \"format\" : \"hostname\" , \"description\" : \"Optional hostname of the client, this defaults to the hostname of the machine. This is useful for SMTP relays.\" }, \"host\" : { \"type\" : \"string\" , \"format\" : \"hostname\" , \"description\" : \"Hostname of the SMTP server.\" }, \"port\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"description\" : \"SMTP server port number.\" }, \"from\" : { \"type\" : \"string\" , \"format\" : \"email\" , \"description\" : \"Email address used in the messages from field.\" }, \"tls\" : { \"type\" : \"boolean\" }, \"auth\" : { \"type\" : \"object\" , \"properties\" : { \"clientId\" : { \"type\" : \"string\" }, \"clientSecret\" : { \"type\" : \"string\" }, \"refreshTfoken\" : { \"type\" : \"string\" } }, \"required\" : [ \"clientId\" , \"clientSecret\" , \"refreshToken\" ] }, \"tlscertcheck\" : { \"type\" : \"boolean\" }, \"tlsstrict\" : { \"type\" : \"boolean\" }, \"verifyemail\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, the email format and DNS MX record are not checked.\" } }, \"required\" : [ \"from\" ] }, \"sendmail\" : { \"title\" : \"Send email using the sendmail command\" , \"description\" : \"Makes MeshCentral send emails using the Unix sendmail command. Allows MeshCentral to send email messages for 2FA or user notification.\" , \"type\" : \"object\" , \"properties\" : { \"newline\" : { \"type\" : \"string\" , \"default\" : \"unix\" , \"description\" : \"Possible values are unix or windows\" }, \"path\" : { \"type\" : \"string\" , \"default\" : \"sendmail\" , \"description\" : \"Path to the sendmail command\" }, \"args\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }, \"default\" : null , \"description\" : \"Array or arguments to pass to sendmail\" } } }, \"authStrategies\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"twitter\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"clientid\" , \"clientsecret\" ] }, \"google\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"clientid\" , \"clientsecret\" ] }, \"github\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"clientid\" , \"clientsecret\" ] }, \"reddit\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"clientid\" , \"clientsecret\" ] }, \"azure\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"tenantid\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"clientid\" , \"clientsecret\" , \"tenantid\" ] }, \"jumpcloud\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"entityid\" : { \"type\" : \"string\" }, \"idpurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"cert\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"entityid\" , \"idpurl\" , \"cert\" ] }, \"saml\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"disableRequestedAuthnContext\" : { \"type\" : \"boolean\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"newAccountsRights\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"entityid\" : { \"type\" : \"string\" }, \"idpurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"cert\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"entityid\" , \"idpurl\" , \"cert\" ] }, \"oidc\" : { \"type\" : \"object\" , \"properties\" : { \"authorizationURL\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"If set, this will be used as the authorization URL. (If set tokenURL and userInfoURL need set also)\" }, \"callbackURL\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Required, this is the URL that your SSO provider sends auth approval to.\" }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"issuer\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Full URL of SSO portal\" }, \"tokenURL\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"If set, this will be used as the token URL. (If set authorizationURL and userInfoURL need set also)\" }, \"userInfoURL\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"If set, this will be used as the user info URL. (If set authorizationURL and tokenURL need set also)\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : true } }, \"required\" : [ \"issuer\" , \"clientid\" , \"clientsecret\" , \"callbackURL\" ] } } } } } }, \"letsEncrypt\" : { \"title\" : \"Built-in Let's Encrypt support\" , \"description\" : \"If your server has a proper DNS name and it public facing on the Internet with a public facing HTTP server on port 80, you can get a free TLS certificate.\" , \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"email\" : { \"type\" : \"string\" , \"format\" : \"email\" , \"description\" : \"Email address of the administrator of this server. Make sure this is a valid email address otherwise the certificate request will fail.\" }, \"names\" : { \"type\" : \"string\" }, \"skipChallengeVerification\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"By default, MeshCentral will perform a self-test to make sure HTTP port 80 can respond correctly before making a request to Let's Encrypt. In some cases, this self-test can't work and must be skipped.\" }, \"production\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"By default a test certificate will be obtained from Let's Encrypt. Always start by getting a test certificate and make sure that works before setting this to true and obtaining a production certificaite. Making too many bad requests for a production certificate will get you banned for a long period of time.\" } }, \"required\" : [ \"email\" , \"names\" ] }, \"peers\" : { \"title\" : \"Server peering\" , \"description\" : \"Setup peer server for load-balancing between many servers.\" , \"type\" : \"object\" , \"minProperties\" : 1 , \"propertyNames\" : { \"pattern\" : \"^[A-Za-z_][A-Za-z0-9_]*$\" }, \"additionalProperties\" : false , \"properties\" : { \"serverId\" : { \"type\" : \"string\" }, \"servers\" : { \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"object\" , \"properties\" : { \"url\" : { \"type\" : \"string\" , \"format\" : \"uri\" } }, \"required\" : [ \"url\" ] } } }, \"required\" : [ \"serverId\" , \"servers\" ] }, \"sendgrid\" : { \"title\" : \"SendGrid.com Email server\" , \"description\" : \"Connects MeshCentral to the SendGrid email server, allows MeshCentral to send email messages for 2FA or user notification.\" , \"type\" : \"object\" , \"properties\" : { \"from\" : { \"type\" : \"string\" , \"format\" : \"email\" , \"description\" : \"Email address used in the messages from field.\" }, \"apikey\" : { \"type\" : \"string\" , \"description\" : \"The SendGrid API key.\" }, \"verifyemail\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, the email format and DNS MX record are not checked.\" } }, \"required\" : [ \"from\" , \"apikey\" ] }, \"smtp\" : { \"title\" : \"SMTP email server\" , \"description\" : \"Connects MeshCentral to a SMTP email server, allows MeshCentral to send email messages for 2FA or user notification.\" , \"type\" : \"object\" , \"properties\" : { \"host\" : { \"type\" : \"string\" , \"format\" : \"hostname\" }, \"port\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 }, \"from\" : { \"type\" : \"string\" , \"format\" : \"email\" , \"description\" : \"Email address used in the messages from field.\" }, \"tls\" : { \"type\" : \"boolean\" }, \"tlscertcheck\" : { \"type\" : \"boolean\" }, \"tlsstrict\" : { \"type\" : \"boolean\" }, \"verifyemail\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, the email format and DNS MX record are not checked.\" } }, \"required\" : [ \"host\" , \"port\" , \"from\" , \"tls\" ] }, \"sms\" : { \"title\" : \"SMS provider\" , \"description\" : \"Connects MeshCentral to a SMS text messaging provider, allows MeshCentral to send SMS messages for 2FA or user notification.\" , \"oneOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"provider\" : { \"type\" : \"string\" , \"enum\" : [ \"twilio\" ] }, \"sid\" : { \"type\" : \"string\" }, \"auth\" : { \"type\" : \"string\" }, \"from\" : { \"type\" : \"string\" } }, \"required\" : [ \"provider\" , \"sid\" , \"auth\" , \"from\" ] }, { \"type\" : \"object\" , \"properties\" : { \"provider\" : { \"type\" : \"string\" , \"enum\" : [ \"plivo\" ] }, \"id\" : { \"type\" : \"string\" }, \"token\" : { \"type\" : \"string\" }, \"from\" : { \"type\" : \"string\" } }, \"required\" : [ \"provider\" , \"id\" , \"token\" , \"from\" ] }, { \"type\" : \"object\" , \"properties\" : { \"provider\" : { \"type\" : \"string\" , \"enum\" : [ \"telnyx\" ] }, \"apikey\" : { \"type\" : \"string\" }, \"from\" : { \"type\" : \"string\" } }, \"required\" : [ \"provider\" , \"apikey\" , \"from\" ] } ] } }, \"required\" : [ \"settings\" , \"domains\" ] }","title":"All Configuration Options"},{"location":"meshcentral/config/#configuration-options","text":"All possible configuration of MeshCentral can be found in this file: https://github.com/Ylianst/MeshCentral/blob/master/meshcentral-config-schema.json See description for information about each item. { \"id\" : \"https://raw.githubusercontent.com/Ylianst/MeshCentral/master/meshcentral-config-schema.json\" , \"$schema\" : \"http://json-schema.org/draft-04/schema#\" , \"description\" : \"MeshCentral configuration file schema\" , \"type\" : \"object\" , \"properties\" : { \"settings\" : { \"type\" : \"object\" , \"properties\" : { \"cert\" : { \"type\" : \"string\" , \"description\" : \"Set this to the primary DNS name of this MeshCentral server.\" }, \"mongoDb\" : { \"type\" : \"string\" , \"default\" : null }, \"mongoDbName\" : { \"type\" : \"string\" }, \"mongoDbChangeStream\" : { \"type\" : \"boolean\" , \"default\" : false }, \"mongoDbBulkOperations\" : { \"type\" : \"boolean\" , \"default\" : false }, \"mariaDB\" : { \"type\" : \"object\" , \"description\" : \"Add this section to connect MeshCentral to a MariaDB database instance.\" , \"properties\" : { \"host\" : { \"type\" : \"string\" , \"description\" : \"MariaDB hostname\" }, \"user\" : { \"type\" : \"string\" , \"description\" : \"MariaDB username\" }, \"port\" : { \"type\" : \"number\" , \"description\" : \"MariaDB port number\" }, \"password\" : { \"type\" : \"string\" , \"description\" : \"MariaDB password\" }, \"connectionLimit\" : { \"type\" : \"number\" , \"description\" : \"MariaDB connection limit\" }, \"database\" : { \"type\" : \"string\" , \"default\" : \"meshcentral\" , \"description\" : \"Name of MariaDB database used\" }, \"awsrds\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Set true to resolve LOCK TABLE permissions on AWS RDS.\" }, \"ssl\" : { \"type\" : \"object\" , \"description\" : \"SSL Options. Set to true (boolean) for default options.\" , \"properties\" : { \"caCertPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the CA certificate. Required for self-signed certificates\" }, \"clientCertPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the client certificate. Required for two-way SSL Authentication\" }, \"clientKeyPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the client key. Required for two-way SSL Authentication\" }, \"dontCheckServerIdentity\" : { \"type\" : \"boolean\" , \"description\" : \"Set true to not check the server hostname during verification\" } } } } }, \"mySQL\" : { \"type\" : \"object\" , \"description\" : \"Add this section to connect MeshCentral to a MySQL database instance.\" , \"properties\" : { \"host\" : { \"type\" : \"string\" , \"description\" : \"MySQL hostname\" }, \"port\" : { \"type\" : \"number\" , \"description\" : \"MySQL port number\" }, \"user\" : { \"type\" : \"string\" , \"description\" : \"MySQL username\" }, \"password\" : { \"type\" : \"string\" , \"description\" : \"MySQL password\" }, \"database\" : { \"type\" : \"string\" , \"default\" : \"meshcentral\" , \"description\" : \"Name of MySQL database used\" }, \"awsrds\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Set true to resolve LOCK TABLE permissions on AWS RDS.\" }, \"ssl\" : { \"type\" : \"object\" , \"description\" : \"SSL Options. Set to true (boolean) for default options.\" , \"properties\" : { \"caCertPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the CA certificate. Required for self-signed certificates\" }, \"clientCertPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the client certificate. Required for two-way SSL Authentication\" }, \"clientKeyPath\" : { \"type\" : \"string\" , \"description\" : \"Absolute path to the client key. Required for two-way SSL Authentication\" }, \"dontCheckServerIdentity\" : { \"type\" : \"boolean\" , \"description\" : \"Set true to not check the server hostname during verification\" } } } } }, \"postgres\" : { \"type\" : \"object\" , \"description\" : \"Add this section to connect MeshCentral to a PostgreSQL database instance.\" , \"properties\" : { \"host\" : { \"type\" : \"string\" , \"description\" : \"PostgreSQL hostname\" }, \"user\" : { \"type\" : \"string\" , \"description\" : \"PostgreSQL username\" }, \"port\" : { \"type\" : \"number\" , \"description\" : \"PostgreSQL port number\" }, \"password\" : { \"type\" : \"string\" , \"description\" : \"PostgreSQL password\" }, \"database\" : { \"type\" : \"string\" , \"default\" : \"meshcentral\" , \"description\" : \"Name of PostgreSQL database used\" } } }, \"WANonly\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, only MeshCentral WAN features are enabled and agents will connect to the server using a well known DNS name.\" }, \"LANonly\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, only MeshCentral LAN features are enabled and agents will find the server using multicast LAN packets.\" }, \"maintenanceMode\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled the server is in maintenance mode, only administrators can login. Use the maintenance command in server console to change.\" }, \"certificatePrivateKeyPassword\" : { \"type\" : \"array\" , \"default\" : null , \"description\" : \"List of passwords used to decrypt PKCK#8 .key files that are in the meshcentral-data folder.\" }, \"sessionTime\" : { \"type\" : \"integer\" , \"default\" : 60 , \"description\" : \"Duration of a session cookie in minutes. Changing this affects how often the session needs to be automatically refreshed.\" }, \"sessionKey\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Password used to encrypt the MeshCentral web session cookies. If null, a random one is generated each time the server starts.\" }, \"sessionSameSite\" : { \"type\" : \"string\" , \"default\" : \"lax\" , \"enum\" : [ \"strict\" , \"lax\" , \"none\" ] }, \"dbEncryptKey\" : { \"type\" : \"string\" }, \"dbRecordsEncryptKey\" : { \"type\" : \"string\" , \"default\" : null }, \"dbRecordsDecryptKey\" : { \"type\" : \"string\" , \"default\" : null }, \"dbExpire\" : { \"type\" : \"object\" , \"properties\" : { \"events\" : { \"type\" : \"integer\" , \"default\" : 1728000 , \"description\" : \"Amount of time in seconds that events are kept in the database.\" }, \"powerevents\" : { \"type\" : \"integer\" , \"default\" : 864000 , \"description\" : \"Amount of time in seconds that device power events are kept in the database.\" }, \"statsevents\" : { \"type\" : \"integer\" , \"default\" : 2592000 , \"description\" : \"Amount of time in seconds that server statistics are kept in the database.\" } } }, \"port\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"default\" : 443 , \"description\" : \"Ths port of the main HTTPS server.\" }, \"portBind\" : { \"type\" : \"string\" , \"description\" : \"When set, bind the HTTPS main port to a specific network address.\" }, \"aliasPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"default\" : null , \"description\" : \"The actual main port as seen externally on the Internet, this setting is often used when a reverse-proxy is used.\" }, \"redirPort\" : { \"type\" : \"integer\" , \"minimum\" : 0 , \"maximum\" : 65535 , \"default\" : 80 , \"description\" : \"This is a HTTP web server port that mostly redirects users to the HTTPS port but does provide some other servces, 0 will turn this port off.\" }, \"redirPortBind\" : { \"type\" : \"string\" , \"description\" : \"When set, bind the HTTP redirection port to a specific network address.\" }, \"redirAliasPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"description\" : \"The actual redirection port as seen externally on the Internet, this setting is often used when a reverse-proxy is used.\" }, \"relayPort\" : { \"type\" : \"integer\" , \"minimum\" : 0 , \"maximum\" : 65535 , \"default\" : 0 , \"description\" : \"When set, a web relay web server is bound to this port and will allow user access to remote web sites.\" }, \"relayAliasPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"default\" : null , \"description\" : \"The actual relay port as seen externally on the Internet, this setting is often used when a reverse-proxy is used.\" }, \"relayDNS\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"When set, relayPort valie is ignored. Set this to a DNS name the points to this server. When the server is accessed using the DNS name, the main web server port is used as a web relay port.\" }, \"agentPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"description\" : \"When set, enabled a new HTTPS server port that only accepts agent connections.\" }, \"agentPortBind\" : { \"type\" : \"string\" , \"description\" : \"When set, binds the agent port to a specific network interface.\" }, \"agentAliasPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"description\" : \"When set, indicates the actual publically visible agent-only port. If not set, the AgentPort value is used.\" }, \"agentAliasDNS\" : { \"type\" : \"string\" , \"format\" : \"hostname\" , \"description\" : \"When set, specified the DNS name used by agents to connect to the agent-only port.\" }, \"agentPortTls\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Indicates if the agent-only port must perform TLS, this should be set to false if TLS is performed in front of this server.\" }, \"agentLogDump\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Automatically downloads all agent error logs into meshcentral-data/agenterrorlogs.txt.\" }, \"agentCoreDump\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Automatically activates and transfers any agent crash dump files to the server in meshcentral-data/coredumps.\" }, \"agentCoreDumpUsers\" : { \"type\" : \"array\" , \"description\" : \"List of non-administrator users that have access to mesh agent crash dumps.\" }, \"agentSignLock\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When code signing an agent using authenticode, lock the agent to only allow connection to this server. (This is in testing, the default value will change to true in the future).\" }, \"agentTimeStampServer\" : { \"type\" : [ \"boolean\" , \"string\" ], \"default\" : \"http://timestamp.comodoca.com/authenticode\" , \"description\" : \"The time stamping server to use when code signing Windows executables. When set to false, the executables are not time stamped.\" }, \"agentTimeStampProxy\" : { \"type\" : [ \"boolean\" , \"string\" ], \"description\" : \"The HTTP proxy to use when contacting the time stamping server, if false, no proxy is used. By default, the npmproxy value is used.\" }, \"ignoreAgentHashCheck\" : { \"type\" : [ \"boolean\" , \"string\" ], \"default\" : false , \"description\" : \"When true, the agent no longer checked the TLS certificate of the server. This should be used for debugging only. You can also set this to a comma seperated list of IP addresses to ignore, for example: \\\"192.168.2.100,192.168.1.0/24\\\".\" }, \"exactPorts\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, MeshCentral will only grab the required TCP listening ports or fail. It will not try to use the next available port of it's busy.\" }, \"allowLoginToken\" : { \"type\" : \"boolean\" , \"default\" : false }, \"StrictTransportSecurity\" : { \"type\" : [ \"boolean\" , \"string\" ], \"default\" : null , \"description\" : \"Controls the Strict-Transport-Security header, default is 1 year. Set to false to remove, true to force enable, or string to set a custom value. If set to null, MeshCentral will enable if a trusted certificate is set.\" }, \"allowFraming\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, the MeshCentral web site can be embedded within another website's iframe.\" }, \"cookieIpCheck\" : { \"type\" : [ \"string\" , \"boolean\" ], \"default\" : \"lax\" , \"enum\" : [ \"strict\" , \"lax\" , \"none\" ] }, \"cookieEncoding\" : { \"type\" : \"string\" , \"enum\" : [ \"hex\" , \"base64\" ], \"default\" : \"base64\" , \"description\" : \"Encoding format of cookies in the HTTP headers, this is typically Base64 but some reverse proxies will require HEX.\" }, \"webRTC\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, allows use of WebRTC to allow direct network traffic between the agent and browser.\" }, \"nice404\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"By default, a nice looking 404 error page is displayed when needed. Set this to false to disable it.\" }, \"selfUpdate\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When true, this server will attempt to self-update everyday after midnight.\" }, \"cleanNpmCacheOnUpdate\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When true, run \\\"npm cache clean --force\\\" to reclame disk space.\" }, \"browserPing\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"description\" : \"When specified, sends data to the browser at x seconds interval and expects a response from the browser.\" }, \"browserPong\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"description\" : \"When specified, sends data to the browser at x seconds interval.\" }, \"agentsInRam\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Loads all agent binaries in RAM for faster agent updates.\" }, \"agentPing\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"description\" : \"When specified, sends data to the agent at x seconds interval and expects a response from the agent.\" }, \"agentPong\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"description\" : \"When specified, sends data to the agent at x seconds interval.\" }, \"amtManager\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When enabled, MeshCentral will automatically monitor and manage Intel AMT devices.\" }, \"orphanAgentUser\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"If an agent attempts to connect to a unknown device group, automatically create a new device group and grant access to the specified user. Example: admin\" }, \"agentIdleTimeout\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"default\" : 150 , \"description\" : \"How much time in seconds with no traffic from an agent before dropping the agent connection.\" }, \"webPageLengthRandomization\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Adds a random length string to generated web pages to mitigate a BREACH attack.\" }, \"compression\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Enables GZIP compression for web requests.\" }, \"wsCompression\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enables server-side, websocket per-message deflate compression.\" }, \"agentWsCompression\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Enables agent-side, websocket per-message deflate compression. wscompression must also be true for this to work.\" }, \"noAgentUpdate\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"Set to 1 to present the server from updating any agent.\" }, \"agentUpdateSystem\" : { \"type\" : \"integer\" , \"default\" : 1 , \"description\" : \"When set to 2, all agents that need to be updated will use the meshcore.js update system. With the default value of 1, the native update system is used.\" }, \"temporaryAgentUpdate\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to not allow temporary agents to be updated.\" }, \"amtScanner\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable Intel AMT scanning on the local network, this is already disabled in WAN mode.\" }, \"meshScanner\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable agent multicast scanning on the local network, this is already disabled in WAN mode.\" }, \"meshErrorLogPath\" : { \"type\" : \"string\" }, \"npmPath\" : { \"type\" : \"string\" }, \"npmProxy\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"allowHighQualityDesktop\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When false, users will only be able to set remote desktop image quality to 60%, this can reduce server bandwidth usage.\" }, \"webPush\" : { \"type\" : \"object\" , \"description\" : \"When set with a valid email address, enables the MeshCentral web push notification feature. Allows administrators to send browser notifications to users even if they are not looking at the MeshCentral web site.\" , \"additionalProperties\" : false , \"properties\" : { \"email\" : { \"type\" : \"string\" , \"description\" : \"Server administrator email given to the FireFox and Chrome push notification services.\" } }, \"required\" : [ \"email\" ] }, \"RunOnServerStarted\" : { \"type\" : \"boolean\" , \"default\" : null , \"description\" : \"Execute this when the server startup is completed. The first parameter will be the server version.\" }, \"RunOnServerUpdated\" : { \"type\" : \"boolean\" , \"default\" : null , \"description\" : \"Execute this when the server has been updated. The first parameter will be the server version.\" }, \"RunOnServerError\" : { \"type\" : \"boolean\" , \"default\" : null , \"description\" : \"Execute this when the server has to restart due to an error. The first parameter will be the server version.\" }, \"publicPushNotifications\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When true, this server uses MeshCentral.com a push notification relay for Android notifications. Push notifications work even if the Android app is not open.\" }, \"desktopMultiplex\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When true, enabled a server modules that efficiently splits a remote desktop stream to multiple browsers. Also allows slow browsers to not slow down the session for fast ones, this comes at the cost of extra server memory and processing for all remote desktop sessions.\" }, \"ipBlockedUserRedirect\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"If set, a user from a banned IP address will be redirected to this URL.\" }, \"userAllowedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, only users from allowed IP address ranges can connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"userBlockedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, users from these denied IP address ranges will not be able to connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"agentAllowedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, only agents from allowed IP address ranges can connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"agentBlockedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, agents from these denied IP address ranges will not be able to connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"authLog\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"File path and name of the authentication log to be created. This log can be parsed by Fail2ban.\" }, \"InterUserMessaging\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" }, \"description\" : \"Users in this list are allowed to send and receive inter-user messages. This can be used to implement bots or other software where MeshCentral is used as data transport. See \\\"interuser\\\" websocket command in the code.\" }, \"manageAllDeviceGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" }, \"description\" : \"Users in this list are allowed to see and manage all device groups within their domain.\" }, \"manageCrossDomain\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" }, \"description\" : \"Users in this list are allowed to manage all users in all domains.\" }, \"localDiscovery\" : { \"type\" : \"object\" , \"description\" : \"When this server is in LAN mode, you may discover this server using a multicast discovery tool. When discovery happens, the name and info fields are sent back to the discovery tool.\" , \"additionalProperties\" : false , \"properties\" : { \"name\" : { \"type\" : \"string\" }, \"info\" : { \"type\" : \"string\" }, \"key\" : { \"type\" : \"string\" , \"description\" : \"When set, encrypts all LAN discovery traffic to agents and tools using this key. This is only useful in LAN/Hybrid mode when agents and tools user multicast to find the server.\" } }, \"required\" : [ \"name\" , \"info\" ] }, \"tlsOffload\" : { \"type\" : [ \"boolean\" , \"string\" ], \"default\" : false , \"description\" : \"When true, indicates that a TLS offloader is in front of the MeshCentral server. More typically, set this to the IP address of the reverse proxy or TLS offloader so that IP forwarding headers will be trusted. For example: \\\"127.0.0.1,192.168.1.100\\\".\" }, \"trustedProxy\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Trust forwarded headers from these IPs or domains. Providing the magic string \\\"CloudFlare\\\" will cause the server to download the IP address list of trusted CloudFlare proxies directly from CloudFlare on each server start. For example: \\\"127.0.0.1,proxy.example.com,CloudFlare\\\".\" }, \"mpsPort\" : { \"type\" : \"integer\" , \"minimum\" : 0 , \"maximum\" : 65535 , \"default\" : 4433 , \"description\" : \"The Management Presence Server (MPS), this is the server that received Intel AMT Client Initiated Remote Access (CIRA) connections.\" }, \"mpsPortBind\" : { \"type\" : \"string\" , \"default\" : null }, \"mpsAliasPort\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"default\" : null }, \"mpsAliasHost\" : { \"type\" : \"string\" , \"default\" : null }, \"mpsTlsOffload\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, indicate that TLS is being performed by a device in front of MeshCentral.\" }, \"mpsHighSecurity\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, the MPS server will only accept TLS 1.2 and 1.3 connections. Older Intel AMT devices will not be able to connect.\" }, \"no2FactorAuth\" : { \"type\" : \"boolean\" , \"default\" : false }, \"log\" : { \"type\" : \"string\" , \"default\" : null }, \"syslog\" : { \"type\" : \"string\" , \"default\" : null }, \"syslogauth\" : { \"type\" : \"string\" , \"default\" : null }, \"syslogjson\" : { \"type\" : \"string\" , \"default\" : null }, \"syslogtcp\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Send syslog events over the network (RFC3164) to a target hostname:port. For example: localhost:514\" }, \"webrtcConfig\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"The STUN servers used for WebRTC, if not specified the Google and Mozilla servers and used when the server is not in LAN mode.\" , \"properties\" : { \"iceServers\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"urls\" : { \"type\" : \"string\" } }, \"required\" : [ \"urls\" ] } } }, \"required\" : [ \"iceServers\" ] }, \"autoBackup\" : { \"type\" : \"object\" , \"properties\" : { \"mongoDumpPath\" : { \"type\" : \"string\" }, \"mysqlDumpPath\" : { \"type\" : \"string\" }, \"backupIntervalHours\" : { \"type\" : \"integer\" }, \"keepLastDaysBackup\" : { \"type\" : \"integer\" }, \"zipPassword\" : { \"type\" : \"string\" }, \"backupPath\" : { \"type\" : \"string\" }, \"googleDrive\" : { \"type\" : \"object\" , \"description\" : \"Enabled automated upload of the server backups to a Google Drive account, once enabled you need to go in \\\"My Server\\\" tab as administrator to associate the account.\" , \"properties\" : { \"folderName\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral-Backups\" , \"description\" : \"The name of the folder to create in the Google Drive account.\" }, \"maxFiles\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"The maximum number of files to keep in the Google Drive folder, older files will be removed if needed.\" } } }, \"webDAV\" : { \"type\" : \"object\" , \"description\" : \"Enabled automated upload of the server backups to a WebDAV account.\" , \"properties\" : { \"url\" : { \"type\" : \"string\" , \"description\" : \"WebDAV account URL.\" }, \"username\" : { \"type\" : \"string\" , \"description\" : \"WebDAV account username.\" }, \"password\" : { \"type\" : \"string\" , \"description\" : \"WebDAV account password.\" }, \"folderName\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral-Backups\" , \"description\" : \"The name of the folder to create in the WebDAV account.\" }, \"maxFiles\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"The maximum number of files to keep in the WebDAV folder, older files will be removed if needed.\" } } } } }, \"redirects\" : { \"type\" : \"object\" }, \"maxInvalidLogin\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"This section described a policy for how many times an IP address is allowed to attempt to login incorrectly. By default it's 10 times in 10 minutes, but this can be changed here.\" , \"properties\" : { \"exclude\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Ranges of IP addresses that are not subject to invalid login limitations. For example: 192.168.1.0/24,172.16.0.1\" }, \"time\" : { \"type\" : \"integer\" , \"default\" : 10 , \"description\" : \"Time in minutes over which the a maximum number of invalid login attempts is allowed from an IP address.\" }, \"count\" : { \"type\" : \"integer\" , \"default\" : 10 , \"description\" : \"Maximum number of invalid login attempts from an IP address in the time period.\" }, \"coolofftime\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Additional time in minute that login attempts will be denied once the invalid login limit is reached.\" } } }, \"maxInvalid2fa\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"This section described a policy for how many times an IP address is allowed to attempt to perform two-factor authentication (2FA) incorrectly. By default it's 10 times in 10 minutes, but this can be changed here.\" , \"properties\" : { \"exclude\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Ranges of IP addresses that are not subject to invalid 2FA limitations. For example: 192.168.1.0/24,172.16.0.1\" }, \"time\" : { \"type\" : \"integer\" , \"default\" : 10 , \"description\" : \"Time in minutes over which the a maximum number of invalid 2FA attempts is allowed from an IP address.\" }, \"count\" : { \"type\" : \"integer\" , \"default\" : 10 , \"description\" : \"Maximum number of invalid 2FA attempts from an IP address in the time period.\" }, \"coolofftime\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Additional time in minute that 2FA attempts will be denied once the invalid 2FA limit is reached.\" } } }, \"amtProvisioningServer\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"required\" : [ \"deviceGroup\" , \"newMebxPassword\" , \"trustedFqdn\" , \"ip\" ], \"description\" : \"When present, this section will enable the Intel AMT provisioning server on the local network. This is used for Intel AMT bare-metal ACM activation.\" , \"properties\" : { \"port\" : { \"type\" : \"number\" , \"default\" : 9971 , \"description\" : \"Port number that provisioning server will listen to.\" }, \"deviceGroup\" : { \"type\" : \"string\" , \"description\" : \"The agent-less device group to add Intel AMT devices to once they are activated. Must be of format: mesh/domain/id\" }, \"newMebxPassword\" : { \"type\" : \"string\" , \"description\" : \"The MEBX password to set during activation. This password must be at least 8 characters long and have 1 lower, 1 upper, 1 alpha-numeric and 1 non-alpha numeric character.\" }, \"trustedFqdn\" : { \"type\" : \"string\" , \"description\" : \"The trusted FQDN or provisioning server value the remote device will have. This can be set in MEBx or using the DHCP server option 15 on the local network.\" }, \"ip\" : { \"type\" : \"string\" , \"description\" : \"The IP address of this server. This address will be used when creating the USB setup.bin file to indicate what IP address to send the hello data to.\" } } }, \"plugins\" : { \"type\" : \"object\" , \"properties\" : { \"enabled\" : { \"type\" : \"boolean\" } }, \"required\" : [ \"enabled\" ] } } }, \"domaindefaults\" : { \"$ref\" : \"#/properties/domains/items\" }, \"domains\" : { \"type\" : \"object\" , \"items\" : { \"type\" : \"object\" , \"properties\" : { \"siteStyle\" : { \"type\" : \"integer\" , \"default\" : 2 , \"description\" : \"Valid numbers are 1 and 2, changes the style of the login page and some secondary pages.\" }, \"title\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral\" , \"description\" : \"The title of this web site. All web pages will have this title.\" }, \"title2\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Secondary title text that is placed on the upper right on the title on many web pages.\" }, \"titlePicture\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Web site .png logo file that is 450x66 in size placed in meshcentral-data that is used on the top of many pages.\" }, \"loginPicture\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Web site .png logo file placed in meshcentral-data that used on the login page when sitestyle is 2.\" }, \"rootRedirect\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Redirects HTTP root requests to this URL. When in use, direct users to /login to see the normal login page.\" }, \"mobileSite\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, this setting will disable the mobile site.\" }, \"unknownUserRootRedirect\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Redirects HTTP root requests to this URL only where user is not already logged in. When in use, direct users to /login to see the normal login page.\" }, \"nightMode\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"0 = User selects day/night mode, 1 = Always night mode, 2 = Always day mode\" }, \"userQuota\" : { \"type\" : \"integer\" }, \"meshQuota\" : { \"type\" : \"integer\" }, \"loginKey\" : { \"type\" : [ \"string\" , \"array\" ], \"items\" : { \"type\" : \"string\" }, \"default\" : null , \"description\" : \"Requires that users add the value ?key=xxx in the URL in order to see the web site.\" }, \"agentKey\" : { \"type\" : [ \"string\" , \"array\" ], \"items\" : { \"type\" : \"string\" }, \"default\" : null , \"description\" : \"Requires that agents add the value ?key=xxx in the URL in order to connect. This is not automatic and needs to be manually added in the meshagent.msh file.\" }, \"ipkvm\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Set to true to enable IP KVM device support in this domain.\" }, \"minify\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, the server will send reduced sided web pages.\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, allow new user accounts to be created from the login page.\" }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"userNameIsEmail\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, the username of each account is also the email address of the account.\" }, \"newAccountEmailDomains\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"newAccountsRights\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"welcomeText\" : { \"type\" : \"string\" , \"description\" : \"Text that will be shown on the login screen.\" }, \"welcomePicture\" : { \"type\" : \"string\" , \"description\" : \"Name of the PNG or JPEG file that will be shown on the login screen. Put this file in the meshcentral-data folder and place the file name here.\" }, \"welcomePictureFullScreen\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, the welcomePicture will show as a fullscreen background on the login screen.\" }, \"meshMessengerTitle\" : { \"type\" : \"string\" , \"default\" : \"MeshMessenger\" , \"description\" : \"Text that will be displayed on the top of the messenger window when no username or device name is displayed.\" }, \"meshMessengerPicture\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Name of a .png image file that is placed in meshcentral-data that is displayed on the top of the messenger web page. When null, the default image is displayed.\" }, \"hide\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"Sum of: 1 = Hide header, 2 = Hide tab, 4 = Hide footer, 8 = Hide title, 16 = Hide left bar, 32 = Hide back buttons\" }, \"footer\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"This is a HTML string displayed at the bottom of the web page when a user is logged in.\" }, \"loginfooter\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"This is a HTML string displayed at the bottom of the web page when a user is not logged in.\" }, \"allowSavingDeviceCredentials\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allow users to save SSH, RDP, VNC device credentials on the server that can be used by any other user.\" }, \"guestDeviceSharing\" : { \"type\" : [ \"boolean\" , \"object\" ], \"default\" : true , \"description\" : \"When set to false, the desktop/terminal sharing link feature is not available.\" , \"properties\" : { \"maxSessionTime\" : { \"type\" : \"number\" , \"description\" : \"When set, limits the maximum length of a guest session, in minutes.\" } } }, \"autoRemoveInactiveDevices\" : { \"type\" : \"integer\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 2000 , \"description\" : \"Number of days a device can be inactive before it's removed. 0 disables this feature. Device group setting will override this value.\" }, \"deviceSearchBarServerAndClientName\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, the devices search box will match on both the server name and client name of a device.\" }, \"agentSelfGuestSharing\" : { \"type\" : [ \"boolean\" , \"object\" ], \"default\" : false , \"description\" : \"When set to true, MeshCentral Asssitant can create it's own guest sharing links.\" , \"properties\" : { \"expire\" : { \"type\" : \"number\" , \"description\" : \"When set, limits the self-created guest sharing link to this number of minutes.\" } } }, \"preConfiguredRemoteInput\" : { \"type\" : \"array\" , \"default\" : null , \"description\" : \"When set, you can right click on the input button in the desktop tab and instantly remotely type one of these pre-configured strings.\" , \"items\" : { \"type\" : \"object\" , \"required\" : [ \"name\" , \"value\" ], \"properties\" : { \"name\" : { \"description\" : \"Name of the text string.\" , \"type\" : \"string\" }, \"value\" : { \"description\" : \"Text string that will be remotely typed when selected.\" , \"type\" : \"string\" } } } }, \"altMessenging\" : { \"type\" : \"object\" , \"properties\" : { \"name\" : { \"type\" : \"string\" , \"description\" : \"Name of the alternative messaging service, for example: \\\"Jitsi\\\" \" }, \"url\" : { \"type\" : \"string\" , \"description\" : \"URL to the alternative messaging services, for example: \\\"https://meet.jit.si/myserver-{0}\\\"\" }, \"localurl\" : { \"type\" : \"string\" , \"description\" : \"If specified, this is the URL that is used on the administrator side, for example: \\\"https://meet.jit.si/myserver-{0}\\\"\" } }, \"required\" : [ \"name\" , \"url\" ] }, \"deviceMeshRouterLinks\" : { \"rdp\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Display a RDP link in the device tab when supported.\" }, \"ssh\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Display a SSH link in the device tab when supported.\" }, \"scp\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Display a SCP link in the device tab when supported.\" }, \"extralinks\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"required\" : [ \"name\" , \"protocol\" , \"port\" ], \"properties\" : { \"name\" : { \"description\" : \"Name of the link to be displayed on the web site.\" , \"type\" : \"string\" }, \"protocol\" : { \"description\" : \"Protocol. Valid values are: custom,http,https,rdp,ssh,scp,mcrdesktop,mcrfiles.\" , \"type\" : \"string\" }, \"port\" : { \"description\" : \"The port on the remote device.\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 65535 , \"type\" : \"integer\" }, \"ip\" : { \"description\" : \"Target IP address. If not specified, the target of the connection is the remote device running the MeshAgent.\" , \"type\" : \"string\" }, \"localport\" : { \"description\" : \"The local port MeshCentral Router would bind to. By default, a random available port is used.\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 65535 , \"type\" : \"integer\" }, \"filter\" : { \"description\" : \"Array of node/<domain>/<id> or mesh/<domain>/<id> or tag:<tag> strings. When set, the link will only show up for the specified devices, device groups or device tag.\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } } } } }, \"certUrl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"https url when to get the TLS certificate that MeshAgent's will see when connecting to this server. This setting is used when a reverse proxy like NGINX is used in front of MeshCentral.\" }, \"myServer\" : { \"type\" : [ \"object\" , \"boolean\" ], \"additionalProperties\" : false , \"properties\" : { \"Backup\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to backup the server from the My Server tab. This option can only enabled when the NeDB databse is in use. For other databases, this option disabled and the setting is ignored.\" }, \"Restore\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to restore the server from the My Server tab. This option can only enabled when the NeDB databse is in use. For other databases, this option disabled and the setting is ignored.\" }, \"Upgrade\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to update the server from the My Server tab.\" }, \"ErrorLog\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to see the server crash log the server from the My Server tab.\" }, \"Console\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to access the server console from the My Server tab.\" }, \"Trace\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Allows administrators to access the server trace tab from from the My Server tab.\" } } }, \"passwordRequirements\" : { \"type\" : \"object\" , \"properties\" : { \"min\" : { \"type\" : \"integer\" , \"description\" : \"Minimum number of characters allowed for the account password.\" }, \"max\" : { \"type\" : \"integer\" , \"description\" : \"Maximum number of characters allowed for the account password.\" }, \"upper\" : { \"type\" : \"integer\" , \"description\" : \"Minimum number of upper case characters required in the password.\" }, \"lower\" : { \"type\" : \"integer\" , \"description\" : \"Minimum number of lower case characters required in the password.\" }, \"numeric\" : { \"type\" : \"integer\" , \"description\" : \"Minimum number of numeric characters required in the password.\" }, \"nonalpha\" : { \"type\" : \"integer\" , \"description\" : \"Minimum number of non-alpha-numeric characters required in the password.\" }, \"reset\" : { \"type\" : \"integer\" , \"description\" : \"Number of days after which the user is required to change the account password.\" }, \"email2factor\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable email 2FA.\" }, \"sms2factor\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable SMS 2FA.\" }, \"push2factor\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable push notification 2FA.\" }, \"otp2factor\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable one-time-password 2FA.\" }, \"backupcode2factor\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable 2FA backup codes.\" }, \"single2factorWarning\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Set to false to disable single 2FA warning.\" }, \"lock2factor\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to true, prevents any changes to 2FA.\" }, \"force2factor\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Requires that all accounts setup 2FA.\" }, \"skip2factor\" : { \"type\" : \"string\" , \"description\" : \"IP addresses where 2FA login is skipped, for example: 127.0.0.1,192.168.2.0/24\" }, \"oldPasswordBan\" : { \"type\" : \"integer\" , \"description\" : \"Number of old passwords the server should remember and not allow the user to switch back to.\" }, \"banCommonPasswords\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Uses WildLeek to block use of the 10000 most commonly used passwords.\" }, \"loginTokens\" : { \"type\" : [ \"boolean\" , \"array\" ], \"default\" : true , \"description\" : \"Allows users to create alternative username/passwords for their account. Set to false to disallow all users, or set to a userid array to only all some users.\" }, \"twoFactorTimeout\" : { \"type\" : \"integer\" , \"default\" : 300 , \"description\" : \"Maximum about of time the to wait for a 2FA token on the login page in seconds.\" }, \"autofido2fa\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"If true and user account has FIDO key setup, 2FA login screen will automatically request FIDO 2FA.\" }, \"maxfidokeys\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of FIDO/YubikeyOTP hardware 2FA keys that can be setup in a user account.\" }, \"allowaccountreset\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"If set to false, the account reset option on the login screen will not be available to users.\" } } }, \"twoFactorCookieDurationDays\" : { \"type\" : \"integer\" , \"default\" : 30 , \"description\" : \"Number of days that a user is allowed to remember this device for when completing 2FA. Set this to 0 to remove this option.\" }, \"auth\" : { \"type\" : \"string\" , \"default\" : null , \"enum\" : [ null , \"sspi\" , \"ldap\" ], \"description\" : \"Type of user authentication to use, this can be SSPI on Windows or LDAP. If not set, username/password is used.\" }, \"ldapUserKey\" : { \"type\" : \"string\" }, \"ldapUserName\" : { \"type\" : \"string\" }, \"ldapUserEmail\" : { \"type\" : \"string\" }, \"ldapUserRealName\" : { \"type\" : \"string\" }, \"ldapUserPhoneNumber\" : { \"type\" : \"string\" }, \"ldapOptions\" : { \"type\" : \"object\" , \"description\" : \"LDAP options passed to ldapauth-fork\" }, \"agentInviteCodes\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enabled a feature where you can set one or more invitation codes in a device group. You can then give a invitation link to users who can use it to download the agent.\" }, \"agentNoProxy\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, all newly installed MeshAgents will be instructed to no use a HTTP/HTTPS proxy even if one is configured on the remote system\" }, \"agentTag\" : { \"type\" : \"object\" , \"description\" : \"This section is used to indicate if parts of the meshagent.tag file should be used to set server-side device properties.\" , \"additionalProperties\" : false , \"properties\" : { \"ServerName\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"Action taken if one of the lines in meshagent.tag contains ~ServerName:name. 0=Ignore, 1=Set.\" }, \"ServerDesc\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"Action taken if one of the lines in meshagent.tag contains ~ServerDesc:desc. 0=Ignore, 1=Set, 2=SetIfEmpty.\" }, \"ServerTags\" : { \"type\" : \"integer\" , \"default\" : 0 , \"description\" : \"Action taken if one of the lines in meshagent.tag contains ~ServerTags:tag1,tag2,tag3. 0=Ignore, 1=Set, 2=SetIfEmpty, 3=Append.\" } } }, \"geoLocation\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enables the geo-location feature and device location map in the user interface, this feature is not being worked on.\" }, \"novnc\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When enabled, activates the built-in web-based VNC client.\" }, \"mstsc\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, activates the built-in web-based RDP client.\" }, \"ssh\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, activates the built-in web-based SSH client.\" }, \"webEmailsPath\" : { \"type\" : \"string\" , \"description\" : \"Path where to find custom email templates for this domain.\" }, \"customUI\" : { \"type\" : \"object\" }, \"consentMessages\" : { \"type\" : \"object\" , \"description\" : \"This section is used to customize user consent prompts, these show up when asking if a remote session is allowed or not.\" , \"additionalProperties\" : false , \"properties\" : { \"Title\" : { \"type\" : \"string\" }, \"Desktop\" : { \"type\" : \"string\" }, \"Terminal\" : { \"type\" : \"string\" }, \"Files\" : { \"type\" : \"string\" }, \"consentTimeout\" : { \"type\" : \"integer\" , \"default\" : 30 , \"description\" : \"How long in seconds to show the user consent dialog box.\" }, \"autoAcceptOnTimeout\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"If true, user consent is accepted after the timeout.\" } } }, \"notificationMessages\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"This section is user to customize user notifications when a remote desktop, terminal or file session is connected to a remote system.\" , \"properties\" : { \"Title\" : { \"type\" : \"string\" }, \"Desktop\" : { \"type\" : \"string\" }, \"Terminal\" : { \"type\" : \"string\" }, \"Files\" : { \"type\" : \"string\" } } }, \"agentCustomization\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Use this section to customize the agent branding.\" , \"properties\" : { \"displayName\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral Agent\" , \"description\" : \"The name of the agent as displayed to the user.\" }, \"description\" : { \"type\" : \"string\" , \"default\" : \"Mesh Agent background service\" , \"description\" : \"The description of the agent as displayed to the user.\" }, \"companyName\" : { \"type\" : \"string\" , \"default\" : \"Mesh Agent\" , \"description\" : \"This will be used as the path to install the agent, by default this is 'Mesh Agent' in Windows and 'meshagent' in other OS's.\" }, \"serviceName\" : { \"type\" : \"string\" , \"default\" : \"Mesh Agent\" , \"description\" : \"The name of the background service, by default this is 'Mesh Agent' in Windows and 'meshagent' in other OS's but should be set to an all lower case, no space string.\" }, \"installText\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Text string to show in the agent installation dialog box.\" }, \"image\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The filename of a image file in .png format located in meshcentral-data to display in the MeshCentral Agent installation dialog, image should be square and from 64x64 to 200x200.\" }, \"fileName\" : { \"type\" : \"string\" , \"default\" : \"meshagent\" , \"description\" : \"The agent filename.\" }, \"foregroundColor\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Foreground text color, valid values are RBG in format 0,0,0 to 255,255,255 or format #000000 to #FFFFFF.\" }, \"backgroundColor\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Background color, valid values are RBG in format 0,0,0 to 255,255,255 or format #000000 to #FFFFFF.\" } } }, \"agentFileInfo\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Use this section to set resource metadata of the Windows agents prior to signing. In Windows, you can right-click and select properties to view these values.\" , \"properties\" : { \"fileDescription\" : { \"type\" : \"string\" , \"description\" : \"Executable file description.\" }, \"fileVersion\" : { \"type\" : \"string\" , \"description\" : \"Executable file version, generally in the form of 1.2.3.4.\" }, \"internalName\" : { \"type\" : \"string\" , \"description\" : \"Executable internal name.\" }, \"legalCopyright\" : { \"type\" : \"string\" , \"description\" : \"Executable legal copyright.\" }, \"originalFilename\" : { \"type\" : \"string\" , \"description\" : \"Executable original file name.\" }, \"productName\" : { \"type\" : \"string\" , \"description\" : \"Executable product name.\" }, \"productVersion\" : { \"type\" : \"string\" , \"description\" : \"Executable product version, generally in the form of 1.2.3.4.\" } } }, \"assistantCustomization\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Use this section to customize the MeshCentral Assistant.\" , \"properties\" : { \"title\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral Assistant\" , \"description\" : \"Name to show as MeshCentral Assistant dialog title.\" }, \"image\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The filename of a image file in .png format located in meshcentral-data to display in MeshCentral Assistant, image should be square and from 64x64 to 128x128.\" }, \"fileName\" : { \"type\" : \"string\" , \"default\" : \"meshagent\" , \"description\" : \"The MeshCentral Assistant filename.\" } } }, \"androidCustomization\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Use this section to customize the MeshCentral Agent for Android.\" , \"properties\" : { \"title\" : { \"type\" : \"string\" , \"default\" : \"MeshCentral Agent\" , \"description\" : \"Displayed on top of the MeshCentral Agent for Android.\" }, \"subtitle\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Subtitle displayed until the title on the toolbar.\" }, \"image\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The filename of a image file in .png format located in meshcentral-data to display in MeshCentral Agent for Android, image should be square and from 64x64 to 128x128.\" } } }, \"ipBlockedUserRedirect\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"If set, a user from a banned IP address will be redirected to this URL.\" }, \"userRequiredHttpHeader\" : { \"type\" : \"object\" , \"default\" : null , \"description\" : \"When set, requires that a browser request have set HTTP header to allow user login. Example: \\\"{ \\\"Sec-Fetch-Dest\\\": \\\"iframe\\\" }\\\"\" }, \"userAllowedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, only users from allowed IP address ranges can connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"userBlockedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, users from these denied IP address ranges will not be able to connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"agentAllowedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, only agents from allowed IP address ranges can connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"agentBlockedIP\" : { \"type\" : [ \"string\" , \"array\" ], \"default\" : null , \"description\" : \"When set, agents from these denied IP address ranges will not be able to connect to the server. Example: \\\"192.168.2.100,192.168.1.0/24\\\"\" }, \"userSessionIdleTimeout\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"When set, idle users will be disconnected after a set amounts of minutes.\" }, \"userConsentFlags\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Use this section to require user consent for this domain.\" , \"properties\" : { \"desktopnotify\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable desktop notification for this domain.\" }, \"terminalnotify\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable terminal notification for this domain.\" }, \"filenotify\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable files notification for this domain.\" }, \"desktopprompt\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable desktop prompt for this domain.\" }, \"terminalprompt\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable terminal user prompt for this domain.\" }, \"fileprompt\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable files prompt for this domain.\" }, \"desktopprivacybar\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"Enable remote desktop privacy bar for this domain.\" } } }, \"urlSwitching\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When users navigate thru the web interface, the URL on top will change to point to the current screen. This allows a user to refresh or bookmark the URL and come back to the correct screen. Setting false here will disable this feature.\" }, \"desktopPrivacyBarText\" : { \"type\" : \"string\" , \"description\" : \"This is the text that will be shown in the remote desktop privacy bar. You can use {0} to display the account realname or {1} to display the account identifier in the string.\" }, \"limits\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"MaxDevices\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of devices in this domain.\" }, \"MaxUserAccounts\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of devices in this domain.\" }, \"MaxUserSessions\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of user sessions that can connect to this server for this domain.\" }, \"MaxAgentSessions\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of agents that can connect to this server for this domain.\" }, \"MaxSingleUserSessions\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of sessions a single user can have. Each time a user opens a new browser tab or opens a new browser on a different computer, a new user session is created.\" } } }, \"terminal\" : { \"type\" : \"object\" , \"description\" : \"Values that affect the terminal feature\" , \"properties\" : { \"linuxShell\" : { \"type\" : \"string\" , \"enum\" : [ \"any\" , \"root\" , \"user\" , \"login\" ], \"default\" : \"any\" , \"description\" : \"Indicate what terminal options are available when the user clicks the right mouse button on the terminal connect button.\" }, \"launchCommand\" : { \"type\" : \"object\" , \"description\" : \"Indicate what string the agent must write to the shell after starting a terminal session\" , \"linux\" : { \"type\" : \"string\" , \"default\" : \" alias ls=\\\\'ls --color=auto\\\\';clear\\\\n\" , \"description\" : \"String to write after opening a Linux terminal.\" }, \"darwin\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"String to write after opening a macOS terminal.\" }, \"freebsd\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"String to write after opening a FreeBSD terminal.\" } } } }, \"desktop\" : { \"type\" : \"object\" , \"description\" : \"Values that affect the remote desktop feature\" , \"properties\" : { \"viewonly\" : { \"type\" : \"boolean\" , \"description\" : \"When set to true, the remote desktop feature is view only.\" , \"default\" : \"false\" } } }, \"amtScanOptions\" : { \"description\" : \"List of local network Intel AMT scanning options offered in the user interface. For example [\\\"LabNetwork 192.168.15.0/23\\\", \\\"SalesNetwork 192.168.8.0/24\\\"].\" , \"type\" : \"array\" , \"default\" : null , \"items\" : { \"type\" : \"string\" } }, \"amtManager\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"description\" : \"Information passed to the AMT manager module that impacts all Intel AMT device managed within this domain.\" , \"properties\" : { \"TlsConnections\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, MeshCentral will use TLS to connect to Intel AMT, this is not recommanded.\" }, \"TlsAcmActivation\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When set to false, MeshCentral will not attempt a TLS ACM activation on Intel AMT v14+\" }, \"AdminAccounts\" : { \"description\" : \"List of username and passwords to try when connecting to Intel AMT.\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"required\" : [ \"pass\" ], \"properties\" : { \"user\" : { \"description\" : \"Intel AMT administrator username.\" , \"type\" : \"string\" , \"default\" : \"admin\" }, \"pass\" : { \"description\" : \"Intel AMT administrator password.\" , \"type\" : \"string\" } } } }, \"EnvironmentDetection\" : { \"description\" : \"List of up to 4 domain suffixes to configure in Intel AMT when activating CIRA.\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" , \"minItems\" : 1 , \"maxItems\" : 4 , \"uniqueItems\" : true } }, \"TlsRootCert\" : { \"description\" : \"Specifies a certificate and private key to use to issue Intel AMT TLS certificates. By default the MeshCentral self-signed root certificate is used.\" , \"type\" : \"object\" , \"properties\" : { \"certpfx\" : { \"description\" : \"Name of the certificate file that is in .p12 or .pfx format in meshcentral-data, use this with certpfxpass.\" , \"type\" : \"string\" }, \"certpfxpass\" : { \"description\" : \"Password for the file specified in certpfx.\" , \"type\" : \"string\" }, \"certfile\" : { \"description\" : \"Name of the certificate file in PEM format located in meshcentral-data. Using this with keyfile.\" , \"type\" : \"string\" }, \"keyfile\" : { \"description\" : \"Name of the private key file in PEM format located in meshcentral-data. Using this with certfile.\" , \"type\" : \"string\" } } }, \"WifiProfiles\" : { \"description\" : \"List of WIFI profiles to setup in any managed Intel AMT device with a WIFI network interface.\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"required\" : [ \"ssid\" ], \"properties\" : { \"name\" : { \"description\" : \"WIFI profile name, if not specified the SSID is used.\" , \"type\" : \"string\" }, \"ssid\" : { \"description\" : \"SSID of the WIFI station.\" , \"type\" : \"string\" }, \"authentication\" : { \"description\" : \"WIFI authentication.\" , \"type\" : \"string\" , \"enum\" : [ \"wpa-psk\" , \"wpa2-psk\" , \"wpa-8021x\" , \"wpa2-802.1x\" , \"wpa3-sae-802.1x\" , \"wpa3-owe-802.1x\" ], \"default\" : \"wpa2-psk\" }, \"encryption\" : { \"description\" : \"WIFI encryption.\" , \"type\" : \"string\" , \"enum\" : [ \"ccmp-aes\" , \"tkip-rc4\" ], \"default\" : \"ccmp-aes\" }, \"password\" : { \"description\" : \"Password on the WIFI station\" , \"type\" : \"string\" , \"minLength\" : 8 , \"maxLength\" : 63 }, \"802.1x\" : { \"description\" : \"802.1x settings for this WIFI profile. Only required if the WIFI authentication type has 802.1x\" , \"default\" : null , \"type\" : \"object\" , \"additionalProperties\" : false , \"required\" : [ \"authenticationProtocol\" ], \"properties\" : { \"authenticationProtocol\" : { \"description\" : \"Identifies the authentication protocol used to authenticate the access requestor to the AAA server.\" , \"type\" : [ \"integer\" , \"string\" ], \"enum\" : [ \"EAP-TLS\" , \"EAP-TTLS/MSCHAPv2\" , \"PEAPv0/EAP-MSCHAPv2\" , \"PEAPv1/EAP-GTC\" , \"EAP-FAST/MSCHAPv2\" , \"EAP-FAST/GTC\" , \"EAP-MD5\" , \"EAP-PSK\" , \"EAP-SIM\" , \"EAP-AKA\" , \"EAP-FAST/TLS\" , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] }, \"serverCertificateNameComparison\" : { \"type\" : [ \"integer\" , \"string\" ], \"default\" : \"FullName\" , \"description\" : \"Determines the comparison algorithm used between the ServerCertificateName value and the subject name field of the certificate presented by the AAA server.\" , \"enum\" : [ \"FullName\" , \"DomainSuffix\" , 2 , 3 ] }, \"serverCertificateName\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The name compared against the subject name field in the certificate provided by the AAA server.\" , \"maxLength\" : 80 }, \"availableInS0\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Indicates the activity setting of the 802.1X module in H0 state\" }, \"protectedAccessCredentialHex\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"A credential used by the supplicant and AAA server to establish a mutually authenticated encrypted tunnel for confidential user authentication.\" , \"maxLength\" : 64 }, \"pacPassword\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Optional password to extract the PAC (Protected Access Credential) information from the PAC data.\" , \"maxLength\" : 256 }, \"domain\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The domain within which Username is unique.\" , \"maxLength\" : 128 }, \"username\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Within the domain specified by Domain, Identifies the user that is requesting access to the network.\" , \"maxLength\" : 128 }, \"password\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The password associated with the user identified by Username and Domain.\" , \"maxLength\" : 32 }, \"roamingIdentity\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"A string presented to the authentication server in 802.1x protocol exchange\" , \"maxLength\" : 80 }, \"pxeTimeoutInSeconds\" : { \"type\" : \"integer\" , \"default\" : 120 , \"description\" : \"Timeout in seconds, in which the Intel(R) AMT will hold an authenticated 802.1X session.\" } } } } } }, \"802.1x\" : { \"description\" : \"802.1x settings for the Intel AMT Wired interface. If set to false, any existing 802.1x wired profile will be removed from Intel AMT.\" , \"default\" : null , \"type\" : [ \"object\" , \"boolean\" ], \"additionalProperties\" : false , \"required\" : [ \"authenticationProtocol\" ], \"properties\" : { \"authenticationProtocol\" : { \"description\" : \"Identifies the authentication protocol used to authenticate the access requestor to the AAA server.\" , \"type\" : [ \"integer\" , \"string\" ], \"enum\" : [ \"EAP-TLS\" , \"EAP-TTLS/MSCHAPv2\" , \"PEAPv0/EAP-MSCHAPv2\" , \"PEAPv1/EAP-GTC\" , \"EAP-FAST/MSCHAPv2\" , \"EAP-FAST/GTC\" , \"EAP-MD5\" , \"EAP-PSK\" , \"EAP-SIM\" , \"EAP-AKA\" , \"EAP-FAST/TLS\" , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] }, \"serverCertificateNameComparison\" : { \"type\" : [ \"integer\" , \"string\" ], \"description\" : \"Determines the comparison algorithm used between the ServerCertificateName value and the subject name field of the certificate presented by the AAA server.\" , \"enum\" : [ \"FullName\" , \"DomainSuffix\" , 2 , 3 ] }, \"serverCertificateName\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The name compared against the subject name field in the certificate provided by the AAA server.\" , \"maxLength\" : 80 }, \"availableInS0\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"Indicates the activity setting of the 802.1X module in H0 state\" }, \"protectedAccessCredentialHex\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"A credential used by the supplicant and AAA server to establish a mutually authenticated encrypted tunnel for confidential user authentication.\" , \"maxLength\" : 64 }, \"pacPassword\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Optional password to extract the PAC (Protected Access Credential) information from the PAC data.\" , \"maxLength\" : 256 }, \"domain\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The domain within which Username is unique.\" , \"maxLength\" : 128 }, \"username\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"Within the domain specified by Domain, Identifies the user that is requesting access to the network.\" , \"maxLength\" : 128 }, \"password\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"The password associated with the user identified by Username and Domain.\" , \"maxLength\" : 32 }, \"roamingIdentity\" : { \"type\" : \"string\" , \"default\" : null , \"description\" : \"A string presented to the authentication server in 802.1x protocol exchange\" , \"maxLength\" : 80 }, \"pxeTimeoutInSeconds\" : { \"type\" : \"integer\" , \"default\" : 120 , \"description\" : \"Timeout in seconds, in which the Intel(R) AMT will hold an authenticated 802.1X session.\" } } } } }, \"amtAcmActivation\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"log\" : { \"type\" : \"string\" }, \"certs\" : { \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"certfiles\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"keyfile\" : { \"type\" : \"string\" } }, \"required\" : [ \"certfiles\" , \"keyfile\" ] } } }, \"required\" : [ \"certs\" ] }, \"redirects\" : { \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" }, \"description\" : \"This is used to create HTTP redirections. For example setting \\\"redirects\\\": { \\\"example\\\":\\\"https://example.com\\\" } will make it so that anyone accessing /example on the server will get redirected to the specified URL.\" }, \"yubikey\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"id\" : { \"type\" : \"string\" }, \"secret\" : { \"type\" : \"string\" }, \"proxy\" : { \"type\" : \"string\" , \"format\" : \"uri\" } }, \"required\" : [ \"id\" , \"secret\" ] }, \"httpHeaders\" : { \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"string\" } }, \"agentConfig\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" }, \"default\" : null , \"description\" : \"Key and values to add to the MeshAgent .msh file\" }, \"assistantConfig\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" }, \"default\" : null , \"description\" : \"Key and values to add to the MeshCentral Assistant .msh file\" }, \"clipboardGet\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When false, users can't set the clipboard of a remove device.\" }, \"clipboardSet\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When false, users can't get the clipboard of a remove device.\" }, \"localSessionRecording\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When false, removes the local recording feature on remote desktop.\" }, \"sessionRecording\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"onlySelectedUsers\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, only device users with the session recording feature turned on will be recorded. When false, all users are recorded.\" }, \"onlySelectedUserGroups\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, only device user groups with the session recording feature turned on will be recorded. When false, all users are recorded.\" }, \"onlySelectedDeviceGroups\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"When enabled, only device groups with the session recording feature turned on will be recorded. When false, all devices are recorded.\" }, \"filepath\" : { \"type\" : \"string\" , \"description\" : \"The file path where recording files are kept.\" }, \"index\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"If true, automatically index remote desktop recordings so that the plays can skip to any place in the file.\" }, \"maxRecordings\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of recording files to keep.\" }, \"maxRecordingDays\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of days to keep a recording.\" }, \"maxRecordingSizeMegabytes\" : { \"type\" : \"integer\" , \"default\" : null , \"description\" : \"Maximum number of recordings in megabytes. Once exceed, remove the oldest recordings.\" }, \"protocols\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"integer\" }, \"description\" : \"This is an array: 1 = Terminal, 2 = Desktop, 5 = Files, 100 = Intel AMT WSMAN, 101 = Intel AMT Redirection, 200 = Messenger\" } }, \"required\" : [ \"protocols\" ] }, \"showPasswordLogin\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, hides the username and password prompt on login screen.\" }, \"sendgrid\" : { \"title\" : \"SendGrid.com Email server\" , \"description\" : \"Connects MeshCentral to the SendGrid email server, allows MeshCentral to send email messages for 2FA or user notification.\" , \"type\" : \"object\" , \"properties\" : { \"from\" : { \"type\" : \"string\" , \"format\" : \"email\" , \"description\" : \"Email address used in the messages from field.\" }, \"apikey\" : { \"type\" : \"string\" , \"description\" : \"The SendGrid API key.\" }, \"verifyemail\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, the email format and DNS MX record are not checked.\" } }, \"required\" : [ \"from\" , \"apikey\" ] }, \"smtp\" : { \"title\" : \"SMTP email server\" , \"description\" : \"Connects MeshCentral to a SMTP email server, allows MeshCentral to send email messages for 2FA or user notification.\" , \"type\" : \"object\" , \"properties\" : { \"name\" : { \"type\" : \"string\" , \"format\" : \"hostname\" , \"description\" : \"Optional hostname of the client, this defaults to the hostname of the machine. This is useful for SMTP relays.\" }, \"host\" : { \"type\" : \"string\" , \"format\" : \"hostname\" , \"description\" : \"Hostname of the SMTP server.\" }, \"port\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"description\" : \"SMTP server port number.\" }, \"from\" : { \"type\" : \"string\" , \"format\" : \"email\" , \"description\" : \"Email address used in the messages from field.\" }, \"tls\" : { \"type\" : \"boolean\" }, \"auth\" : { \"type\" : \"object\" , \"properties\" : { \"clientId\" : { \"type\" : \"string\" }, \"clientSecret\" : { \"type\" : \"string\" }, \"refreshTfoken\" : { \"type\" : \"string\" } }, \"required\" : [ \"clientId\" , \"clientSecret\" , \"refreshToken\" ] }, \"tlscertcheck\" : { \"type\" : \"boolean\" }, \"tlsstrict\" : { \"type\" : \"boolean\" }, \"verifyemail\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, the email format and DNS MX record are not checked.\" } }, \"required\" : [ \"from\" ] }, \"sendmail\" : { \"title\" : \"Send email using the sendmail command\" , \"description\" : \"Makes MeshCentral send emails using the Unix sendmail command. Allows MeshCentral to send email messages for 2FA or user notification.\" , \"type\" : \"object\" , \"properties\" : { \"newline\" : { \"type\" : \"string\" , \"default\" : \"unix\" , \"description\" : \"Possible values are unix or windows\" }, \"path\" : { \"type\" : \"string\" , \"default\" : \"sendmail\" , \"description\" : \"Path to the sendmail command\" }, \"args\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }, \"default\" : null , \"description\" : \"Array or arguments to pass to sendmail\" } } }, \"authStrategies\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"twitter\" : { \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"clientid\" , \"clientsecret\" ] }, \"google\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"clientid\" , \"clientsecret\" ] }, \"github\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"clientid\" , \"clientsecret\" ] }, \"reddit\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"clientid\" , \"clientsecret\" ] }, \"azure\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"tenantid\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"clientid\" , \"clientsecret\" , \"tenantid\" ] }, \"jumpcloud\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"entityid\" : { \"type\" : \"string\" }, \"idpurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"cert\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"entityid\" , \"idpurl\" , \"cert\" ] }, \"saml\" : { \"type\" : \"object\" , \"properties\" : { \"callbackurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"disableRequestedAuthnContext\" : { \"type\" : \"boolean\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : false }, \"newAccountsUserGroups\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"newAccountsRights\" : { \"type\" : \"array\" , \"uniqueItems\" : true , \"items\" : { \"type\" : \"string\" } }, \"entityid\" : { \"type\" : \"string\" }, \"idpurl\" : { \"type\" : \"string\" , \"format\" : \"uri\" }, \"cert\" : { \"type\" : \"string\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" } }, \"required\" : [ \"entityid\" , \"idpurl\" , \"cert\" ] }, \"oidc\" : { \"type\" : \"object\" , \"properties\" : { \"authorizationURL\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"If set, this will be used as the authorization URL. (If set tokenURL and userInfoURL need set also)\" }, \"callbackURL\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Required, this is the URL that your SSO provider sends auth approval to.\" }, \"clientid\" : { \"type\" : \"string\" }, \"clientsecret\" : { \"type\" : \"string\" }, \"issuer\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Full URL of SSO portal\" }, \"tokenURL\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"If set, this will be used as the token URL. (If set authorizationURL and userInfoURL need set also)\" }, \"userInfoURL\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"If set, this will be used as the user info URL. (If set authorizationURL and tokenURL need set also)\" }, \"logouturl\" : { \"type\" : \"string\" , \"format\" : \"uri\" , \"description\" : \"Then set, the user will be redirected to this URL when hitting the logout link.\" }, \"newAccounts\" : { \"type\" : \"boolean\" , \"default\" : true } }, \"required\" : [ \"issuer\" , \"clientid\" , \"clientsecret\" , \"callbackURL\" ] } } } } } }, \"letsEncrypt\" : { \"title\" : \"Built-in Let's Encrypt support\" , \"description\" : \"If your server has a proper DNS name and it public facing on the Internet with a public facing HTTP server on port 80, you can get a free TLS certificate.\" , \"type\" : \"object\" , \"additionalProperties\" : false , \"properties\" : { \"email\" : { \"type\" : \"string\" , \"format\" : \"email\" , \"description\" : \"Email address of the administrator of this server. Make sure this is a valid email address otherwise the certificate request will fail.\" }, \"names\" : { \"type\" : \"string\" }, \"skipChallengeVerification\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"By default, MeshCentral will perform a self-test to make sure HTTP port 80 can respond correctly before making a request to Let's Encrypt. In some cases, this self-test can't work and must be skipped.\" }, \"production\" : { \"type\" : \"boolean\" , \"default\" : false , \"description\" : \"By default a test certificate will be obtained from Let's Encrypt. Always start by getting a test certificate and make sure that works before setting this to true and obtaining a production certificaite. Making too many bad requests for a production certificate will get you banned for a long period of time.\" } }, \"required\" : [ \"email\" , \"names\" ] }, \"peers\" : { \"title\" : \"Server peering\" , \"description\" : \"Setup peer server for load-balancing between many servers.\" , \"type\" : \"object\" , \"minProperties\" : 1 , \"propertyNames\" : { \"pattern\" : \"^[A-Za-z_][A-Za-z0-9_]*$\" }, \"additionalProperties\" : false , \"properties\" : { \"serverId\" : { \"type\" : \"string\" }, \"servers\" : { \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"object\" , \"properties\" : { \"url\" : { \"type\" : \"string\" , \"format\" : \"uri\" } }, \"required\" : [ \"url\" ] } } }, \"required\" : [ \"serverId\" , \"servers\" ] }, \"sendgrid\" : { \"title\" : \"SendGrid.com Email server\" , \"description\" : \"Connects MeshCentral to the SendGrid email server, allows MeshCentral to send email messages for 2FA or user notification.\" , \"type\" : \"object\" , \"properties\" : { \"from\" : { \"type\" : \"string\" , \"format\" : \"email\" , \"description\" : \"Email address used in the messages from field.\" }, \"apikey\" : { \"type\" : \"string\" , \"description\" : \"The SendGrid API key.\" }, \"verifyemail\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, the email format and DNS MX record are not checked.\" } }, \"required\" : [ \"from\" , \"apikey\" ] }, \"smtp\" : { \"title\" : \"SMTP email server\" , \"description\" : \"Connects MeshCentral to a SMTP email server, allows MeshCentral to send email messages for 2FA or user notification.\" , \"type\" : \"object\" , \"properties\" : { \"host\" : { \"type\" : \"string\" , \"format\" : \"hostname\" }, \"port\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 }, \"from\" : { \"type\" : \"string\" , \"format\" : \"email\" , \"description\" : \"Email address used in the messages from field.\" }, \"tls\" : { \"type\" : \"boolean\" }, \"tlscertcheck\" : { \"type\" : \"boolean\" }, \"tlsstrict\" : { \"type\" : \"boolean\" }, \"verifyemail\" : { \"type\" : \"boolean\" , \"default\" : true , \"description\" : \"When set to false, the email format and DNS MX record are not checked.\" } }, \"required\" : [ \"host\" , \"port\" , \"from\" , \"tls\" ] }, \"sms\" : { \"title\" : \"SMS provider\" , \"description\" : \"Connects MeshCentral to a SMS text messaging provider, allows MeshCentral to send SMS messages for 2FA or user notification.\" , \"oneOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"provider\" : { \"type\" : \"string\" , \"enum\" : [ \"twilio\" ] }, \"sid\" : { \"type\" : \"string\" }, \"auth\" : { \"type\" : \"string\" }, \"from\" : { \"type\" : \"string\" } }, \"required\" : [ \"provider\" , \"sid\" , \"auth\" , \"from\" ] }, { \"type\" : \"object\" , \"properties\" : { \"provider\" : { \"type\" : \"string\" , \"enum\" : [ \"plivo\" ] }, \"id\" : { \"type\" : \"string\" }, \"token\" : { \"type\" : \"string\" }, \"from\" : { \"type\" : \"string\" } }, \"required\" : [ \"provider\" , \"id\" , \"token\" , \"from\" ] }, { \"type\" : \"object\" , \"properties\" : { \"provider\" : { \"type\" : \"string\" , \"enum\" : [ \"telnyx\" ] }, \"apikey\" : { \"type\" : \"string\" }, \"from\" : { \"type\" : \"string\" } }, \"required\" : [ \"provider\" , \"apikey\" , \"from\" ] } ] } }, \"required\" : [ \"settings\" , \"domains\" ] }","title":"Configuration Options"},{"location":"meshcentral/debugging/","text":"Websockets Video \u00b6 Make sure you understand how MeshCentral works with your browser using chrome developer tools. MeshCentral Server \u00b6 Useful config.js settings \u00b6 https://github.com/Ylianst/MeshCentral/blob/master/meshcentral-config-schema.json \"AgentsInRAM\" : false , \"AgentUpdateBlockSize\" : 2048 , \"agentUpdateSystem\" : 1 , \"noAgentUpdate\" : 1 , \"WsCompression\" : false , \"AgentWsCompression\" : false , Enabling trace in your browser Dev Tools \u00b6 Trace=1 as a parameter in chrome dev tools for debugging To log all database queries, change log_statement in /etc/postgresql/13/main/postgresql.conf # CUSTOM log_statement = 'all' # none, ddl, mod, all The stacktrace was logged to stdout/journalctl . Supposedly, you can enable debug logging for node modules by adding DEBUG=<modulename> to the environment. Adding this to /etc/systemd/system/meshcentral.service should do it but it didn't seem to do anything. I think that's because Mesh uses the trace logging in the browser instead of logging things in the server logs. Environment=DEBUG=mesh* If you want to change node to meshcentral in journalctl, add this to /etc/systemd/system/meshcentral.service. SyslogIdentifier=meshcentral Logging it all \u00b6 To log everything that's possible, prepare the log directory. mkdir /meshcentral/meshcentral-logs/ chown tactical:tactical logs ln -s ../meshcentral-logs/log.txt /meshcentral/meshcentral-data/log.txt And then add this to your config. \"meshErrorLogPath\" : \"/meshcentral/meshcentral-logs/\" , \"authLog\" : \"/meshcentral/meshcentral-logs/auth.log\" , \"log\" : [ \"cookie\" , \"dispatch\" , \"main\" , \"peer\" , \"web\" , \"webrequest\" , \"relay\" , \"webrelaydata\" , \"webrelay\" , \"mps\" , \"mpscmd\" , \"swarm\" , \"swarmcmd\" , \"agentupdate\" , \"agent\" , \"cert\" , \"db\" , \"email\" , \"amt\" , \"httpheaders\" , \"websocket\" ], You'll then have 3 files: -rw-rw-r-- 1 tactical tactical 2593 Feb 2 12 :22 auth.log -rw-r--r-- 1 tactical tactical 147593 Feb 2 12 :31 log.txt -rw-rw-r-- 1 tactical tactical 381 Feb 2 12 :02 mesherrors.txt log.txt will now log everything in the Trace tab Restricting server to specific IP(s) \u00b6 When doing debugging on my development server, I use this line in the settings section to block all agent connections except the agent I want: \"agentAllowedIp\": [ \"192.168.2.147\" ], Of course, this is just for debugging. Finding system ID types \u00b6 https://serverurl/meshagents aka trying figure out what this is Pull down cert .crt file from internet \u00b6 See #1662 We have run into this challenge before, where our .crt file expired and then all our agents were unable to connect. In our case, the TLS cert was available on the internet, and thus, we were able to use these commands to update it: echo -n \\| openssl s_client -connect yourdomain.com:443 2 > /dev/null \\| sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > /opt/meshcentral/meshcentral-data/webserver-cert-public.crt service meshcentral restart MeshAgent \u00b6 Agent Debug Logs to server \u00b6 This automatically downloads all agent error logs into meshcentral-data/agenterrorlogs.txt Set in config.json \"agentLogDump\" : true Determine Agent capabilities \u00b6 On the server goto the agents console tab. Type: info Useful MeshAgent.msh flags \u00b6 https://github.com/Ylianst/MeshAgent/blob/master/meshcore/agentcore.h#L190 co ntr olCha nnel Debug= 1 logUpda te = 1 Obtain generated .msh File \u00b6 If you need a trick to get the .msh file, you can add ?debug=1 to the URL and click \"Add Agent\", there will be an extra link to download it. MeshAgent Commands \u00b6 MeshAgent run MeshAgent dbTool.js list Forcing Core version from Cmdline Download meschore.js and rename to CoreModule.js and put it alongside MeshAgent.exe Stop MeshAgent service Run MeshAgent.exe dbTool.js import CoreModule On the fly Patching MeshAgent \u00b6 MeshAgent#89 (comment) There are two ways to do this... When debugging, and making changes, you can modify the .js file directly, and just save it in the same folder as the agent binary... The agent will use the .js file from disc if it's there, if it's newer than the one compiled in the binary. You don't even need to restart the agent. You can just clear the core, and reload the core..... When you are satisfied with your changes to the .js file, you can use the clipboard, in the following fashion: meshagent -exec \"require('clipboard').nativeAddCompressedModule('foo');process.exit();\" if the file you modified isn't in the same folder as the agent binary, you can use the following command if you don't want to move the file, and edit it directly in the modules folder: meshagent -exec \"setModulePath('pathToFolder');require('clipboard').nativeAddCompressedModule('foo');process.exit();\" This command is just like the previous, except it searches for modules in the path specified. Just substitute foo, with the name of the module that you modified. It will load the module from disc, compress it, and save it into the clipboard.. So you can just load up your editor for ILibDuktape_Polyfills.c, and find where that particular module is defined... and paste directly from the clipboard... The clipboard will contain all the necessary C code to uncompress and load the module. If the compressed result is relatively long, it will auto break it up into multiple lines to work around an issue with visual studio's maximum string literal limitations. Agent Debugging using MeshCore JS Debugger \u00b6 (#119) How to test changes to the meshagent and recompile them. Copy duktape-debugger.js to the mesh directory on the target machine. From the console tab of the agent, enter this command, substituting the port number you want to use instead of 9999 eval \"attachDebugger({ webport: 9999 })\" Then open your browser to http://localhost:9999 or whatever port you used. Note If you pause the debugger, and happen to forget about it, the agent will automatically kill itself and restart because it will think that a thread is stuck. Default debugger timeout is 10 minutes, you may find a log entry saved to disk saying \"Microstack Thread STUCK\", or something similar.","title":"Debugging"},{"location":"meshcentral/debugging/#websockets-video","text":"Make sure you understand how MeshCentral works with your browser using chrome developer tools.","title":"Websockets Video"},{"location":"meshcentral/debugging/#meshcentral-server","text":"","title":"MeshCentral Server"},{"location":"meshcentral/debugging/#useful-configjs-settings","text":"https://github.com/Ylianst/MeshCentral/blob/master/meshcentral-config-schema.json \"AgentsInRAM\" : false , \"AgentUpdateBlockSize\" : 2048 , \"agentUpdateSystem\" : 1 , \"noAgentUpdate\" : 1 , \"WsCompression\" : false , \"AgentWsCompression\" : false ,","title":"Useful config.js settings"},{"location":"meshcentral/debugging/#enabling-trace-in-your-browser-dev-tools","text":"Trace=1 as a parameter in chrome dev tools for debugging To log all database queries, change log_statement in /etc/postgresql/13/main/postgresql.conf # CUSTOM log_statement = 'all' # none, ddl, mod, all The stacktrace was logged to stdout/journalctl . Supposedly, you can enable debug logging for node modules by adding DEBUG=<modulename> to the environment. Adding this to /etc/systemd/system/meshcentral.service should do it but it didn't seem to do anything. I think that's because Mesh uses the trace logging in the browser instead of logging things in the server logs. Environment=DEBUG=mesh* If you want to change node to meshcentral in journalctl, add this to /etc/systemd/system/meshcentral.service. SyslogIdentifier=meshcentral","title":"Enabling trace in your browser Dev Tools"},{"location":"meshcentral/debugging/#logging-it-all","text":"To log everything that's possible, prepare the log directory. mkdir /meshcentral/meshcentral-logs/ chown tactical:tactical logs ln -s ../meshcentral-logs/log.txt /meshcentral/meshcentral-data/log.txt And then add this to your config. \"meshErrorLogPath\" : \"/meshcentral/meshcentral-logs/\" , \"authLog\" : \"/meshcentral/meshcentral-logs/auth.log\" , \"log\" : [ \"cookie\" , \"dispatch\" , \"main\" , \"peer\" , \"web\" , \"webrequest\" , \"relay\" , \"webrelaydata\" , \"webrelay\" , \"mps\" , \"mpscmd\" , \"swarm\" , \"swarmcmd\" , \"agentupdate\" , \"agent\" , \"cert\" , \"db\" , \"email\" , \"amt\" , \"httpheaders\" , \"websocket\" ], You'll then have 3 files: -rw-rw-r-- 1 tactical tactical 2593 Feb 2 12 :22 auth.log -rw-r--r-- 1 tactical tactical 147593 Feb 2 12 :31 log.txt -rw-rw-r-- 1 tactical tactical 381 Feb 2 12 :02 mesherrors.txt log.txt will now log everything in the Trace tab","title":"Logging it all"},{"location":"meshcentral/debugging/#restricting-server-to-specific-ips","text":"When doing debugging on my development server, I use this line in the settings section to block all agent connections except the agent I want: \"agentAllowedIp\": [ \"192.168.2.147\" ], Of course, this is just for debugging.","title":"Restricting server to specific IP(s)"},{"location":"meshcentral/debugging/#finding-system-id-types","text":"https://serverurl/meshagents aka trying figure out what this is","title":"Finding system ID types"},{"location":"meshcentral/debugging/#pull-down-cert-crt-file-from-internet","text":"See #1662 We have run into this challenge before, where our .crt file expired and then all our agents were unable to connect. In our case, the TLS cert was available on the internet, and thus, we were able to use these commands to update it: echo -n \\| openssl s_client -connect yourdomain.com:443 2 > /dev/null \\| sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > /opt/meshcentral/meshcentral-data/webserver-cert-public.crt service meshcentral restart","title":"Pull down cert .crt file from internet"},{"location":"meshcentral/debugging/#meshagent","text":"","title":"MeshAgent"},{"location":"meshcentral/debugging/#agent-debug-logs-to-server","text":"This automatically downloads all agent error logs into meshcentral-data/agenterrorlogs.txt Set in config.json \"agentLogDump\" : true","title":"Agent Debug Logs to server"},{"location":"meshcentral/debugging/#determine-agent-capabilities","text":"On the server goto the agents console tab. Type: info","title":"Determine Agent capabilities"},{"location":"meshcentral/debugging/#useful-meshagentmsh-flags","text":"https://github.com/Ylianst/MeshAgent/blob/master/meshcore/agentcore.h#L190 co ntr olCha nnel Debug= 1 logUpda te = 1","title":"Useful MeshAgent.msh flags"},{"location":"meshcentral/debugging/#obtain-generated-msh-file","text":"If you need a trick to get the .msh file, you can add ?debug=1 to the URL and click \"Add Agent\", there will be an extra link to download it.","title":"Obtain generated .msh File"},{"location":"meshcentral/debugging/#meshagent-commands","text":"MeshAgent run MeshAgent dbTool.js list Forcing Core version from Cmdline Download meschore.js and rename to CoreModule.js and put it alongside MeshAgent.exe Stop MeshAgent service Run MeshAgent.exe dbTool.js import CoreModule","title":"MeshAgent Commands"},{"location":"meshcentral/debugging/#on-the-fly-patching-meshagent","text":"MeshAgent#89 (comment) There are two ways to do this... When debugging, and making changes, you can modify the .js file directly, and just save it in the same folder as the agent binary... The agent will use the .js file from disc if it's there, if it's newer than the one compiled in the binary. You don't even need to restart the agent. You can just clear the core, and reload the core..... When you are satisfied with your changes to the .js file, you can use the clipboard, in the following fashion: meshagent -exec \"require('clipboard').nativeAddCompressedModule('foo');process.exit();\" if the file you modified isn't in the same folder as the agent binary, you can use the following command if you don't want to move the file, and edit it directly in the modules folder: meshagent -exec \"setModulePath('pathToFolder');require('clipboard').nativeAddCompressedModule('foo');process.exit();\" This command is just like the previous, except it searches for modules in the path specified. Just substitute foo, with the name of the module that you modified. It will load the module from disc, compress it, and save it into the clipboard.. So you can just load up your editor for ILibDuktape_Polyfills.c, and find where that particular module is defined... and paste directly from the clipboard... The clipboard will contain all the necessary C code to uncompress and load the module. If the compressed result is relatively long, it will auto break it up into multiple lines to work around an issue with visual studio's maximum string literal limitations.","title":"On the fly Patching MeshAgent"},{"location":"meshcentral/debugging/#agent-debugging-using-meshcore-js-debugger","text":"(#119) How to test changes to the meshagent and recompile them. Copy duktape-debugger.js to the mesh directory on the target machine. From the console tab of the agent, enter this command, substituting the port number you want to use instead of 9999 eval \"attachDebugger({ webport: 9999 })\" Then open your browser to http://localhost:9999 or whatever port you used. Note If you pause the debugger, and happen to forget about it, the agent will automatically kill itself and restart because it will think that a thread is stuck. Default debugger timeout is 10 minutes, you may find a log entry saved to disk saying \"Microstack Thread STUCK\", or something similar.","title":"Agent Debugging using MeshCore JS Debugger"},{"location":"meshcentral/devicetabs/","text":"Device Tabs \u00b6 General \u00b6 For viewing general information about the agent Group Description IP-KVM Port Number IP-KVM Port Type Intel AMT Intel AMT Tag Mesh Agent Operating System Windows Security Antivirus Active User User Consent Notifications Tags Fields \u00b6 Buttons \u00b6 Actions Notes Log Event Message PDU On/Off/Control Chat 7 Day Power State \u00b6 Legend Black color : Device is powered on (Intel AMT & agents) Purple color : Device is in sleep state (Intel AMT agents only) Teal color : Device is connected through AMT/CIRA, but not powered on (Intel AMT agents only) Grey color : Device is powered off (Intel AMT & agents) Text Links \u00b6 You can set alternate port in the link if it's not default by right-clicking. Interfaces Location MeshCmd RDP Web-VNC Web-RDP Web-SSH XTerm HTTP HTTPS SSH SCP MQTT Login Desktop \u00b6 For connecting to the machines KVM interface. Connect Button \u00b6 Right-clicking on Connect button will give you additional options: Ask Consent + Bar Ask Consent Privacy Bar RDP Connect Button \u00b6 Right-clicking on RDP Connect button allows you to specify Alternate Port. Intel AMT Connect Button \u00b6 Uses Intel AMT to control video output of the hardware video card. Terminal \u00b6 For connecting to a command line based interface on the agent Right-clicking on Connect button allows you to: Note Linux and Windows have different options: Admin Shell (Windows) Admin Powershell (Windows) User Shell (Windows) User Powershell (Windows) SSH (Linux) Files \u00b6 For transferring files to and from the agent. Events \u00b6 Mesh Events related to the agent. This is your audit log to see what actions have been taken on the agent from the MeshCentral server. Details \u00b6 Agent information that includes: OS Agent Info Network Info BIOS Motherboard Memory Storage Intel AMT Note you can show CPU and Memory usage info by clicking the icon in the top right corner Intel AMT \u00b6 Console \u00b6 For debugging and communicating with the mesh agent. It allows JS commands to be issued to the device but also run extra commands from the meshcore. Type help for all available options","title":"Device Tabs"},{"location":"meshcentral/devicetabs/#device-tabs","text":"","title":"Device Tabs"},{"location":"meshcentral/devicetabs/#general","text":"For viewing general information about the agent Group Description IP-KVM Port Number IP-KVM Port Type Intel AMT Intel AMT Tag Mesh Agent Operating System Windows Security Antivirus Active User User Consent Notifications Tags","title":"General"},{"location":"meshcentral/devicetabs/#fields","text":"","title":"Fields"},{"location":"meshcentral/devicetabs/#buttons","text":"Actions Notes Log Event Message PDU On/Off/Control Chat","title":"Buttons"},{"location":"meshcentral/devicetabs/#7-day-power-state","text":"Legend Black color : Device is powered on (Intel AMT & agents) Purple color : Device is in sleep state (Intel AMT agents only) Teal color : Device is connected through AMT/CIRA, but not powered on (Intel AMT agents only) Grey color : Device is powered off (Intel AMT & agents)","title":"7 Day Power State"},{"location":"meshcentral/devicetabs/#text-links","text":"You can set alternate port in the link if it's not default by right-clicking. Interfaces Location MeshCmd RDP Web-VNC Web-RDP Web-SSH XTerm HTTP HTTPS SSH SCP MQTT Login","title":"Text Links"},{"location":"meshcentral/devicetabs/#desktop","text":"For connecting to the machines KVM interface.","title":"Desktop"},{"location":"meshcentral/devicetabs/#connect-button","text":"Right-clicking on Connect button will give you additional options: Ask Consent + Bar Ask Consent Privacy Bar","title":"Connect Button"},{"location":"meshcentral/devicetabs/#rdp-connect-button","text":"Right-clicking on RDP Connect button allows you to specify Alternate Port.","title":"RDP Connect Button"},{"location":"meshcentral/devicetabs/#intel-amt-connect-button","text":"Uses Intel AMT to control video output of the hardware video card.","title":"Intel AMT Connect Button"},{"location":"meshcentral/devicetabs/#terminal","text":"For connecting to a command line based interface on the agent Right-clicking on Connect button allows you to: Note Linux and Windows have different options: Admin Shell (Windows) Admin Powershell (Windows) User Shell (Windows) User Powershell (Windows) SSH (Linux)","title":"Terminal"},{"location":"meshcentral/devicetabs/#files","text":"For transferring files to and from the agent.","title":"Files"},{"location":"meshcentral/devicetabs/#events","text":"Mesh Events related to the agent. This is your audit log to see what actions have been taken on the agent from the MeshCentral server.","title":"Events"},{"location":"meshcentral/devicetabs/#details","text":"Agent information that includes: OS Agent Info Network Info BIOS Motherboard Memory Storage Intel AMT Note you can show CPU and Memory usage info by clicking the icon in the top right corner","title":"Details"},{"location":"meshcentral/devicetabs/#intel-amt","text":"","title":"Intel AMT"},{"location":"meshcentral/devicetabs/#console","text":"For debugging and communicating with the mesh agent. It allows JS commands to be issued to the device but also run extra commands from the meshcore. Type help for all available options","title":"Console"},{"location":"meshcentral/plugins/","text":"Plugins \u00b6 Installation \u00b6 Enable plugins in the configuration and restart MC as described. Log into MC as full administrator. Go my My Server -> Plugins , hit the Download plugin button. A dialog opens requesting an URL, put in: https://github.com/ryanblenis/MeshCentral-ScriptTask The plugin pops up in the plugin list below the download button, you can now configure and enable/disable it.","title":"Plugins"},{"location":"meshcentral/plugins/#plugins","text":"","title":"Plugins"},{"location":"meshcentral/plugins/#installation","text":"Enable plugins in the configuration and restart MC as described. Log into MC as full administrator. Go my My Server -> Plugins , hit the Download plugin button. A dialog opens requesting an URL, put in: https://github.com/ryanblenis/MeshCentral-ScriptTask The plugin pops up in the plugin list below the download button, you can now configure and enable/disable it.","title":"Installation"},{"location":"meshcentral/tokens/","text":"14.1 Tokens \u00b6 User Tokens \u00b6 Software Integration Tokens \u00b6 Currently, the login tokens in the user manual section 14.1 can't be tracked, deleted or revoked. They are generated with: node meshcentral --loginTokenKey","title":"Tokens"},{"location":"meshcentral/tokens/#141-tokens","text":"","title":"14.1 Tokens"},{"location":"meshcentral/tokens/#user-tokens","text":"","title":"User Tokens"},{"location":"meshcentral/tokens/#software-integration-tokens","text":"Currently, the login tokens in the user manual section 14.1 can't be tracked, deleted or revoked. They are generated with: node meshcentral --loginTokenKey","title":"Software Integration Tokens"},{"location":"meshcmd/","text":"MeshCmd \u00b6 MeshCmd Guide as .pdf as .odt Video Walkthru \u00b6 Abstract \u00b6 This user guide contains all essential information for the user to make full use of MeshCmd, a command line tool used to perform tasks on MeshCentral and for Intel\u00ae AMT. This tool run on Windows and Linux and perform a wide array of different tasks. From routing traffic over the Internet to activating Intel AMT, MeshCmd is a great do it all tool for computer management. Introduction \u00b6 MeshCmd, called \u201cMesh Command\u201d, is a command line tool that runs on both Windows and Linux and used to perform many tasks related to computer management. As the tool continues to evolve, it will continue to be improved and acquire more features. Broadly, the tool is intended to perform three sets of tasks. MeshCentral2 command line operations - There are command line operations that relate to interacting with the MeshCentral2 server. A good example of this is to route traffic from your computer to a remote computer on the internet thru a MeshCentral2 server. Intel AMT local actions - If you happen to have Intel AMT on your computer, MeshCmd can take a look at the version and activation status, activate and de-activate Intel AMT and help with getting access to Intel AMT and more. Intel AMT remote actions - Whether you have Intel AMT on your local computer or a remote computer on your network, MeshCmd can help unlock the features Intel AMT provides. From getting the state of Intel AMT remotely to running configuration scripts and loading MeshCommander into Intel AMT web storage. To get started, you need to download MeshCmd for your computer. MeshCmd is a single file executable that you can get on MeshCommander.com at: http://www.meshcommander.com/meshcommander/meshcmd If you have access to a MeshCentral2 server, the download link to MeshCmd is at the bottom left of the main device page. Once you click on the \u201cMeshCmd\u201d link, a dialog box will allow you to select the operating system you want to get a link to MeshCmd. MeshCentral will also provide an action file called meshaction.txt that contains information on how MeshCmd can connect back to that MeshCentral server. This is optional, and only used for some operations. Once downloaded, just run it from the command prompt or terminal window. C:\\Temp>meshcmd MeshCentral Command (MeshCmd) No action specified, use MeshCmd like this: meshcmd [action] [arguments...] Valid MeshCentral actions: Route - Map a local TCP port to a remote computer. Valid local actions: SMBios - Display System Management BIOS tables for this computer. RawSMBios - Display RAW System Management BIOS tables for this computer. MicroLMS - Run MicroLMS, allowing local access to Intel AMT. AmtInfo - Show Intel AMT version and activation state. AmtVersions - Show all Intel ME version information. AmtHashes - Show all Intel AMT trusted activation hashes. AmtCCM - Activate Intel AMT into Client Control Mode. AmtACM - Activate Intel AMT into Admin Control Mode. AmtDeactivate - Deactivate Intel AMT if activated in Client Control mode. AmtAcmDeactivate - Deactivate Intel AMT if activated in Admin Control mode. Valid local or remote actions: MeshCommander - Launch a local MeshCommander web server. AmtUUID - Show Intel AMT unique identifier. AmtAuditLog - Show the Intel AMT audit log. AmtLoadWebApp - Load MeshCommander in Intel AMT 11.6+ firmware. AmtClearWebApp - Clear everything from Intel AMT web storage. AmtStorageState - Show contents of the Intel AMT web storage. AmtSaveState - Save all Intel AMT WSMAN object to file. AmtPresence - Heartbeat a local Intel AMT watchdog agent. AmtScript - Run .mescript on Intel AMT. AmtIDER - Mount local disk image to remote computer. Help on a specific action using: meshcmd help [action] By default you will get the help screen with all of the different actions you can take with the tool. You can also get help by typing \u201chelp\u201d followed by the action name. In this document we will cover the main actions that MeshCmd can perform. If you don\u2019t use Intel AMT at all, then only the MeshCentral actions are interesting for you. If you use Intel AMT, the rest of the actions will be of interest to you. MeshCentral TCP port mapping \u00b6 MeshCmd can map a TCP port from your local computer to any remote port on any computer with one of your MeshAgents installed. This port mapping will work over a local network or the Internet and should work even thru proxies and firewalls. In order to start using MeshCmd in this way, you first need to have access to a MeshCentral server and at least one computer you already manage. TCP port mapping works by selecting a port on your local computer that will be routed to a remote device and port. Here, local port 123 is routed thru the server to port 123 on a remote device. Of course, this picture is a bit simplify. Firewalls, NAT routers and HTTP proxies may be in the way and the MeshAgent on the remote computer will act at the TCP traffic relay in most cases. One typical use of this is to route local port 1234 to port Microsoft RDP port 3389 on a remote device. Once routed, you can start a RDP session on \u201clocalhost:1234\u201d and get a RDP session to the remote device. The RDP protocol is feature rich and efficient, so you get a great user experience regardless of where in the world the remote computer is at. To get started, click on a device in MeshCentral and click on the \u201cRouter\u201d link on the bottom left of the device page. You can download MeshCmd is you have not done so already, but more importantly, download the action.txt file. The file is in text format and contain something like this: { \"action\" : \"route\" , \"localPort\" : 1234 , \uf0df Cha n ge t his \"remoteName\" : \"AmtMachine7\" , \"remoteNodeId\" : \"node//@yw$s5jLUivpzZ49laprt4T0sBaOKImbDAiniothQwccZPukCB696$BvPWAW0Bg2\" , \"remotePort\" : 3389 , \uf0df Cha n ge t his \"username\" : \"admin\" , \"password\" : \"\" , \uf0df No te t ha t t he password is emp t y \"serverId\" : \"D99362D5ED8BAEA8BF9E743B34B242256370C460FD66CB62373C6CFCB204D6D70 7403E396CF0EF6DC2B3A42F735135FD\" , \"serverHttpsHash\" : \"D9DE9E27A229B5355708A3672FB23237CC994A680B3570D242A91E36B4AE5BC 96539E59746E2B71EEF3DBDABBF2AE138\" , \"debugLevel\" : 0 , \"serverUrl\" : \"wss://devbox.mesh.meshcentral.com:443/meshrelay.ashx\" } The action file contains almost all the parameters needed to perform the route. It indicates the local and remote ports, the remote computer unique identifier, server location and authentication information and more. You can just put the action file in the same folder as MeshCmd and run MeshCmd, it will automatically pick up the arguments from the meshaction.txt file. You may want to change the local and remote port in the action file to suite your needs. Be default, the Microsoft RDP port is the target. If the password is not specified in the meshaction.txt file, you can also specify it as a meshcmd argument. C:\\MeshCmd>meshcmd --pass xxxxxxxx Redirecting local port 1234 to AmtMachine7:3389. Press ctrl-c to exit. Now, the traffic router is ready. You can now RDP to localhost:1234 and login to the remote computer. MeshCommander \u00b6 MeshCommander is a web based Intel AMT management console. MeshCmd has no less then three different versions of MeshCommander built-in, so if you are using Intel AMT, it\u2019s worth a moment to get some knowledge about MeshCommander which is available as a standalone tool along with a full user\u2019s guide at: http://www.meshcommander.com/ and also included as part of MeshCentral. The three versions included in MeshCmd are: MeshCommander as a local web server. MeshCommander for LMS MeshCommander for firmware. In this section, we review the three versions, how they are used and what can be done with them. MeshCommander local web server \u00b6 You can start MeshCommander on a local web server by typing \u201cmeshcmd meshcommander\u201d. By default, local port 3000 is used, but you can optionally specify the port using \u201c--localport [port]\u201d. Running it with look like this: C:\\MeshCmd>meshcmd meshcommander MeshCommander running on HTTP port 3000. Ctrl-C to exit. Once running, use a web browser and go to \u201chttp://localhost:3000\u201d to see the MeshCommander web page. The page will start out without any computers in it and you will have to add some. In this mode, the local computers that are added will be stored in the browser\u2019s storage cache. So, clearing the browser\u2019s cache will also clear the list of computers. You can however load and save the list of computers using the \u201cOpen\u2026\u201d and \u201cSave\u2026\u201d buttons. This version of MeshCommander will have some limitations when compared to the full version installed using the Windows .MSI installer. Notably: No certificate management or validation. Mutual-Authenticated TLS is not supported. Kerberos authentication is not supported. IDE-R is not supported. This said, features like KVM, Terminal and most Intel AMT configuration options are available which makes this a fairly powerful Intel AMT management console. You can run MeshCommander as a background server on both Windows and Linux. To do this, use the install, uninstall, start and stop commands like this: C:\\MeshCmd>meshcmd meshcommander install Installing to \"C:\\Program Files (x86)\\Open Source\\MeshCmd\\MeshCommander.exe\" MeshCommander installed. C:\\MeshCmd>meshcmd meshcommander start MeshCommander starting. On Linux computers, both systemd and initd are supported. When installing, the MeshCmd executable will be copied to a different installation folder. LMS & MeshCommander \u00b6 The Layered Management Service (LMS) is a background process that runs in the operating system and provides local OS access to Intel AMT. More specifically, it redirects local TCP ports 16992 and 16993 to Intel AMT thru the MEI driver. One way to check if the LMS service is installed on your computer is to try http://localhost:16992 or https://localhost:16993 in a browser. A page should generally show up. On Windows, LMS is a Windows service that must be downloaded and installed as part of the OEM drivers for a computer. On Linux, it\u2019s generally never installed and users normally have to download the source code and compile it themselves. MeshCmd has its own LMS implementation, so is LMS is not installed it will automatically use its own internal one. In addition, you can run MicroLMS alone by typing the following list while running as root or local administrator: C:\\MeshCmd>meshcmd microlms MicroLMS started, MeshCommander on HTTP/16994. This will start MicroLMS and as indicated, start MeshCommander on local port 16994 at the same time. In total, traffic redirection looks like this: In addition to providing normal services, MicroLMS that is part of MeshCmd will also start a web server on port 16994 and allow a browser to access LMS MeshCommander, a special version of MeshCommander specially made to run in this situation. MeshCommander for LMS will show up even if the computer has Intel AMT un-configured and offer the user the choice to activate Intel AMT and perform configuration actions. In the following screen, we see a computer activated in Client Control Mode. Because it\u2019s in this mode, you can use the web interface to de-activate Intel AMT or login to perform additional configuration. MicroLMS along with MeshCommander for LMS is very useful, especially on Linux as it offers a single tool to setup and configuration Intel AMT. If you wish you run MicroLMS without MeshCommander being available on port 16994, run MeshCmd with \u201c--noconsole\": C:\\MeshCmd>meshcmd microlms --noconsole MicroLMS started. You can run MicroLMS as a background server on both Windows and Linux. To do this, use the MicroLMS install, uninstall, start and stop commands like this: C:\\MeshCmd>meshcmd microlms install Installing to \"C:\\Program Files (x86)\\Open Source\\MeshCmd\\MicroLMS.exe\" MicroLMS installed. C:\\MeshCmd>meshcmd microlms start MicroLMS starting. On Linux computers, both systemd and initd are supported. When installing, the MeshCmd executable will be copied to a different installation folder. MeshCommander for firmware \u00b6 MeshCmd also includes a surprising version of MeshCommander, the one you can load into the firmware of Intel AMT. Starting with Intel AMT 11.6, you can push into the small ~190k storage space of Intel AMT a replacement to the index.htm page served by the firmware on port 16992 & 16993. In the following picture, the left side is the original Intel AMT web page, the right is the replaced MeshCommander built to go in firmware. The firmware version of MeshCommander has support for remote desktop, terminal and all sorts of Intel AMT usages and configuration. Probably the most surprising is that this entire page is between 40k and 100k depending on the version you select. It\u2019s notable that with MeshCommander loaded into Intel AMT firmware, one does not need any other tool except for a browser to perform most Intel AMT maintenance operations. C:\\MeshCmd>meshcmd amtloadwebapp --host 192.168.2.144 --pass xxxxxxxx Uploading MeshCommander... Verifying MeshCommander... Done. To get the current state of Intel AMT web storage, type this: C:\\MeshCmd>meshcmd amtstoragestate --host 192.168.2.144 --pass xxxxxxxx Storage State: { \"information\": { \"version\": 1, \"realms\": 7765759, \"user\": \"admin\" }, \"content\": { \"index.htm\": { \"size\": 57246 \uf0df Replacement index.htm with size. } } } Here, a 57k index.htm replacement is present in the Intel AMT flash. You can clear the web storage, revering the web page back to the original like this: C:\\MeshCmd>meshcmd amtclearwebapp --host 192.168.2.144 --pass xxxxxxxx Done. When MeshCommander is loaded into Intel AMT, you can access it from a different computer using http://computername:16992 or https://computername:16993 You will need to authenticate first before getting access to the web page. Intel AMT state & activation \u00b6 MeshCmd can easily be used to read the local state of the computer and Intel AMT. There are many commands available to do this. The \u201cSMBios\u201d action works on most computers and is used to get basic information about your current system. The output is JSON format. C : \\MeshCmd>meshcmd smbios { processorI nf o : { 0 : { Processor : \"CPU\" MaxSpeed : \"3800 Mhz\" Cores : 4 Threads : 8 Popula te d : 1 S tatus : \"Enabled\" Socke t : \"CPU 1\" Ma nufa c turer : \"Intel(R) Corporation\" Versio n : \"Intel(R) Core(TM) i7-3770 CPU @ 3.40GHz\" } } memoryI nf o : { loca t io n : \"System Board\" maxCapaci t yKb : 33554432 } sys te mI nf o : { uuid : \"C57B83D9A94E11E18BA1505054503030\" wakeReaso n : \"Power Switch\" } sys te mSlo ts : { uuid : \"C57B83D9A94E11E18BA1505054503030\" wakeReaso n : \"Power Switch\" } am t I nf o : { AMT : true e na bled : true s t orageRedirec t io n : true serialOverLa n : true kvm : true TXT : false VMX : true MEBX : \"66.0.0.8\" Ma na geme nt E n gi ne : \"8.1.0.57353\" } } If you have Intel AMT on your system, you can use the \u201camtinfo\u201d, \u201camtversions\u201d and \u201camthashes\u201d to get lots of information about Intel AMT current state. These commands use the Intel AMT MEI driver to get this information and require MeshCmd be run as root or administrator: C:\\MeshCmd>meshcmd amtinfo Intel AMT v8.1.71, activated in client control mode. Wired Enabled, DHCP, 00:1E:8C:F5:4F:ED, 192.168.2.10. C:\\MeshCmd>meshcmd amtversions MEI Version = MKQ7710H.86A.0072.2017.0519.1347 Flash = 8.1.71 Netstack = 8.1.71 AMTApps = 8.1.71 AMT = 8.1.71 Sku = 24584 VendorID = 8086 Build Number = 3608 Recovery Version = 8.1.71 Recovery Build Num = 3608 Legacy Mode = False C:\\MeshCmd>meshcmd amthashes VeriSign Class 3 Primary CA-G1, (Default, Active) SHA256: E7685634EFACF69ACE939A6B255B7B4FABEF42935B50A265ACB5CB6027E44E70 VeriSign Class 3 Primary CA-G3, (Default, Active) SHA256: EB04CF5EB1F39AFA762F2BB120F296CBA520C1B97DB1589565B81CB9A17B7244 \u2026 In addition to getting Intel AMT state, MeshCmd can activate Intel AMT in client control mode (CCM) and de-activate Intel AMT if it\u2019s in this mode. Doing this is very simple, starting with Intel AMT not being activated, you use the \u201camtccm\u201d and \u201camtdeactivate\u201d actions. C:\\MeshCmd>meshcmd amtinfo Intel AMT v8.1.71, pre-provisioning state. C:\\MeshCmd>meshcmd amtccm --pass xxxxxxxx Success C:\\MeshCmd>meshcmd amtinfo Intel AMT v8.1.71, activated in client control mode. C:\\MeshCmd>meshcmd amtdeactivate Success Note that when using the \u201camtccm\u201d action, you need to provide a password that will be used for authentication into Intel AMT. This password must be strong with at least 8 characters including a lower case, an uppercase, a numeric value and a non-alpha-numeric value. Intel AMT Audit Log \u00b6 One very useful feature of MeshCmd is its ability to fetch the Intel AMT audit log. This can be valuable when doing forensics on a computer or just trying figure out what is being done thru Intel AMT. MeshCmd can pull the audit log on a local computer without any credentials, as long as it\u2019s running as root or administrator, or pull the audit log remotely if usual credentials are provided. The Intel AMT audit log will show when a computer\u2019s Intel AMT was activated, when remote desktop sessions where initiated and more. To get the local audit log, just use the \u201cAmtAuditLog\u201d action. C:\\MeshCmd>meshcmd amtauditlog 2004-01-01 19:17:58.000-08:00 - Local: Provisioning Started 2018-01-26 14:03:16.000-08:00 - Local: Unprovisioning Started 2018-01-26 14:03:31.000-08:00 - Local: Provisioning Started 2018-02-01 12:13:14.000-08:00 - admin: KVM Enabled 2018-02-01 12:16:01.000-08:00 - admin: KVM Session Started 2018-02-01 12:16:07.000-08:00 - admin: KVM Session Ended 2018-02-02 10:56:06.000-08:00 - admin: KVM Session Started 2018-02-02 10:56:08.000-08:00 - admin: KVM Session Ended To get a remote audit log: C:\\MeshCmd>meshcmd amtauditlog --host 192.168.2.144 --user admin --pass xxxxxxxx 2003-12-31 23:06:58.000-08:00 - $$OsAdmin: Intel(r) ME Time Set 2017-08-15 06:53:31.000-07:00 - $$OsAdmin: Intel(r) ME Time Set 2017-10-13 17:55:11.000-07:00 - Local: Provisioning Started 2017-10-13 17:55:54.000-07:00 - Local: Opt-In Policy Change 2017-10-15 06:44:38.000-07:00 - admin: KVM Enabled You can also save the audit log to file using the \u201c--output\" option. Running Intel AMT script \u00b6 MeshCmd has a full WSMAN stack built-in and can be used to run \u201c.mescript\u201d file on a target Intel AMT computer. Script file are useful when you want to run a set of actions on one or more Intel AMT computers at once. You can build a .mescript file using the script editor within MeshCommander. This script editor allows the user to drag & drop script blocks, set parameters on each block and test the script against a connected Intel AMT computer. In addition to building your own scripts, you can download a CIRA setup script from a MeshCentral server. When running this script, Intel AMT will be setup to call back to the server using an encrypted connection. This enables remote management of Intel AMT over the Internet. The CIRA setup script is available in the \u201cAdd CIRA\u201d link for meshes that are Intel AMT only (no agent). Once you got the script, run it with MeshCmd like this. You specify the host if it\u2019s not localhost, the password and the script file. C:\\MeshCmd>meshcmd amtscript --host 192.168.2.106 --pass xxxxxxxx --script cira_setup.mescript Script Started Policies removed successfully Adding root certificate... Management Presence Server (MPS) successfully added Found matching (primary) mps: Intel(r) AMT:Management Presence Server 0 Setting policy... Policy added successfully Remote Access user interfaces set to: BIOS & OS Enabed Parsing block parameters Setting Environment Detection Environment Detection set successfully Script Completed In this example, the CIRA setup script was run on a remote computer. After the script is run, the computer got configured and connected back to the server. MeshCentral show the new connection state for this computer. IDE Redirection \u00b6 Video Walkthru \u00b6 MeshCmd has all the code needed to perform Intel AMT IDE Redirection from the command line. This allows disk images on the administrator\u2019s computer to be remotely mounted to an Intel AMT computer. You need to start with a floppy disk .img file and/or an .iso CDROM file. Then use the \u201cAmtIDER\u201d command of MeshCMD to start an IDER session. The help command for AmtIDER looks like this: C:\\Temp>meshcmd help amtider AmtIDER will mount a local disk images to a remote Intel AMT computer. Example usage: meshcmd amtider --host 1.2.3.4 --user admin --pass mypassword --tls --floppy disk.img --cdrom disk.iso Possible arguments: --host [hostname] The IP address or DNS name of Intel AMT. --user [username] The Intel AMT login username, admin is default. --pass [password] The Intel AMT login password. --tls Specifies that TLS must be used. --floppy [file] Specifies .img file to be mounted as a flppy disk. --cdrom [file] Specifies .img file to be mounted as a CDROM disk. --timeout [seconds] Optional, disconnect after number of seconds without disk read. The command is fairly simple. It takes as input a remote host, username/password for Intel AMT login, the disk images and TLS option. One can also specify the timeout option so that MeshCMD will automatically disconnect when no disk read operations are performed for a set number of seconds. Conclusion \u00b6 MeshCmd is a cross-platform command line tools that perform an ever-growing list of actions that are important for remote computer management. MeshCmd works alone or with MeshCentral and MeshCommander to offer a suite of free, opens source and powerful tools that work well together. License \u00b6 MeshCmd and this document are both opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0","title":"MeshCmd"},{"location":"meshcmd/#meshcmd","text":"MeshCmd Guide as .pdf as .odt","title":"MeshCmd"},{"location":"meshcmd/#video-walkthru","text":"","title":"Video Walkthru"},{"location":"meshcmd/#abstract","text":"This user guide contains all essential information for the user to make full use of MeshCmd, a command line tool used to perform tasks on MeshCentral and for Intel\u00ae AMT. This tool run on Windows and Linux and perform a wide array of different tasks. From routing traffic over the Internet to activating Intel AMT, MeshCmd is a great do it all tool for computer management.","title":"Abstract"},{"location":"meshcmd/#introduction","text":"MeshCmd, called \u201cMesh Command\u201d, is a command line tool that runs on both Windows and Linux and used to perform many tasks related to computer management. As the tool continues to evolve, it will continue to be improved and acquire more features. Broadly, the tool is intended to perform three sets of tasks. MeshCentral2 command line operations - There are command line operations that relate to interacting with the MeshCentral2 server. A good example of this is to route traffic from your computer to a remote computer on the internet thru a MeshCentral2 server. Intel AMT local actions - If you happen to have Intel AMT on your computer, MeshCmd can take a look at the version and activation status, activate and de-activate Intel AMT and help with getting access to Intel AMT and more. Intel AMT remote actions - Whether you have Intel AMT on your local computer or a remote computer on your network, MeshCmd can help unlock the features Intel AMT provides. From getting the state of Intel AMT remotely to running configuration scripts and loading MeshCommander into Intel AMT web storage. To get started, you need to download MeshCmd for your computer. MeshCmd is a single file executable that you can get on MeshCommander.com at: http://www.meshcommander.com/meshcommander/meshcmd If you have access to a MeshCentral2 server, the download link to MeshCmd is at the bottom left of the main device page. Once you click on the \u201cMeshCmd\u201d link, a dialog box will allow you to select the operating system you want to get a link to MeshCmd. MeshCentral will also provide an action file called meshaction.txt that contains information on how MeshCmd can connect back to that MeshCentral server. This is optional, and only used for some operations. Once downloaded, just run it from the command prompt or terminal window. C:\\Temp>meshcmd MeshCentral Command (MeshCmd) No action specified, use MeshCmd like this: meshcmd [action] [arguments...] Valid MeshCentral actions: Route - Map a local TCP port to a remote computer. Valid local actions: SMBios - Display System Management BIOS tables for this computer. RawSMBios - Display RAW System Management BIOS tables for this computer. MicroLMS - Run MicroLMS, allowing local access to Intel AMT. AmtInfo - Show Intel AMT version and activation state. AmtVersions - Show all Intel ME version information. AmtHashes - Show all Intel AMT trusted activation hashes. AmtCCM - Activate Intel AMT into Client Control Mode. AmtACM - Activate Intel AMT into Admin Control Mode. AmtDeactivate - Deactivate Intel AMT if activated in Client Control mode. AmtAcmDeactivate - Deactivate Intel AMT if activated in Admin Control mode. Valid local or remote actions: MeshCommander - Launch a local MeshCommander web server. AmtUUID - Show Intel AMT unique identifier. AmtAuditLog - Show the Intel AMT audit log. AmtLoadWebApp - Load MeshCommander in Intel AMT 11.6+ firmware. AmtClearWebApp - Clear everything from Intel AMT web storage. AmtStorageState - Show contents of the Intel AMT web storage. AmtSaveState - Save all Intel AMT WSMAN object to file. AmtPresence - Heartbeat a local Intel AMT watchdog agent. AmtScript - Run .mescript on Intel AMT. AmtIDER - Mount local disk image to remote computer. Help on a specific action using: meshcmd help [action] By default you will get the help screen with all of the different actions you can take with the tool. You can also get help by typing \u201chelp\u201d followed by the action name. In this document we will cover the main actions that MeshCmd can perform. If you don\u2019t use Intel AMT at all, then only the MeshCentral actions are interesting for you. If you use Intel AMT, the rest of the actions will be of interest to you.","title":"Introduction"},{"location":"meshcmd/#meshcentral-tcp-port-mapping","text":"MeshCmd can map a TCP port from your local computer to any remote port on any computer with one of your MeshAgents installed. This port mapping will work over a local network or the Internet and should work even thru proxies and firewalls. In order to start using MeshCmd in this way, you first need to have access to a MeshCentral server and at least one computer you already manage. TCP port mapping works by selecting a port on your local computer that will be routed to a remote device and port. Here, local port 123 is routed thru the server to port 123 on a remote device. Of course, this picture is a bit simplify. Firewalls, NAT routers and HTTP proxies may be in the way and the MeshAgent on the remote computer will act at the TCP traffic relay in most cases. One typical use of this is to route local port 1234 to port Microsoft RDP port 3389 on a remote device. Once routed, you can start a RDP session on \u201clocalhost:1234\u201d and get a RDP session to the remote device. The RDP protocol is feature rich and efficient, so you get a great user experience regardless of where in the world the remote computer is at. To get started, click on a device in MeshCentral and click on the \u201cRouter\u201d link on the bottom left of the device page. You can download MeshCmd is you have not done so already, but more importantly, download the action.txt file. The file is in text format and contain something like this: { \"action\" : \"route\" , \"localPort\" : 1234 , \uf0df Cha n ge t his \"remoteName\" : \"AmtMachine7\" , \"remoteNodeId\" : \"node//@yw$s5jLUivpzZ49laprt4T0sBaOKImbDAiniothQwccZPukCB696$BvPWAW0Bg2\" , \"remotePort\" : 3389 , \uf0df Cha n ge t his \"username\" : \"admin\" , \"password\" : \"\" , \uf0df No te t ha t t he password is emp t y \"serverId\" : \"D99362D5ED8BAEA8BF9E743B34B242256370C460FD66CB62373C6CFCB204D6D70 7403E396CF0EF6DC2B3A42F735135FD\" , \"serverHttpsHash\" : \"D9DE9E27A229B5355708A3672FB23237CC994A680B3570D242A91E36B4AE5BC 96539E59746E2B71EEF3DBDABBF2AE138\" , \"debugLevel\" : 0 , \"serverUrl\" : \"wss://devbox.mesh.meshcentral.com:443/meshrelay.ashx\" } The action file contains almost all the parameters needed to perform the route. It indicates the local and remote ports, the remote computer unique identifier, server location and authentication information and more. You can just put the action file in the same folder as MeshCmd and run MeshCmd, it will automatically pick up the arguments from the meshaction.txt file. You may want to change the local and remote port in the action file to suite your needs. Be default, the Microsoft RDP port is the target. If the password is not specified in the meshaction.txt file, you can also specify it as a meshcmd argument. C:\\MeshCmd>meshcmd --pass xxxxxxxx Redirecting local port 1234 to AmtMachine7:3389. Press ctrl-c to exit. Now, the traffic router is ready. You can now RDP to localhost:1234 and login to the remote computer.","title":"MeshCentral TCP port mapping"},{"location":"meshcmd/#meshcommander","text":"MeshCommander is a web based Intel AMT management console. MeshCmd has no less then three different versions of MeshCommander built-in, so if you are using Intel AMT, it\u2019s worth a moment to get some knowledge about MeshCommander which is available as a standalone tool along with a full user\u2019s guide at: http://www.meshcommander.com/ and also included as part of MeshCentral. The three versions included in MeshCmd are: MeshCommander as a local web server. MeshCommander for LMS MeshCommander for firmware. In this section, we review the three versions, how they are used and what can be done with them.","title":"MeshCommander"},{"location":"meshcmd/#meshcommander-local-web-server","text":"You can start MeshCommander on a local web server by typing \u201cmeshcmd meshcommander\u201d. By default, local port 3000 is used, but you can optionally specify the port using \u201c--localport [port]\u201d. Running it with look like this: C:\\MeshCmd>meshcmd meshcommander MeshCommander running on HTTP port 3000. Ctrl-C to exit. Once running, use a web browser and go to \u201chttp://localhost:3000\u201d to see the MeshCommander web page. The page will start out without any computers in it and you will have to add some. In this mode, the local computers that are added will be stored in the browser\u2019s storage cache. So, clearing the browser\u2019s cache will also clear the list of computers. You can however load and save the list of computers using the \u201cOpen\u2026\u201d and \u201cSave\u2026\u201d buttons. This version of MeshCommander will have some limitations when compared to the full version installed using the Windows .MSI installer. Notably: No certificate management or validation. Mutual-Authenticated TLS is not supported. Kerberos authentication is not supported. IDE-R is not supported. This said, features like KVM, Terminal and most Intel AMT configuration options are available which makes this a fairly powerful Intel AMT management console. You can run MeshCommander as a background server on both Windows and Linux. To do this, use the install, uninstall, start and stop commands like this: C:\\MeshCmd>meshcmd meshcommander install Installing to \"C:\\Program Files (x86)\\Open Source\\MeshCmd\\MeshCommander.exe\" MeshCommander installed. C:\\MeshCmd>meshcmd meshcommander start MeshCommander starting. On Linux computers, both systemd and initd are supported. When installing, the MeshCmd executable will be copied to a different installation folder.","title":"MeshCommander local web server"},{"location":"meshcmd/#lms-meshcommander","text":"The Layered Management Service (LMS) is a background process that runs in the operating system and provides local OS access to Intel AMT. More specifically, it redirects local TCP ports 16992 and 16993 to Intel AMT thru the MEI driver. One way to check if the LMS service is installed on your computer is to try http://localhost:16992 or https://localhost:16993 in a browser. A page should generally show up. On Windows, LMS is a Windows service that must be downloaded and installed as part of the OEM drivers for a computer. On Linux, it\u2019s generally never installed and users normally have to download the source code and compile it themselves. MeshCmd has its own LMS implementation, so is LMS is not installed it will automatically use its own internal one. In addition, you can run MicroLMS alone by typing the following list while running as root or local administrator: C:\\MeshCmd>meshcmd microlms MicroLMS started, MeshCommander on HTTP/16994. This will start MicroLMS and as indicated, start MeshCommander on local port 16994 at the same time. In total, traffic redirection looks like this: In addition to providing normal services, MicroLMS that is part of MeshCmd will also start a web server on port 16994 and allow a browser to access LMS MeshCommander, a special version of MeshCommander specially made to run in this situation. MeshCommander for LMS will show up even if the computer has Intel AMT un-configured and offer the user the choice to activate Intel AMT and perform configuration actions. In the following screen, we see a computer activated in Client Control Mode. Because it\u2019s in this mode, you can use the web interface to de-activate Intel AMT or login to perform additional configuration. MicroLMS along with MeshCommander for LMS is very useful, especially on Linux as it offers a single tool to setup and configuration Intel AMT. If you wish you run MicroLMS without MeshCommander being available on port 16994, run MeshCmd with \u201c--noconsole\": C:\\MeshCmd>meshcmd microlms --noconsole MicroLMS started. You can run MicroLMS as a background server on both Windows and Linux. To do this, use the MicroLMS install, uninstall, start and stop commands like this: C:\\MeshCmd>meshcmd microlms install Installing to \"C:\\Program Files (x86)\\Open Source\\MeshCmd\\MicroLMS.exe\" MicroLMS installed. C:\\MeshCmd>meshcmd microlms start MicroLMS starting. On Linux computers, both systemd and initd are supported. When installing, the MeshCmd executable will be copied to a different installation folder.","title":"LMS &amp; MeshCommander"},{"location":"meshcmd/#meshcommander-for-firmware","text":"MeshCmd also includes a surprising version of MeshCommander, the one you can load into the firmware of Intel AMT. Starting with Intel AMT 11.6, you can push into the small ~190k storage space of Intel AMT a replacement to the index.htm page served by the firmware on port 16992 & 16993. In the following picture, the left side is the original Intel AMT web page, the right is the replaced MeshCommander built to go in firmware. The firmware version of MeshCommander has support for remote desktop, terminal and all sorts of Intel AMT usages and configuration. Probably the most surprising is that this entire page is between 40k and 100k depending on the version you select. It\u2019s notable that with MeshCommander loaded into Intel AMT firmware, one does not need any other tool except for a browser to perform most Intel AMT maintenance operations. C:\\MeshCmd>meshcmd amtloadwebapp --host 192.168.2.144 --pass xxxxxxxx Uploading MeshCommander... Verifying MeshCommander... Done. To get the current state of Intel AMT web storage, type this: C:\\MeshCmd>meshcmd amtstoragestate --host 192.168.2.144 --pass xxxxxxxx Storage State: { \"information\": { \"version\": 1, \"realms\": 7765759, \"user\": \"admin\" }, \"content\": { \"index.htm\": { \"size\": 57246 \uf0df Replacement index.htm with size. } } } Here, a 57k index.htm replacement is present in the Intel AMT flash. You can clear the web storage, revering the web page back to the original like this: C:\\MeshCmd>meshcmd amtclearwebapp --host 192.168.2.144 --pass xxxxxxxx Done. When MeshCommander is loaded into Intel AMT, you can access it from a different computer using http://computername:16992 or https://computername:16993 You will need to authenticate first before getting access to the web page.","title":"MeshCommander for firmware"},{"location":"meshcmd/#intel-amt-state-activation","text":"MeshCmd can easily be used to read the local state of the computer and Intel AMT. There are many commands available to do this. The \u201cSMBios\u201d action works on most computers and is used to get basic information about your current system. The output is JSON format. C : \\MeshCmd>meshcmd smbios { processorI nf o : { 0 : { Processor : \"CPU\" MaxSpeed : \"3800 Mhz\" Cores : 4 Threads : 8 Popula te d : 1 S tatus : \"Enabled\" Socke t : \"CPU 1\" Ma nufa c turer : \"Intel(R) Corporation\" Versio n : \"Intel(R) Core(TM) i7-3770 CPU @ 3.40GHz\" } } memoryI nf o : { loca t io n : \"System Board\" maxCapaci t yKb : 33554432 } sys te mI nf o : { uuid : \"C57B83D9A94E11E18BA1505054503030\" wakeReaso n : \"Power Switch\" } sys te mSlo ts : { uuid : \"C57B83D9A94E11E18BA1505054503030\" wakeReaso n : \"Power Switch\" } am t I nf o : { AMT : true e na bled : true s t orageRedirec t io n : true serialOverLa n : true kvm : true TXT : false VMX : true MEBX : \"66.0.0.8\" Ma na geme nt E n gi ne : \"8.1.0.57353\" } } If you have Intel AMT on your system, you can use the \u201camtinfo\u201d, \u201camtversions\u201d and \u201camthashes\u201d to get lots of information about Intel AMT current state. These commands use the Intel AMT MEI driver to get this information and require MeshCmd be run as root or administrator: C:\\MeshCmd>meshcmd amtinfo Intel AMT v8.1.71, activated in client control mode. Wired Enabled, DHCP, 00:1E:8C:F5:4F:ED, 192.168.2.10. C:\\MeshCmd>meshcmd amtversions MEI Version = MKQ7710H.86A.0072.2017.0519.1347 Flash = 8.1.71 Netstack = 8.1.71 AMTApps = 8.1.71 AMT = 8.1.71 Sku = 24584 VendorID = 8086 Build Number = 3608 Recovery Version = 8.1.71 Recovery Build Num = 3608 Legacy Mode = False C:\\MeshCmd>meshcmd amthashes VeriSign Class 3 Primary CA-G1, (Default, Active) SHA256: E7685634EFACF69ACE939A6B255B7B4FABEF42935B50A265ACB5CB6027E44E70 VeriSign Class 3 Primary CA-G3, (Default, Active) SHA256: EB04CF5EB1F39AFA762F2BB120F296CBA520C1B97DB1589565B81CB9A17B7244 \u2026 In addition to getting Intel AMT state, MeshCmd can activate Intel AMT in client control mode (CCM) and de-activate Intel AMT if it\u2019s in this mode. Doing this is very simple, starting with Intel AMT not being activated, you use the \u201camtccm\u201d and \u201camtdeactivate\u201d actions. C:\\MeshCmd>meshcmd amtinfo Intel AMT v8.1.71, pre-provisioning state. C:\\MeshCmd>meshcmd amtccm --pass xxxxxxxx Success C:\\MeshCmd>meshcmd amtinfo Intel AMT v8.1.71, activated in client control mode. C:\\MeshCmd>meshcmd amtdeactivate Success Note that when using the \u201camtccm\u201d action, you need to provide a password that will be used for authentication into Intel AMT. This password must be strong with at least 8 characters including a lower case, an uppercase, a numeric value and a non-alpha-numeric value.","title":"Intel AMT state &amp; activation"},{"location":"meshcmd/#intel-amt-audit-log","text":"One very useful feature of MeshCmd is its ability to fetch the Intel AMT audit log. This can be valuable when doing forensics on a computer or just trying figure out what is being done thru Intel AMT. MeshCmd can pull the audit log on a local computer without any credentials, as long as it\u2019s running as root or administrator, or pull the audit log remotely if usual credentials are provided. The Intel AMT audit log will show when a computer\u2019s Intel AMT was activated, when remote desktop sessions where initiated and more. To get the local audit log, just use the \u201cAmtAuditLog\u201d action. C:\\MeshCmd>meshcmd amtauditlog 2004-01-01 19:17:58.000-08:00 - Local: Provisioning Started 2018-01-26 14:03:16.000-08:00 - Local: Unprovisioning Started 2018-01-26 14:03:31.000-08:00 - Local: Provisioning Started 2018-02-01 12:13:14.000-08:00 - admin: KVM Enabled 2018-02-01 12:16:01.000-08:00 - admin: KVM Session Started 2018-02-01 12:16:07.000-08:00 - admin: KVM Session Ended 2018-02-02 10:56:06.000-08:00 - admin: KVM Session Started 2018-02-02 10:56:08.000-08:00 - admin: KVM Session Ended To get a remote audit log: C:\\MeshCmd>meshcmd amtauditlog --host 192.168.2.144 --user admin --pass xxxxxxxx 2003-12-31 23:06:58.000-08:00 - $$OsAdmin: Intel(r) ME Time Set 2017-08-15 06:53:31.000-07:00 - $$OsAdmin: Intel(r) ME Time Set 2017-10-13 17:55:11.000-07:00 - Local: Provisioning Started 2017-10-13 17:55:54.000-07:00 - Local: Opt-In Policy Change 2017-10-15 06:44:38.000-07:00 - admin: KVM Enabled You can also save the audit log to file using the \u201c--output\" option.","title":"Intel AMT Audit Log"},{"location":"meshcmd/#running-intel-amt-script","text":"MeshCmd has a full WSMAN stack built-in and can be used to run \u201c.mescript\u201d file on a target Intel AMT computer. Script file are useful when you want to run a set of actions on one or more Intel AMT computers at once. You can build a .mescript file using the script editor within MeshCommander. This script editor allows the user to drag & drop script blocks, set parameters on each block and test the script against a connected Intel AMT computer. In addition to building your own scripts, you can download a CIRA setup script from a MeshCentral server. When running this script, Intel AMT will be setup to call back to the server using an encrypted connection. This enables remote management of Intel AMT over the Internet. The CIRA setup script is available in the \u201cAdd CIRA\u201d link for meshes that are Intel AMT only (no agent). Once you got the script, run it with MeshCmd like this. You specify the host if it\u2019s not localhost, the password and the script file. C:\\MeshCmd>meshcmd amtscript --host 192.168.2.106 --pass xxxxxxxx --script cira_setup.mescript Script Started Policies removed successfully Adding root certificate... Management Presence Server (MPS) successfully added Found matching (primary) mps: Intel(r) AMT:Management Presence Server 0 Setting policy... Policy added successfully Remote Access user interfaces set to: BIOS & OS Enabed Parsing block parameters Setting Environment Detection Environment Detection set successfully Script Completed In this example, the CIRA setup script was run on a remote computer. After the script is run, the computer got configured and connected back to the server. MeshCentral show the new connection state for this computer.","title":"Running Intel AMT script"},{"location":"meshcmd/#ide-redirection","text":"","title":"IDE Redirection"},{"location":"meshcmd/#video-walkthru_1","text":"MeshCmd has all the code needed to perform Intel AMT IDE Redirection from the command line. This allows disk images on the administrator\u2019s computer to be remotely mounted to an Intel AMT computer. You need to start with a floppy disk .img file and/or an .iso CDROM file. Then use the \u201cAmtIDER\u201d command of MeshCMD to start an IDER session. The help command for AmtIDER looks like this: C:\\Temp>meshcmd help amtider AmtIDER will mount a local disk images to a remote Intel AMT computer. Example usage: meshcmd amtider --host 1.2.3.4 --user admin --pass mypassword --tls --floppy disk.img --cdrom disk.iso Possible arguments: --host [hostname] The IP address or DNS name of Intel AMT. --user [username] The Intel AMT login username, admin is default. --pass [password] The Intel AMT login password. --tls Specifies that TLS must be used. --floppy [file] Specifies .img file to be mounted as a flppy disk. --cdrom [file] Specifies .img file to be mounted as a CDROM disk. --timeout [seconds] Optional, disconnect after number of seconds without disk read. The command is fairly simple. It takes as input a remote host, username/password for Intel AMT login, the disk images and TLS option. One can also specify the timeout option so that MeshCMD will automatically disconnect when no disk read operations are performed for a set number of seconds.","title":"Video Walkthru"},{"location":"meshcmd/#conclusion","text":"MeshCmd is a cross-platform command line tools that perform an ever-growing list of actions that are important for remote computer management. MeshCmd works alone or with MeshCentral and MeshCommander to offer a suite of free, opens source and powerful tools that work well together.","title":"Conclusion"},{"location":"meshcmd/#license","text":"MeshCmd and this document are both opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0","title":"License"},{"location":"meshctrl/","text":"MeshCtrl \u00b6 MeshCmd Guide as .pdf as .odt Video Walkthru \u00b6 Abstract \u00b6 This user guide contains all essential information for the user to make full use of MeshCtrl, a command line tool used to perform tasks on the MeshCentral server. This tool is built in NodeJS and can be run on the same computer as the server, or on a different computer. It\u2019s typically used by administrators to perform various management operations on the MeshCentral server. Introduction \u00b6 MeshCtrl, also called \u201cMesh Control\u201d, is a command line tool built in NodeJS that comes with MeshCentral and allows command line management operation of the MeshCentral server. It can be run both on the same computer as the MeshCentral server, or on a different computer. This tool allows an administrator to list user accounts, create and remove user accounts, list device groups and much more. All of the operations performed by this tool can also be performed using the MeshCentral website, however it\u2019s sometimes useful to automate and script some management operations from the command line and this tool can do this. MeshCtrl will login to the MeshCentral server using a web socket connection, just like the web application does and so, it needs to login to the server using user or administrator credentials. In the next section, we will cover how to login using MeshCtrl, we then follow with the operations that MeshCtrl can perform. Running MeshCtrl \u00b6 MeshCtrl.js is a file that is installed with MeshCentral and is located in the \u201c./node_modules/meshcentral\u201d folder. You can normally run MeshCtrl like this: node ./node\\_modules/meshcentral/meshctrl In this case, when the above command is run without parameters, you should see something like this: MeshCtrl performs command line actions on a MeshCentral server. Information at: https://meshcommander.com/meshcentral No action specified, use MeshCtrl like this: meshctrl [action] [arguments] Supported actions: Help [action] - Get help on an action. ServerInfo - Show server information. UserInfo - Show user information. ListUsers - List user accounts. ListDevices - List devices. ListDeviceGroups - List device groups. ListUsersOfDeviceGroup - List the users in a device group. AddUser - Create a new user account. RemoveUser - Delete a user account. AddDeviceGroup - Create a new device group. RemoveDeviceGroup - Delete a device group. AddUserToDeviceGroup - Add a user to a device group. RemoveUserFromDeviceGroup - Remove a user from a device group. SendInviteEmail - Send an agent install invitation email. Broadcast - Display a message to all online users. Supported login arguments: --url [wss://server] - Server url, wss://localhost:443 is default. --loginuser [username] - Login username, admin is default. --loginpass [password] - Login password. --token [number] - 2nd factor authentication token. --loginkey [hex] - Server login key in hex. --loginkeyfile [file] - File containing server login key in hex. --domain [domainid] - Domain id, default is empty. This indicated you have a good version of MeshCentral with support for MeshCtrl. MeshCentral and MeshCtrl will be updated together, so as changes are made to the server, MeshCtrl will also be updated to match. The next step is to login to the server with MeshCtrl before we can start performing commands. For this document, we will assume we are connection to the local MeshCentral server on port 443 using TLS. For connecting to a different server, use the --url argument to set a different server. Login \u00b6 There are two ways to login to MeshCentral using MeshCtrl. You can use the normal username/password, or use a login key. In this section we look at both. Login using username & password \u00b6 This is the easiest way to login and start issuing commands is to login using a username and password. You do this by using the \"loginuser\" and \"loginpass\" argument like this: node ./node_modules/meshcentral/meshctrl serverinfo --loginuser \"admin\" --loginpass \"mypassword\" In this example we are trying to run the \u201cserverinfo\u201d command using the \u201cadmin\u201d user and \u201cmypassword\u201d as the password. Because \u201cadmin\u201d if the default username for MeshCtrl, you can omit it and just type: Authentication token required, use --token [number]. In this case, you need to use the Google Authenticator application or a similar application to enter your time based second factor like this: node ./node_modules/meshcentral/meshctrl serverinfo --loginpass \"mypassword\" \u2013token 123456 Once the command is run successfully, you should see a response like this: name: devbox.meshcentral.com mpsname: devbox.meshcentral.com mpsport: 4433 port: 443 emailcheck: true domainauth: false tlshash: E7A41E1A56D8D716F7D7729B876E48693F2D19C4761F22B1\u2026 https: true redirport: 80 This is a typical response for the \u201cserverinfo\u201d command and a good way to test that everything is working as expected. Login using the server login key \u00b6 This technique needs some setup, but allows MeshCtrl to login as any account without knowing the password of the account, making it very powerful. Care must be taken when doing this and it\u2019s recommended to only be done on the local server itself unless you know when you are doing. In this technique, we will get a special encryption key from the server and use this to generate a login token to the server. First, we must activate the login token feature of the server by setting \u201cAllowLoginToken\u201d to \u201ctrue\u201d in the \u201csettings\u201d section of config.json: { \"settings\" : { \"Port\" : 443 , \"AllowLoginToken\" : true } } Then run the MeshCentral server with the --logintokenkey parameter, you should see something like this: node ./node_modules/meshcentral --logintokenkey f3bd69a08a2dde4a3423bec8f20d8626b1e6365381f2d9919e7dfe256ace9cbbdea66bed2bdcd00b71eea9d7c727cb6eb37f3148c0c2d240d5ed44c8f3f6795a479c949159dad366571fea4db7f31c24 The hex value presented here is a sensitive secret that allows anyone to create login tokens that can be used for user impersonation. This key is used when MeshCentral does server peering and load balancing for example. You should save this key in a file, for example \u201ckey.txt\u201d, you can do it like this: node ./node_modules/meshcentral \u2013logintokenkey > key.txt Now that you have the server key, you can use MeshCtrl like this: node ./node_modules/meshcentral/meshctrl serverinfo \u2013-loginkeyfile key.txt --loginuser admin Instead of using a password, we use the key file instead. MeshCtrl will generate a time limited cookie and use that to login as \u201cadmin\u201d. Since \u201cadmin\u201d is the default username for MeshCtrl, we can omit this parameter: node ./node_modules/meshcentral/meshctrl serverinfo \u2013-loginkeyfile key.txt Like the username and password example above, the result will be the server information we requested. Something like this: name: devbox.meshcentral.com mpsname: devbox.meshcentral.com mpsport: 4433 port: 443 emailcheck: true domainauth: false tlshash: E7A41E1A56D8D716F7D7729B876E48693F2D19C4761F22B1\u2026 https: true redirport: 80 Login into a different domain \u00b6 So far, we have seen how to login to a MeshCentral server using a username/password or username/key technique for the default domain. MeshCentral supports many domains at once with each of the domain having its own set of users, groups and administrators. To do this, using the username and password, we have to tell MeshCtrl to login using the URL that would be used to access that domain, for example: node ./node_modules/meshcentral/meshctrl serverinfo --url wss://server/domainname --loginuser \"admin\" --loginpass \"mypassword\" or for servers have a DNS name for a domain: node ./node_modules/meshcentral/meshctrl serverinfo --url wss://domainname.server --loginuser \"admin\" --loginpass \"mypassword\" Note the \"--url\" argument is different and so, the server will see MeshCtrl access the server using a different domain. Doing a domain login using the login is key file is a bit different. We need to specify both the url to access that domain and specify the domain name explicitly using the --domain argument. For example: node ./node_modules/meshcentral/meshctrl serverinfo \u2013-loginkeyfile key.txt --url wss://server/domainname --domain mycustomer So, we add both the url to access the correct domain and the domain name explicitly. The domain name must be exactly the one that is used in the domain section of the config.json for of MeshCentral. For example, if the MeshCentral config.json file looks like this: { \"settings\" : { \"Cert\" : \"myserver.com\" , \"Port\" : 443 }, \"domains\" : { \"\" : { \"title\" : \"Default domain\" , }, \"customer1\" : { \"dns\" : \"c1.myserver.com\" , \"title\" : \"Customer1 domain\" , } } } The domain login for MeshCtrl with a key file would look like this: node ./node_modules/meshcentral/meshctrl serverinfo \u2013-loginkeyfile key.txt --url wss://c1.myserver.com --domain customer1 In the next section, we start making use of MeshCtrl to do useful things on the server. From now on, we will omit the login arguments, but note that they are required for all commands. Making use of MeshCtrl \u00b6 We can start doing useful operations with MeshCtrl. The current list of operations are: edituser listusers listusersessions listdevicegroups listdevices listusersofdevicegroup listevents logintokens serverinfo userinfo adduser removeuser adddevicegroup removedevicegroup editdevicegroup broadcast showevents addusertodevicegroup removeuserfromdevicegroup addusertodevice removeuserfromdevice sendinviteemail generateinvitelink config movetodevicegroup deviceinfo editdevice addusergroup listusergroups removeusergroup runcommand shell upload download deviceopenurl devicemessage devicetoast addtousergroup removefromusergroup removeallusersfromusergroup devicesharing devicepower indexagenterrorlog agentdownload You can get this list by just running MeshCtrl without any argument and can get more information on each action by typing \u201cmeshctrl help [action]\u201d Note Note that when using Intel AMT only (no agent) you can do wake (on) and power off and reset from the group action. MeshCentral should automatically using Intel AMT to perform these actions when you select \"Wake-up devices\", \"Power off devices\" or \"Reset devices\". Gathering information \u00b6 The following commands are really easy to use: serverinfo, userinfo, listusers, listdevices, listdevicegroups. They just request information from the server. Note that for these commands, you can optionally use \u201c--json\" to receive the response in JSON format. For example, getting the list of users will look like this: node meshctrl.js listusers id, name, email --------------- \"admin\", \"admin\", \"username@domain.com\" \"joe\", \"joe\", \"joe@domain.com\" \"mytestuser\", \"MyTestUser\", \"a@a.com\" \"test.user\", \"test.user\", \"test.user@user.com\" In the --json argument is used, it looks like this: node meshctrl.js listusers --json { \"_id\": \"user//admin\", \"name\": \"admin\", \"creation\": 1417814230, \"siteadmin\": 4294967295, \u2026 The JSON version is much long and contain much more information. This format can be useful if you take the output of MeshCtrl and dump it into a file for later parsing. One really useful command is \u201clistdevices\u201d that just displays all the devices in the account grouped by device groups. For example: node meshctrl listdevices Device group: \"Lab Computers\" id, name, icon, conn, pwr, ip ----------------------------- p3HOhDapgT@VyO$upGJYxEa$v4YCY76Y2G@hOGmJnbPXjkSHP@AgJ1M6FkqSEUqg, \"raspberrypi\", 5, 1, 1 yjbMXlQBf09TSIqKlkwrRucm767TcXfNbSinQWXgpdBBY5MEU1gg0kzshwiwFCOp, \"tinkerboard\", 5, 1, 1 DRvCLkYIgk744tqqMr9Xvy5TK8aXkLoOXUQETnFdFepVQojyFV5gaBi5Gh4f6B6d, \"LattePanda\", 5, 1, 1 ggifepc5wqK7sCVnOIjOZy9i9kaJizalIarz7Qwe5bJ4icpLD69zWYpjAaU@sfY$, \"MeshLabTop\", 1, 5, 1 ECAI7NO893JoN3ntK7@mbniyDq0qriG82wqGKQF4s8SpXs3NdnvuHR76Bzq14Pik, \"MeshLabRight\", 1, 1, 1 fCLFeHaxQ$T6mgICdVkCdkifiU8LNJdU73YknmxfAb@0jBF2BrhTsEIBwgpoCNx$, \"DevLinux\", 1, 1, 1 hfbJ7zAgwZK@LQfsZkr1cqTSp6mjjZ3MjGC$v4X8E7HM1cZEnlGBgcorELu1hZWe, \"AmtMachine11\", 1, 1, 1 YRGm4AQVRR38Ypisuo40KhvBGhDl2pE5YCp4j4eIbLaX3kmH3tmumOUbxb44A@Rh, \"CoffeeTable\", 1, 1, 1 PpMJiPxtjRjfoEal$9RHdm5s31BaqDSbGc3329s49rzcXcVuTDvm4VO0YllO5XR7, \"DevBox\", 1, 0, 0 tyR7l2j5@wOjDeRbOQNfjU7xB$ss6VZQPDkFsALPzJ4zbTI4IamV$OdwHeqiXV0K, \"MeshLabLeft\", 1, 5, 1 i@BNTAHB5NMtDyrHMiCaz3GzYlJUUQn7qZZfh@N6271DWAM3EH6ujRNPc2snGXYX, \"raspberrypi\", 5, 1, 1 2E$CjXw2Aldh3DGAzSNo5qTSgEhd4OTWcO9KGBi9ja4EOxEUHq8J1135Y2IvxOlX, \"AmtMachine7\", 1, 5, 1 0Ab3O@4fgHjwVOpC0qaARfURTtKCa@QjxWPDpT5WQ0Wz5s4OvRWAgeoGT9j8k5JF, \"RaspberryPi\", 5, 1, 1 Device group: \"IntelAMT only\" id, name, icon, conn, pwr, ip ----------------------------- LN8qsH634RGjDwATIOd3ICzfKrB@t@ERow8AEyDndyAs3yqwfrfhEaMPABMg53cg, \"AmtMachine7\", 0, 0, 0 Ea3GcF$EoMnDEc9Tbz$Vu9wnmTziqqcOZ0URSdYeuVn4LU9LLMT@91P5s1WLSgVA, \"DevBox\", 0, 0, 0 It\u2019s also possible to list only the display the list of devices for a single group. Just add --id followed by the group identifier. You can find the group identifier using the \u201cDeisplayDeviceGroups\u201d command. For example: node meshctrl listdevices --id 7b4b43cdad850135f36ab31124b52e47c167fba055\u2026 id, name, icon, conn, pwr, ip ----------------------------- p3HOhDapgT@VyO$upGJYxEa$v4YCY76Y2G@hOGmJnbPXjkSHP@AgJ1M6FkqSEUqg, \"raspberrypi\", 5, 1, 1 yjbMXlQBf09TSIqKlkwrRucm767TcXfNbSinQWXgpdBBY5MEU1gg0kzshwiwFCOp, \"tinkerboard\", 5, 1, 1 DRvCLkYIgk744tqqMr9Xvy5TK8aXkLoOXUQETnFdFepVQojyFV5gaBi5Gh4f6B6d, \"LattePanda\", 5, 1, 1 ggifepc5wqK7sCVnOIjOZy9i9kaJizalIarz7Qwe5bJ4icpLD69zWYpjAaU@sfY$, \"MeshLabTop\", 1, 5, 1 ECAI7NO893JoN3ntK7@mbniyDq0qriG82wqGKQF4s8SpXs3NdnvuHR76Bzq14Pik, \"MeshLabRight\", 1, 1, 1 fCLFeHaxQ$T6mgICdVkCdkifiU8LNJdU73YknmxfAb@0jBF2BrhTsEIBwgpoCNx$, \"DevLinux\", 1, 1, 1 hfbJ7zAgwZK@LQfsZkr1cqTSp6mjjZ3MjGC$v4X8E7HM1cZEnlGBgcorELu1hZWe, \"AmtMachine11\", 1, 1, 1 YRGm4AQVRR38Ypisuo40KhvBGhDl2pE5YCp4j4eIbLaX3kmH3tmumOUbxb44A@Rh, \"CoffeeTable\", 1, 1, 1 PpMJiPxtjRjfoEal$9RHdm5s31BaqDSbGc3329s49rzcXcVuTDvm4VO0YllO5XR7, \"DevBox\", 1, 0, 0 tyR7l2j5@wOjDeRbOQNfjU7xB$ss6VZQPDkFsALPzJ4zbTI4IamV$OdwHeqiXV0K, \"MeshLabLeft\", 1, 5, 1 i@BNTAHB5NMtDyrHMiCaz3GzYlJUUQn7qZZfh@N6271DWAM3EH6ujRNPc2snGXYX, \"raspberrypi\", 5, 1, 1 2E$CjXw2Aldh3DGAzSNo5qTSgEhd4OTWcO9KGBi9ja4EOxEUHq8J1135Y2IvxOlX, \"AmtMachine7\", 1, 5, 1 0Ab3O@4fgHjwVOpC0qaARfURTtKCa@QjxWPDpT5WQ0Wz5s4OvRWAgeoGT9j8k5JF, \"RaspberryPi\", 5, 1, 1 You can also add \u201c--count\" to just return the number of devices instead of displaying them. An example of this would be: node meshctrl listdevices --id 7b4b43cdad850135f36ab31124b52e47c167fba055\u2026 --count 13 Here we see that in a specific device group, there are 13 devices. Adding and removing accounts \u00b6 MeshCtrl can be used to add and remove user accounts. This is great is you want to automate MeshCentral in some situations. Normally, an administrator can go to the \u201cMy Users\u201d tab and press \u201cNew Account\u2026\u201d button to create a new account. With MeshCtrl the same process can be accomplished using the following command line: node ./node_modules/meshcentral/meshctrl adduser --user SampleUser --pass SamplePassword This will create a basic user account with the specified \u201cSampleUser\u201d username and \u201cSamplePassword\u201d password. In addition to the basic example above, there are plenty of additional arguments that can be used. There is a list: --email [email] - New account email address. --emailverified - New account email is verified. --resetpass - Request password reset on next login. --siteadmin - Create the account as full site administrator. --manageusers - Allow this account to manage server users. --fileaccess - Allow this account to store server files. --serverupdate - Allow this account to update the server. --locked - This account will be locked. --nonewgroups - Account will not be allowed to create device groups --notools - Account not see MeshCMD download links. Instead of specifying a password, one can specify \u201c--randompass\" to have MeshCtrl generate a random password, this is typically use along with \u201c--resetpass\" and \u201c--email\" to cause the user to perform a password reset the first time a login occurs. The permission arguments are used to grant server permissions to the new account. The \u201c-- siteadmin\" argument will grant this account full site administrator rights and all other permission arguments are ignored. The other permission arguments can be combined. To remove a user account, use the following command: node ./node_modules/meshcentral/meshctrl removeuser --userid SampleId Note that when creating a new user, the username is passed in. However, when removing a user account, the userid is used. One can get the list of userid\u2019s by using the \u201cListUsers\u201d command. MeshCtrl will return \u201cok\u201d if the command is successful and the account will be added in real-time to the \u201cMy Users\u201d tab on the website. Creating and removing device groups \u00b6 MeshCtrl can be used to add and remove device groups. When a group is created, it\u2019s added in the account that MeshCtrl is logged into and that account gets full rights over that device group. Typically, a new device group is created using the \u201cAdd Device Group\u201d link in the main website. A group has a name, type and optionally a description text. To add a device group using MeshCtrl, we use the \u201cAddDeviceGroup\u201d command like this: node ./node_modules/meshcentral/meshctrl adddevicegroup --name \"Sample group name\" --desc \"Sample description\" Here we specify the name and description of the new device group. This will create a normal device group that requires agents to be installed on each computer. You can also create an agent-less Intel AMT device group by adding the \"--amtonly\" argument. Once done, MeshCtrl will return \u201cok\" and the group will be created in the logged in account in real-time. You can delete a group by using the \u201cRemoveDeviceGroup\u201d command like this: node ./node_modules/meshcentral/meshctrl removedevicegroup --id 7b4b43cd\u2026dc89fe0e581c To remove a device group, the group identifier needs to be specified. You can get that identifier using the \"ListDeviceGroups\" command. For device groups, the group identifier is a long hex value. Adding and removing users from device groups \u00b6 Once you created user account and device groups, the next important operation is to connect the two and grant users access to some device groups. In the web interface, this is typically done by clicking on a device group and managing the users in that page. To do this, you first have to get the user and group identifiers. You can get these using the \u201clistusers\u201d and \u201clistdevicegroups\u201d commands. Then, you can for example do this: node ./node_modules/meshcentral/meshctrl addusertodevicegroup --id 7b4b43cd\u2026dc89fe0e581c --userid bob --fullrights Typically, the group identifier is a long hex value. The command will add user \u201cbob\u201d to a given group with full rights. You can also add a user to a group with only some rights, the list is as follows: --fullrights - Allow full rights over this device group. --editgroup - Allow the user to edit group information. --manageusers - Allow the user to add/remove users. --managedevices - Allow the user to edit device information. --remotecontrol - Allow device remote control operations. --agentconsole - Allow agent console operations. --serverfiles - Allow access to group server files. --wakedevices - Allow device wake operation. --notes - Allow editing of device notes. --desktopviewonly - Restrict user to view-only remote desktop. --limiteddesktop - Limit remote desktop keys. --noterminal - Hide the terminal tab from this user. --nofiles - Hide the files tab from this user. --noamt - Hide the Intel AMT tab from this user. Note that if \u201cfullrights\u201d are granted, all other access right arguments are ignored. If successful, MeshCtrl will display \u201cok\u201d, otherwise it will show an error message. To remove a user from a group, use the \u201cremoveuserfromdevicegroup\u201d command. For example: node ./node_modules/meshcentral/meshctrl removeuserfromdevicegroup --id 7b4b43cd\u2026dc89fe0e581c --userid bob The syntax of this command is identical to the \u201caddusertodevicegroup\u201d command, but there are no rights arguments. MeshCtrl will also display \u201cok\u201d if the command got processed correctly. Message Broadcast \u00b6 One fun command the MeshCtrl offers is the \u201cbroadcast\u201d command. It sends a short notification message that all connected users will see in real-time. For example, you can do this: node ./node\\_modules/meshcentral/meshctrl broadcast --msg \"This is a test\" All connected users will see this: The broadcast command is great for notifying users of upcoming server downtime or other events. Conclusion \u00b6 MeshCtrl is an essential tools in every MeshCentral administrator\u2019s tool box. It allows administrators to automate various MeshCentral management tasks which can be useful for large scale management of many devices and users. License \u00b6 MeshCtrl and this document are both opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0","title":"MeshCtrl"},{"location":"meshctrl/#meshctrl","text":"MeshCmd Guide as .pdf as .odt","title":"MeshCtrl"},{"location":"meshctrl/#video-walkthru","text":"","title":"Video Walkthru"},{"location":"meshctrl/#abstract","text":"This user guide contains all essential information for the user to make full use of MeshCtrl, a command line tool used to perform tasks on the MeshCentral server. This tool is built in NodeJS and can be run on the same computer as the server, or on a different computer. It\u2019s typically used by administrators to perform various management operations on the MeshCentral server.","title":"Abstract"},{"location":"meshctrl/#introduction","text":"MeshCtrl, also called \u201cMesh Control\u201d, is a command line tool built in NodeJS that comes with MeshCentral and allows command line management operation of the MeshCentral server. It can be run both on the same computer as the MeshCentral server, or on a different computer. This tool allows an administrator to list user accounts, create and remove user accounts, list device groups and much more. All of the operations performed by this tool can also be performed using the MeshCentral website, however it\u2019s sometimes useful to automate and script some management operations from the command line and this tool can do this. MeshCtrl will login to the MeshCentral server using a web socket connection, just like the web application does and so, it needs to login to the server using user or administrator credentials. In the next section, we will cover how to login using MeshCtrl, we then follow with the operations that MeshCtrl can perform.","title":"Introduction"},{"location":"meshctrl/#running-meshctrl","text":"MeshCtrl.js is a file that is installed with MeshCentral and is located in the \u201c./node_modules/meshcentral\u201d folder. You can normally run MeshCtrl like this: node ./node\\_modules/meshcentral/meshctrl In this case, when the above command is run without parameters, you should see something like this: MeshCtrl performs command line actions on a MeshCentral server. Information at: https://meshcommander.com/meshcentral No action specified, use MeshCtrl like this: meshctrl [action] [arguments] Supported actions: Help [action] - Get help on an action. ServerInfo - Show server information. UserInfo - Show user information. ListUsers - List user accounts. ListDevices - List devices. ListDeviceGroups - List device groups. ListUsersOfDeviceGroup - List the users in a device group. AddUser - Create a new user account. RemoveUser - Delete a user account. AddDeviceGroup - Create a new device group. RemoveDeviceGroup - Delete a device group. AddUserToDeviceGroup - Add a user to a device group. RemoveUserFromDeviceGroup - Remove a user from a device group. SendInviteEmail - Send an agent install invitation email. Broadcast - Display a message to all online users. Supported login arguments: --url [wss://server] - Server url, wss://localhost:443 is default. --loginuser [username] - Login username, admin is default. --loginpass [password] - Login password. --token [number] - 2nd factor authentication token. --loginkey [hex] - Server login key in hex. --loginkeyfile [file] - File containing server login key in hex. --domain [domainid] - Domain id, default is empty. This indicated you have a good version of MeshCentral with support for MeshCtrl. MeshCentral and MeshCtrl will be updated together, so as changes are made to the server, MeshCtrl will also be updated to match. The next step is to login to the server with MeshCtrl before we can start performing commands. For this document, we will assume we are connection to the local MeshCentral server on port 443 using TLS. For connecting to a different server, use the --url argument to set a different server.","title":"Running MeshCtrl"},{"location":"meshctrl/#login","text":"There are two ways to login to MeshCentral using MeshCtrl. You can use the normal username/password, or use a login key. In this section we look at both.","title":"Login"},{"location":"meshctrl/#login-using-username-password","text":"This is the easiest way to login and start issuing commands is to login using a username and password. You do this by using the \"loginuser\" and \"loginpass\" argument like this: node ./node_modules/meshcentral/meshctrl serverinfo --loginuser \"admin\" --loginpass \"mypassword\" In this example we are trying to run the \u201cserverinfo\u201d command using the \u201cadmin\u201d user and \u201cmypassword\u201d as the password. Because \u201cadmin\u201d if the default username for MeshCtrl, you can omit it and just type: Authentication token required, use --token [number]. In this case, you need to use the Google Authenticator application or a similar application to enter your time based second factor like this: node ./node_modules/meshcentral/meshctrl serverinfo --loginpass \"mypassword\" \u2013token 123456 Once the command is run successfully, you should see a response like this: name: devbox.meshcentral.com mpsname: devbox.meshcentral.com mpsport: 4433 port: 443 emailcheck: true domainauth: false tlshash: E7A41E1A56D8D716F7D7729B876E48693F2D19C4761F22B1\u2026 https: true redirport: 80 This is a typical response for the \u201cserverinfo\u201d command and a good way to test that everything is working as expected.","title":"Login using username &amp; password"},{"location":"meshctrl/#login-using-the-server-login-key","text":"This technique needs some setup, but allows MeshCtrl to login as any account without knowing the password of the account, making it very powerful. Care must be taken when doing this and it\u2019s recommended to only be done on the local server itself unless you know when you are doing. In this technique, we will get a special encryption key from the server and use this to generate a login token to the server. First, we must activate the login token feature of the server by setting \u201cAllowLoginToken\u201d to \u201ctrue\u201d in the \u201csettings\u201d section of config.json: { \"settings\" : { \"Port\" : 443 , \"AllowLoginToken\" : true } } Then run the MeshCentral server with the --logintokenkey parameter, you should see something like this: node ./node_modules/meshcentral --logintokenkey f3bd69a08a2dde4a3423bec8f20d8626b1e6365381f2d9919e7dfe256ace9cbbdea66bed2bdcd00b71eea9d7c727cb6eb37f3148c0c2d240d5ed44c8f3f6795a479c949159dad366571fea4db7f31c24 The hex value presented here is a sensitive secret that allows anyone to create login tokens that can be used for user impersonation. This key is used when MeshCentral does server peering and load balancing for example. You should save this key in a file, for example \u201ckey.txt\u201d, you can do it like this: node ./node_modules/meshcentral \u2013logintokenkey > key.txt Now that you have the server key, you can use MeshCtrl like this: node ./node_modules/meshcentral/meshctrl serverinfo \u2013-loginkeyfile key.txt --loginuser admin Instead of using a password, we use the key file instead. MeshCtrl will generate a time limited cookie and use that to login as \u201cadmin\u201d. Since \u201cadmin\u201d is the default username for MeshCtrl, we can omit this parameter: node ./node_modules/meshcentral/meshctrl serverinfo \u2013-loginkeyfile key.txt Like the username and password example above, the result will be the server information we requested. Something like this: name: devbox.meshcentral.com mpsname: devbox.meshcentral.com mpsport: 4433 port: 443 emailcheck: true domainauth: false tlshash: E7A41E1A56D8D716F7D7729B876E48693F2D19C4761F22B1\u2026 https: true redirport: 80","title":"Login using the server login key"},{"location":"meshctrl/#login-into-a-different-domain","text":"So far, we have seen how to login to a MeshCentral server using a username/password or username/key technique for the default domain. MeshCentral supports many domains at once with each of the domain having its own set of users, groups and administrators. To do this, using the username and password, we have to tell MeshCtrl to login using the URL that would be used to access that domain, for example: node ./node_modules/meshcentral/meshctrl serverinfo --url wss://server/domainname --loginuser \"admin\" --loginpass \"mypassword\" or for servers have a DNS name for a domain: node ./node_modules/meshcentral/meshctrl serverinfo --url wss://domainname.server --loginuser \"admin\" --loginpass \"mypassword\" Note the \"--url\" argument is different and so, the server will see MeshCtrl access the server using a different domain. Doing a domain login using the login is key file is a bit different. We need to specify both the url to access that domain and specify the domain name explicitly using the --domain argument. For example: node ./node_modules/meshcentral/meshctrl serverinfo \u2013-loginkeyfile key.txt --url wss://server/domainname --domain mycustomer So, we add both the url to access the correct domain and the domain name explicitly. The domain name must be exactly the one that is used in the domain section of the config.json for of MeshCentral. For example, if the MeshCentral config.json file looks like this: { \"settings\" : { \"Cert\" : \"myserver.com\" , \"Port\" : 443 }, \"domains\" : { \"\" : { \"title\" : \"Default domain\" , }, \"customer1\" : { \"dns\" : \"c1.myserver.com\" , \"title\" : \"Customer1 domain\" , } } } The domain login for MeshCtrl with a key file would look like this: node ./node_modules/meshcentral/meshctrl serverinfo \u2013-loginkeyfile key.txt --url wss://c1.myserver.com --domain customer1 In the next section, we start making use of MeshCtrl to do useful things on the server. From now on, we will omit the login arguments, but note that they are required for all commands.","title":"Login into a different domain"},{"location":"meshctrl/#making-use-of-meshctrl","text":"We can start doing useful operations with MeshCtrl. The current list of operations are: edituser listusers listusersessions listdevicegroups listdevices listusersofdevicegroup listevents logintokens serverinfo userinfo adduser removeuser adddevicegroup removedevicegroup editdevicegroup broadcast showevents addusertodevicegroup removeuserfromdevicegroup addusertodevice removeuserfromdevice sendinviteemail generateinvitelink config movetodevicegroup deviceinfo editdevice addusergroup listusergroups removeusergroup runcommand shell upload download deviceopenurl devicemessage devicetoast addtousergroup removefromusergroup removeallusersfromusergroup devicesharing devicepower indexagenterrorlog agentdownload You can get this list by just running MeshCtrl without any argument and can get more information on each action by typing \u201cmeshctrl help [action]\u201d Note Note that when using Intel AMT only (no agent) you can do wake (on) and power off and reset from the group action. MeshCentral should automatically using Intel AMT to perform these actions when you select \"Wake-up devices\", \"Power off devices\" or \"Reset devices\".","title":"Making use of MeshCtrl"},{"location":"meshctrl/#gathering-information","text":"The following commands are really easy to use: serverinfo, userinfo, listusers, listdevices, listdevicegroups. They just request information from the server. Note that for these commands, you can optionally use \u201c--json\" to receive the response in JSON format. For example, getting the list of users will look like this: node meshctrl.js listusers id, name, email --------------- \"admin\", \"admin\", \"username@domain.com\" \"joe\", \"joe\", \"joe@domain.com\" \"mytestuser\", \"MyTestUser\", \"a@a.com\" \"test.user\", \"test.user\", \"test.user@user.com\" In the --json argument is used, it looks like this: node meshctrl.js listusers --json { \"_id\": \"user//admin\", \"name\": \"admin\", \"creation\": 1417814230, \"siteadmin\": 4294967295, \u2026 The JSON version is much long and contain much more information. This format can be useful if you take the output of MeshCtrl and dump it into a file for later parsing. One really useful command is \u201clistdevices\u201d that just displays all the devices in the account grouped by device groups. For example: node meshctrl listdevices Device group: \"Lab Computers\" id, name, icon, conn, pwr, ip ----------------------------- p3HOhDapgT@VyO$upGJYxEa$v4YCY76Y2G@hOGmJnbPXjkSHP@AgJ1M6FkqSEUqg, \"raspberrypi\", 5, 1, 1 yjbMXlQBf09TSIqKlkwrRucm767TcXfNbSinQWXgpdBBY5MEU1gg0kzshwiwFCOp, \"tinkerboard\", 5, 1, 1 DRvCLkYIgk744tqqMr9Xvy5TK8aXkLoOXUQETnFdFepVQojyFV5gaBi5Gh4f6B6d, \"LattePanda\", 5, 1, 1 ggifepc5wqK7sCVnOIjOZy9i9kaJizalIarz7Qwe5bJ4icpLD69zWYpjAaU@sfY$, \"MeshLabTop\", 1, 5, 1 ECAI7NO893JoN3ntK7@mbniyDq0qriG82wqGKQF4s8SpXs3NdnvuHR76Bzq14Pik, \"MeshLabRight\", 1, 1, 1 fCLFeHaxQ$T6mgICdVkCdkifiU8LNJdU73YknmxfAb@0jBF2BrhTsEIBwgpoCNx$, \"DevLinux\", 1, 1, 1 hfbJ7zAgwZK@LQfsZkr1cqTSp6mjjZ3MjGC$v4X8E7HM1cZEnlGBgcorELu1hZWe, \"AmtMachine11\", 1, 1, 1 YRGm4AQVRR38Ypisuo40KhvBGhDl2pE5YCp4j4eIbLaX3kmH3tmumOUbxb44A@Rh, \"CoffeeTable\", 1, 1, 1 PpMJiPxtjRjfoEal$9RHdm5s31BaqDSbGc3329s49rzcXcVuTDvm4VO0YllO5XR7, \"DevBox\", 1, 0, 0 tyR7l2j5@wOjDeRbOQNfjU7xB$ss6VZQPDkFsALPzJ4zbTI4IamV$OdwHeqiXV0K, \"MeshLabLeft\", 1, 5, 1 i@BNTAHB5NMtDyrHMiCaz3GzYlJUUQn7qZZfh@N6271DWAM3EH6ujRNPc2snGXYX, \"raspberrypi\", 5, 1, 1 2E$CjXw2Aldh3DGAzSNo5qTSgEhd4OTWcO9KGBi9ja4EOxEUHq8J1135Y2IvxOlX, \"AmtMachine7\", 1, 5, 1 0Ab3O@4fgHjwVOpC0qaARfURTtKCa@QjxWPDpT5WQ0Wz5s4OvRWAgeoGT9j8k5JF, \"RaspberryPi\", 5, 1, 1 Device group: \"IntelAMT only\" id, name, icon, conn, pwr, ip ----------------------------- LN8qsH634RGjDwATIOd3ICzfKrB@t@ERow8AEyDndyAs3yqwfrfhEaMPABMg53cg, \"AmtMachine7\", 0, 0, 0 Ea3GcF$EoMnDEc9Tbz$Vu9wnmTziqqcOZ0URSdYeuVn4LU9LLMT@91P5s1WLSgVA, \"DevBox\", 0, 0, 0 It\u2019s also possible to list only the display the list of devices for a single group. Just add --id followed by the group identifier. You can find the group identifier using the \u201cDeisplayDeviceGroups\u201d command. For example: node meshctrl listdevices --id 7b4b43cdad850135f36ab31124b52e47c167fba055\u2026 id, name, icon, conn, pwr, ip ----------------------------- p3HOhDapgT@VyO$upGJYxEa$v4YCY76Y2G@hOGmJnbPXjkSHP@AgJ1M6FkqSEUqg, \"raspberrypi\", 5, 1, 1 yjbMXlQBf09TSIqKlkwrRucm767TcXfNbSinQWXgpdBBY5MEU1gg0kzshwiwFCOp, \"tinkerboard\", 5, 1, 1 DRvCLkYIgk744tqqMr9Xvy5TK8aXkLoOXUQETnFdFepVQojyFV5gaBi5Gh4f6B6d, \"LattePanda\", 5, 1, 1 ggifepc5wqK7sCVnOIjOZy9i9kaJizalIarz7Qwe5bJ4icpLD69zWYpjAaU@sfY$, \"MeshLabTop\", 1, 5, 1 ECAI7NO893JoN3ntK7@mbniyDq0qriG82wqGKQF4s8SpXs3NdnvuHR76Bzq14Pik, \"MeshLabRight\", 1, 1, 1 fCLFeHaxQ$T6mgICdVkCdkifiU8LNJdU73YknmxfAb@0jBF2BrhTsEIBwgpoCNx$, \"DevLinux\", 1, 1, 1 hfbJ7zAgwZK@LQfsZkr1cqTSp6mjjZ3MjGC$v4X8E7HM1cZEnlGBgcorELu1hZWe, \"AmtMachine11\", 1, 1, 1 YRGm4AQVRR38Ypisuo40KhvBGhDl2pE5YCp4j4eIbLaX3kmH3tmumOUbxb44A@Rh, \"CoffeeTable\", 1, 1, 1 PpMJiPxtjRjfoEal$9RHdm5s31BaqDSbGc3329s49rzcXcVuTDvm4VO0YllO5XR7, \"DevBox\", 1, 0, 0 tyR7l2j5@wOjDeRbOQNfjU7xB$ss6VZQPDkFsALPzJ4zbTI4IamV$OdwHeqiXV0K, \"MeshLabLeft\", 1, 5, 1 i@BNTAHB5NMtDyrHMiCaz3GzYlJUUQn7qZZfh@N6271DWAM3EH6ujRNPc2snGXYX, \"raspberrypi\", 5, 1, 1 2E$CjXw2Aldh3DGAzSNo5qTSgEhd4OTWcO9KGBi9ja4EOxEUHq8J1135Y2IvxOlX, \"AmtMachine7\", 1, 5, 1 0Ab3O@4fgHjwVOpC0qaARfURTtKCa@QjxWPDpT5WQ0Wz5s4OvRWAgeoGT9j8k5JF, \"RaspberryPi\", 5, 1, 1 You can also add \u201c--count\" to just return the number of devices instead of displaying them. An example of this would be: node meshctrl listdevices --id 7b4b43cdad850135f36ab31124b52e47c167fba055\u2026 --count 13 Here we see that in a specific device group, there are 13 devices.","title":"Gathering information"},{"location":"meshctrl/#adding-and-removing-accounts","text":"MeshCtrl can be used to add and remove user accounts. This is great is you want to automate MeshCentral in some situations. Normally, an administrator can go to the \u201cMy Users\u201d tab and press \u201cNew Account\u2026\u201d button to create a new account. With MeshCtrl the same process can be accomplished using the following command line: node ./node_modules/meshcentral/meshctrl adduser --user SampleUser --pass SamplePassword This will create a basic user account with the specified \u201cSampleUser\u201d username and \u201cSamplePassword\u201d password. In addition to the basic example above, there are plenty of additional arguments that can be used. There is a list: --email [email] - New account email address. --emailverified - New account email is verified. --resetpass - Request password reset on next login. --siteadmin - Create the account as full site administrator. --manageusers - Allow this account to manage server users. --fileaccess - Allow this account to store server files. --serverupdate - Allow this account to update the server. --locked - This account will be locked. --nonewgroups - Account will not be allowed to create device groups --notools - Account not see MeshCMD download links. Instead of specifying a password, one can specify \u201c--randompass\" to have MeshCtrl generate a random password, this is typically use along with \u201c--resetpass\" and \u201c--email\" to cause the user to perform a password reset the first time a login occurs. The permission arguments are used to grant server permissions to the new account. The \u201c-- siteadmin\" argument will grant this account full site administrator rights and all other permission arguments are ignored. The other permission arguments can be combined. To remove a user account, use the following command: node ./node_modules/meshcentral/meshctrl removeuser --userid SampleId Note that when creating a new user, the username is passed in. However, when removing a user account, the userid is used. One can get the list of userid\u2019s by using the \u201cListUsers\u201d command. MeshCtrl will return \u201cok\u201d if the command is successful and the account will be added in real-time to the \u201cMy Users\u201d tab on the website.","title":"Adding and removing accounts"},{"location":"meshctrl/#creating-and-removing-device-groups","text":"MeshCtrl can be used to add and remove device groups. When a group is created, it\u2019s added in the account that MeshCtrl is logged into and that account gets full rights over that device group. Typically, a new device group is created using the \u201cAdd Device Group\u201d link in the main website. A group has a name, type and optionally a description text. To add a device group using MeshCtrl, we use the \u201cAddDeviceGroup\u201d command like this: node ./node_modules/meshcentral/meshctrl adddevicegroup --name \"Sample group name\" --desc \"Sample description\" Here we specify the name and description of the new device group. This will create a normal device group that requires agents to be installed on each computer. You can also create an agent-less Intel AMT device group by adding the \"--amtonly\" argument. Once done, MeshCtrl will return \u201cok\" and the group will be created in the logged in account in real-time. You can delete a group by using the \u201cRemoveDeviceGroup\u201d command like this: node ./node_modules/meshcentral/meshctrl removedevicegroup --id 7b4b43cd\u2026dc89fe0e581c To remove a device group, the group identifier needs to be specified. You can get that identifier using the \"ListDeviceGroups\" command. For device groups, the group identifier is a long hex value.","title":"Creating and removing device groups"},{"location":"meshctrl/#adding-and-removing-users-from-device-groups","text":"Once you created user account and device groups, the next important operation is to connect the two and grant users access to some device groups. In the web interface, this is typically done by clicking on a device group and managing the users in that page. To do this, you first have to get the user and group identifiers. You can get these using the \u201clistusers\u201d and \u201clistdevicegroups\u201d commands. Then, you can for example do this: node ./node_modules/meshcentral/meshctrl addusertodevicegroup --id 7b4b43cd\u2026dc89fe0e581c --userid bob --fullrights Typically, the group identifier is a long hex value. The command will add user \u201cbob\u201d to a given group with full rights. You can also add a user to a group with only some rights, the list is as follows: --fullrights - Allow full rights over this device group. --editgroup - Allow the user to edit group information. --manageusers - Allow the user to add/remove users. --managedevices - Allow the user to edit device information. --remotecontrol - Allow device remote control operations. --agentconsole - Allow agent console operations. --serverfiles - Allow access to group server files. --wakedevices - Allow device wake operation. --notes - Allow editing of device notes. --desktopviewonly - Restrict user to view-only remote desktop. --limiteddesktop - Limit remote desktop keys. --noterminal - Hide the terminal tab from this user. --nofiles - Hide the files tab from this user. --noamt - Hide the Intel AMT tab from this user. Note that if \u201cfullrights\u201d are granted, all other access right arguments are ignored. If successful, MeshCtrl will display \u201cok\u201d, otherwise it will show an error message. To remove a user from a group, use the \u201cremoveuserfromdevicegroup\u201d command. For example: node ./node_modules/meshcentral/meshctrl removeuserfromdevicegroup --id 7b4b43cd\u2026dc89fe0e581c --userid bob The syntax of this command is identical to the \u201caddusertodevicegroup\u201d command, but there are no rights arguments. MeshCtrl will also display \u201cok\u201d if the command got processed correctly.","title":"Adding and removing users from device groups"},{"location":"meshctrl/#message-broadcast","text":"One fun command the MeshCtrl offers is the \u201cbroadcast\u201d command. It sends a short notification message that all connected users will see in real-time. For example, you can do this: node ./node\\_modules/meshcentral/meshctrl broadcast --msg \"This is a test\" All connected users will see this: The broadcast command is great for notifying users of upcoming server downtime or other events.","title":"Message Broadcast"},{"location":"meshctrl/#conclusion","text":"MeshCtrl is an essential tools in every MeshCentral administrator\u2019s tool box. It allows administrators to automate various MeshCentral management tasks which can be useful for large scale management of many devices and users.","title":"Conclusion"},{"location":"meshctrl/#license","text":"MeshCtrl and this document are both opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0","title":"License"},{"location":"meshrouter/","text":"MeshCentral Router \u00b6 MeshCentral Router Guide as .pdf as .odt Video Walkthru \u00b6 Abstract \u00b6 This document takes a look at MeshCentral Router, a Windows application that performs TCP and UDP port mapping from a local machine to any remote computer thru a MeshCentral servers. This document should allow the user to Internet relay traffic thru NAT routers and firewalls. Introduction \u00b6 MeshCentral is a remote management web site that connects users to remote computers over a local network or the internet. In addition to remote management features, MeshCentral is capable of relaying TCP and UDP traffic thru the server and thru mesh agents installed on remote computers. This feature can be useful to, for example, perform a remote desktop session using RDP or route custom traffic that would otherwise be difficult to route. Downloading \u00b6 MeshCentral router is a Windows application that comes built-into the MeshCentral server or can be downloaded at: http://info.meshcentral.com/downloads/MeshCentral2/MeshCentralRouter.exe It\u2019s probably best to use the MeshCentral router that comes with your version of the MeshCentral server as the two will likely be most compatible. A given MeshCentral Router version may not work with any MeshCentral server versions. On MeshCentral, you can download MeshCentral Router with this link: The router link will only show up on Windows browsers. Login \u00b6 MeshCentral router will need to login to your MeshCentral server just like any browser. You can do this by entering the server name and account username and password. Depending on your server and account situation, you may see some or all of the following screens. If the second factor authentication is required, MeshCentral Router does not support hardware keys (WebAuthn), but does support the YubiKey\u2122 OTP. Creating Port Maps \u00b6 Once logged in, you can start adding port maps using the \u201cAdd Map\u2026\u201d and \u201cAdd Relay Map\u2026\u201d buttons on the bottom right. You can then create a map and open the associated application using the \u201cOpen\u2026\u201d button and remote to port map using the \u201cRemove\u201d button. There are two different types of ports mappings. A normal port map and a relay port map. A normal port map will route packets to the selected destination computer that is running the mesh agent as shown here. A relay port map will route traffic thru the server and thru the remote agent to a target IP address on the remote agent\u2019s network as shown here. Note that all traffic is encrypted using TLS from MeshCentral Router to the MeshCentral server and from the server to the MeshAgent. The server and the agent do have access the traffic so it\u2019s recommended to use port mappings to tunnel data that is also encrypted for that end-to-end encryption is assured. Custom Apps \u00b6 Starting v1.0.21 Command Line Arguments \u00b6 MeshCentral router can be run with command line arguments to make it quicker and easier to use. The arguments range from debugging to being able to quickly login and setting up port maps. -debug Causes MeshCentral Router to generate a \u201cdebug.log\u201d dump file that can be useful for debugging. -host:<hostname> -user:<username> -pass:<password> -ignorecert This set of command line arguments make logging into the MeshCentral server easier. Note that specifying the password using a command line argument may not be secure as the command shell can record the password in the command history. The \u201cignorecert\u201d argument is not recommended as it\u2019s going to cause MeshCentral Router to ignore untrusted server certificates. This should only be used for debugging. -map:<protocol>:<localport>:<computername>:<app>:<remoteport> The \u201cmap\u201d argument will automatically create a network map once MeshCentral Router is logged In. The protocol must be \u201cTCP\u201d or \u201cUDP, the local port can be 0 for any. The computer name is the server-side name of the computer, if many computers have the same one, one of them will be selected. The app can be empty for a custom application, or can be \u201cHTTP\u201d, \u201cHTTPS\u201d, \u201cRDP\u201d, \u201cPuTTY\u201d or \u201cWinSCP\u201d. For the UDP protocol, no apps are currently supported so it should be left blank. For example you can use: -map:TCP:0: \"MyComputer\" :HTTP:80 -map:UDP:1235: \"MyComputer\" ::1234 The first example will map a random local port to port 80 of \u201cMyComputer\u201d and is expected for use with HTTP traffic. The second example maps local UDP port 1235 to port 1234 on \u201cMyComputer\u201d. It\u2019s best for the computer name to be in quotes. In addition to port mapping, you can also setup relay maps where a remote computer is used as a traffic relay like this: -relaymap:<protocol>:<localport>:<computername> :<app>:<remoteip>:<remoteport> This will relays a local port to thru the server and thru a remote agent to a target IP address and port. For example: -relaymap:TCP:555: \"MyComputer\" :HTTP:192.168.1.1:80 This will relay local port 555 to a 192.168.1.1:80 for HTTP traffic. A typical use of this is to be able to remotely configure a home router from anywhere on the Internet. -all The \u201call\u201d switch will bind local ports to all network interfaces so that other computers on the network can use the port maps provided by MeshCentral Router. By default, local ports will be bound to the loopback interface so that only local application can use the port mappings. -tray The \u201ctray\u201d switch will place MeshCentral Router on the Windows system tray instead of the normal application bar. MeshCentral Router with SAML or OAuth \u00b6 You can't use the MeshCentral Router (MCR) login dialog box to login to a server that uses SAML or OAuth. However, you can still use MCR Download MCR and run it. In the first dialog box, there will be an \"Install...\" button to setup MeshCentral router with the \"mcrouter://\" protocol in your system registry. Once done, close MCR. Now log into the web UI of your MeshCentral server. Go in the bottom of the \"My Devices\" tab, hit the \"Router\" link and hit \"Launch MeshCentral Router\". This will launch the router and connect directly to your server using a login cookie. Note The only drawback is you will have to manually load mappings saved in an .mcrouter file. When not using SAML, you can click on the .mcrouter file to load the mappings and MCR at the same time. Conclusion \u00b6 MeshCentral Router is a free, open source tool for routing TCP and UDP traffic over the internet. It\u2019s a powerful as it allows for any traffic to go thru NAT routers and firewalls while being encrypted using TLS. License \u00b6 MeshCentral, MeshCentral Router and this document are all opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0 .","title":"MeshCentral Router"},{"location":"meshrouter/#meshcentral-router","text":"MeshCentral Router Guide as .pdf as .odt","title":"MeshCentral Router"},{"location":"meshrouter/#video-walkthru","text":"","title":"Video Walkthru"},{"location":"meshrouter/#abstract","text":"This document takes a look at MeshCentral Router, a Windows application that performs TCP and UDP port mapping from a local machine to any remote computer thru a MeshCentral servers. This document should allow the user to Internet relay traffic thru NAT routers and firewalls.","title":"Abstract"},{"location":"meshrouter/#introduction","text":"MeshCentral is a remote management web site that connects users to remote computers over a local network or the internet. In addition to remote management features, MeshCentral is capable of relaying TCP and UDP traffic thru the server and thru mesh agents installed on remote computers. This feature can be useful to, for example, perform a remote desktop session using RDP or route custom traffic that would otherwise be difficult to route.","title":"Introduction"},{"location":"meshrouter/#downloading","text":"MeshCentral router is a Windows application that comes built-into the MeshCentral server or can be downloaded at: http://info.meshcentral.com/downloads/MeshCentral2/MeshCentralRouter.exe It\u2019s probably best to use the MeshCentral router that comes with your version of the MeshCentral server as the two will likely be most compatible. A given MeshCentral Router version may not work with any MeshCentral server versions. On MeshCentral, you can download MeshCentral Router with this link: The router link will only show up on Windows browsers.","title":"Downloading"},{"location":"meshrouter/#login","text":"MeshCentral router will need to login to your MeshCentral server just like any browser. You can do this by entering the server name and account username and password. Depending on your server and account situation, you may see some or all of the following screens. If the second factor authentication is required, MeshCentral Router does not support hardware keys (WebAuthn), but does support the YubiKey\u2122 OTP.","title":"Login"},{"location":"meshrouter/#creating-port-maps","text":"Once logged in, you can start adding port maps using the \u201cAdd Map\u2026\u201d and \u201cAdd Relay Map\u2026\u201d buttons on the bottom right. You can then create a map and open the associated application using the \u201cOpen\u2026\u201d button and remote to port map using the \u201cRemove\u201d button. There are two different types of ports mappings. A normal port map and a relay port map. A normal port map will route packets to the selected destination computer that is running the mesh agent as shown here. A relay port map will route traffic thru the server and thru the remote agent to a target IP address on the remote agent\u2019s network as shown here. Note that all traffic is encrypted using TLS from MeshCentral Router to the MeshCentral server and from the server to the MeshAgent. The server and the agent do have access the traffic so it\u2019s recommended to use port mappings to tunnel data that is also encrypted for that end-to-end encryption is assured.","title":"Creating Port Maps"},{"location":"meshrouter/#custom-apps","text":"Starting v1.0.21","title":"Custom Apps"},{"location":"meshrouter/#command-line-arguments","text":"MeshCentral router can be run with command line arguments to make it quicker and easier to use. The arguments range from debugging to being able to quickly login and setting up port maps. -debug Causes MeshCentral Router to generate a \u201cdebug.log\u201d dump file that can be useful for debugging. -host:<hostname> -user:<username> -pass:<password> -ignorecert This set of command line arguments make logging into the MeshCentral server easier. Note that specifying the password using a command line argument may not be secure as the command shell can record the password in the command history. The \u201cignorecert\u201d argument is not recommended as it\u2019s going to cause MeshCentral Router to ignore untrusted server certificates. This should only be used for debugging. -map:<protocol>:<localport>:<computername>:<app>:<remoteport> The \u201cmap\u201d argument will automatically create a network map once MeshCentral Router is logged In. The protocol must be \u201cTCP\u201d or \u201cUDP, the local port can be 0 for any. The computer name is the server-side name of the computer, if many computers have the same one, one of them will be selected. The app can be empty for a custom application, or can be \u201cHTTP\u201d, \u201cHTTPS\u201d, \u201cRDP\u201d, \u201cPuTTY\u201d or \u201cWinSCP\u201d. For the UDP protocol, no apps are currently supported so it should be left blank. For example you can use: -map:TCP:0: \"MyComputer\" :HTTP:80 -map:UDP:1235: \"MyComputer\" ::1234 The first example will map a random local port to port 80 of \u201cMyComputer\u201d and is expected for use with HTTP traffic. The second example maps local UDP port 1235 to port 1234 on \u201cMyComputer\u201d. It\u2019s best for the computer name to be in quotes. In addition to port mapping, you can also setup relay maps where a remote computer is used as a traffic relay like this: -relaymap:<protocol>:<localport>:<computername> :<app>:<remoteip>:<remoteport> This will relays a local port to thru the server and thru a remote agent to a target IP address and port. For example: -relaymap:TCP:555: \"MyComputer\" :HTTP:192.168.1.1:80 This will relay local port 555 to a 192.168.1.1:80 for HTTP traffic. A typical use of this is to be able to remotely configure a home router from anywhere on the Internet. -all The \u201call\u201d switch will bind local ports to all network interfaces so that other computers on the network can use the port maps provided by MeshCentral Router. By default, local ports will be bound to the loopback interface so that only local application can use the port mappings. -tray The \u201ctray\u201d switch will place MeshCentral Router on the Windows system tray instead of the normal application bar.","title":"Command Line Arguments"},{"location":"meshrouter/#meshcentral-router-with-saml-or-oauth","text":"You can't use the MeshCentral Router (MCR) login dialog box to login to a server that uses SAML or OAuth. However, you can still use MCR Download MCR and run it. In the first dialog box, there will be an \"Install...\" button to setup MeshCentral router with the \"mcrouter://\" protocol in your system registry. Once done, close MCR. Now log into the web UI of your MeshCentral server. Go in the bottom of the \"My Devices\" tab, hit the \"Router\" link and hit \"Launch MeshCentral Router\". This will launch the router and connect directly to your server using a login cookie. Note The only drawback is you will have to manually load mappings saved in an .mcrouter file. When not using SAML, you can click on the .mcrouter file to load the mappings and MCR at the same time.","title":"MeshCentral Router with SAML or OAuth"},{"location":"meshrouter/#conclusion","text":"MeshCentral Router is a free, open source tool for routing TCP and UDP traffic over the internet. It\u2019s a powerful as it allows for any traffic to go thru NAT routers and firewalls while being encrypted using TLS.","title":"Conclusion"},{"location":"meshrouter/#license","text":"MeshCentral, MeshCentral Router and this document are all opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0 .","title":"License"},{"location":"other/adfs_sso_guide/","text":"ADFS SSO Guide \u00b6 Assumptions \u00b6 The following guide was built under the assumptions that: ADFS 4.0 running on Server 2016 using Active Directory Main ADFS setup already completed / working. SSL certs installed and port forwarded as expected. The guide was built to deal specifically with adding mesh as a Relying Party. I\u2019m far from an ADFS expert and some configurations may not be needed. Most of this was built by reading the code and taking guesses as to the needed values. Guide \u00b6 As with anything SSO, you need 2 pieces \u2013 the IDP setup (in this case ADFS) and the SP setup (in this case Mesh). Mesh Setup \u00b6 Add the following to your mesh config file in the domains part: Callback URL : Should be the FQDN for your Mesh Server, ending with /auth-saml-callback Entity ID : This is how ADFS IDs which party the request goes to. You can set this to whatever you want, but you will need this value later on when working in ADFS. IDP URL : This is the URL to ADFS. Ends with /adfs/ls unless you did something very weird in ADFS. Cert : You will need to export the token signing cert from ADFS, then convert it to PEM format. This cert can be found in ADFS -> Service -> Certificates . You can use this openssl command to convert it from CRT to PEM format: openssl x509 -in mycert.crt -out mycert.pem -outform PEM Save the config and restart the mesh server. Windows Server Configuration \u00b6 ADFS setup (in pictures): Relying Party Trust -> New Relying Party Trust Edit the new \u201cRelying Party Trust\u201d Properties: Then it\u2019s time to add Claims\u2026 For the outgoing claim type, where it says firstname, lastname, and email, manually type it in as shown. All other fields should be selected from the dropdown. Add another rule: For all fields, select from the dropdowns","title":"ADFS SSO Guide"},{"location":"other/adfs_sso_guide/#adfs-sso-guide","text":"","title":"ADFS SSO Guide"},{"location":"other/adfs_sso_guide/#assumptions","text":"The following guide was built under the assumptions that: ADFS 4.0 running on Server 2016 using Active Directory Main ADFS setup already completed / working. SSL certs installed and port forwarded as expected. The guide was built to deal specifically with adding mesh as a Relying Party. I\u2019m far from an ADFS expert and some configurations may not be needed. Most of this was built by reading the code and taking guesses as to the needed values.","title":"Assumptions"},{"location":"other/adfs_sso_guide/#guide","text":"As with anything SSO, you need 2 pieces \u2013 the IDP setup (in this case ADFS) and the SP setup (in this case Mesh).","title":"Guide"},{"location":"other/adfs_sso_guide/#mesh-setup","text":"Add the following to your mesh config file in the domains part: Callback URL : Should be the FQDN for your Mesh Server, ending with /auth-saml-callback Entity ID : This is how ADFS IDs which party the request goes to. You can set this to whatever you want, but you will need this value later on when working in ADFS. IDP URL : This is the URL to ADFS. Ends with /adfs/ls unless you did something very weird in ADFS. Cert : You will need to export the token signing cert from ADFS, then convert it to PEM format. This cert can be found in ADFS -> Service -> Certificates . You can use this openssl command to convert it from CRT to PEM format: openssl x509 -in mycert.crt -out mycert.pem -outform PEM Save the config and restart the mesh server.","title":"Mesh Setup"},{"location":"other/adfs_sso_guide/#windows-server-configuration","text":"ADFS setup (in pictures): Relying Party Trust -> New Relying Party Trust Edit the new \u201cRelying Party Trust\u201d Properties: Then it\u2019s time to add Claims\u2026 For the outgoing claim type, where it says firstname, lastname, and email, manually type it in as shown. All other fields should be selected from the dropdown. Add another rule: For all fields, select from the dropdowns","title":"Windows Server Configuration"},{"location":"other/meshcentral_satellite/","text":"MeshCentral Satellite \u00b6 Coming Soon Abstract \u00b6 MeshCentral Satellite is a Windows application that acts as a relay between a Windows Active Directory Domain and a MeshCentral Server. Once setup, the MeshCentral server can request that MeshCentral Satellite create an 802.1x computer profile for Intel AMT in the domain, or ask a certificate authority to issue or revoke a certificate. Introduction \u00b6 A MeshCentral server can run in the cloud on a Linux server, but it may occasionally need to interact with a domain controller to perform some operations. MeshCentral Satellite is built to perform this function. MeshCentral Satellite is a Windows application built in C# and must run on a computer that is part of a domain and must run with sufficient rights to perform LDAP object addition and removal. If a certificate authority (CA) needs to be used, MeshCentral Satellite needs to have sufficient rights to ask the CA issue or revoke certificates. MeshCentral Satellite should run on a computer that is always on. Once running, it will attempt to connect to the MeshCentral server and keep the connection open awaiting requests. Currently, MeshCentral Satellite can perform four operations on behalf of the MeshCentral server: Create an Intel AMT domain computer. Remove an Intel AMT domain computer. Issue a certificate for Intel AMT. Revoke an Intel AMT certificate. MeshCentral Satellite can run both as a standalone application which is practical to get started and it can be setup as a background Windows Service for long term operations. To get started, we will run it as a standalone application and start working on getting it setup. Installation and Configuration \u00b6 Start by creating an empty folder on a computer that is part of the domain you need to interact with. For example, create a \u201cc:\\MeshCentralSatellite\u201d then copy \u201cMeshCentralSatellite.exe\u201d into that folder. You can find that executable in the \u201cnode_modules/meshcentral/agents\u201d folder of your server. If it\u2019s not present, update your server to the latest version and look again. Once started you should see something this: Go in the file menu and select \u201cSettings\u2026\u201d, this is where all of the MeshCentral Satellite setting are. It includes sections to connect to your MeshCentral server. Security groups you want device to join and Certificate settings. First, enter your MeshCentral server hostname and username and password. MeshCentral Satellite can\u2019t use two-factor authentication (2FA) so you need to create a user account in MeshCentral for Satellite or you can create a login token in the \u201cMy Account\u201d section of MeshCentral with an unlimited expire time and cut & paste the username and password given into MeshCentral Satellite. If your MeshCentral server is a test server that does not have a real TLS certificate, you can opt to ignore the TLS certificate on connection but this is not secure and so, not recommended. The \u201cDevice Name\u201d has two options, \u201cOperating System Name\u201d or \u201cNode Identifier\u201d. If you opt for \u201cOperating System Name\u201d, Intel AMT devices will show as, for example, \u201ciME-ComputerName\u201d in the list of domain computers. If \u201cnode identifier\u201d is used, Intel AMT devices will look like \u201ciME-xxxxxxxxxxx\u201d where xxx is the start of the MeshCentral node identifier for this device. Using the node identifier is more secure as it can\u2019t easily be replicate by any other device. The operating system name would be impersonated by another device causing various security issues. The security groups section will list any security groups created until the \u201cComputers\u201d section of the domain controller. Checking one or more of these security groups will automatically going new Intel AMT devices to these groups. Lastly, we have the certificate authority and certificate settings. If a certificate authority needs to used, enter the name of the CA which is in the format \u201c \\ \u201d you can then hit the check box next to the name and select the certificate template to use. For certificate configuration, you can leave it as-is with \u201cSAM Account Name\u201d and the common name and all alternative names selected. Once done, you can hit ok. The settings will be saved in a file called \u201cconfig.txt\u201d in plain text in the same folder as \u201cMeshCentralSatellite.exe\u201d. Make sure not to grant access to this file to anyone not authorized to do so as it will have the MeshCentral login username and password. Once done, select \u201cLocal Connect\u201d the \u201cFiles\u201d menu to connect to the MeshCentral server. MeshCentral Satellite should be connected and ready to receive commands from the server. Checking the connection \u00b6 In order to make sure the server correctly recognizes the MeshCentral Satellite connection, you can go to the server console and type \u201cusersession\u201d. The Satellite session should be marked. Currently, you should only have a single satellite session per user. In the future, multiple sessions could be supported for redundancy. Configuring Intel\u00ae AMT 802.1x \u00b6 To start using MeshCentral Satellite, you can configure Intel AMT with an 802.1x profile, this is done in the domain section of the config.json. Here is an example of an 802.1x EAP-TLS profile that will require that Intel AMT be issued a certificate: \"AmtManager\": { \"802.1x\": { \"AuthenticationProtocol\": \"EAP-TLS\", \"SatelliteCredentials\": \"admin\" }, \"WifiProfiles\": [ { \"ssid\": \"Network-8021x\", \"authentication\": \"wpa2-802.1x\", \"encryption\": \"ccmp-aes\" } ] } In this following example, MSCHAPv2 is used and so, MeshCentral Satellite will need to generate a random password, save it in the active directory and send the password back to MeshCentral for Intel AMT configuration: \"AmtManager\": { \"802.1x\": { \"AuthenticationProtocol\": \"PEAPv0/EAP-MSCHAPv2\", \"SatelliteCredentials\": \"admin\" }, \"WifiProfiles\": [ { \"ssid\": \"Network-8021x\", \"authentication\": \"wpa2-802.1x\", \"encryption\": \"ccmp-aes\" } ] } The second example does not require that a certificate authority be setup, the first example does. In both cases, the WIFI profile is set to \u201cwpa2-802.1x\u201d and so, the 802.1x profile will be setup for both the Intel AMT wired interface and the specified WIFI profile for wireless. Note that is both examples, \u201cSatelliteCredentials\u201d indicates the account name that MeshCentral Satellite will be connected on. In our case, we used the \u201cadmin\u201d account that matches the account configuration we used in sections 3 and 4. Make these changes to the config.json and restart the MeshCentral server. Once done, any device groups that are set to configure Intel AMT will generate operations for MeshCentral Satellite. Computer and certificate operations \u00b6 Once MeshCentral and MeshCentral Satellite are setup, make sure a device group has an active Intel AMT policy. In the example below, we have a device group with an Admin Control Mode (ACM) activation policy. Computers connecting to this device group will automatically be setup with the new 802.1x and WIFI profile, but you can go in an agent console and type \u201camtconfig\u201d to force the check of the Intel AMT configuration. In our case, it looks like this: MeshCentral is adding a new WIFI profile, setting up 802.1x and issuing a new Intel AMT certificate from the domain CA. This was all done in a few seconds. On the MeshCentral Satellite side, we see this: The MeshCentral Satellite received an 802.1x EAP-TLS request. It asked Intel AMT to generate a RSA key pair, to sign a certificate request, forwarded the request to the domain CA for signature and finally returned the final certificate to Intel AMT. The computer account in the domain was also updated and looks like this: The new Intel AMT device was added to the domain along with the Intel AMT version and node identifier in the description. If \u201cNode Identifier\u201d was selected as the computer name in MeshCentral Satellite settings, the friendly name would be in the description and the node identifier would be used as the device name. Finally, it\u2019s worth taking a look at how Intel AMT was configured before and after this operation. Before setting up the 802.1x profile, Intel AMT looked like this: Note that there is no 802.1x profiles or WIFI profiles. After the new configuration, MeshCommander shows Intel AMT looking like this: There are now two new certificates in the \u201cSecurity\u201d tab. One if the root of the domain CA, the other is the certificate assigned to the Intel AMT device by the CA. You also see the WIFI 802.1x profile. In this example, the device did not have a wired network interface, but if it did, 802.1x would also be setup for the wired interface. Running as a Background Service \u00b6 MeshCentral Satellite can be run as a background service. This is useful when running for lang periods on a domain server. You can use the \u201cService\u201d menu in MeshCentral Satellite to install, start, stop and uninstall the Windows service. Make sure to come and run \u201cMeshCentralSatellite.exe\u201d from the correct location you want to install the Windows Service from. Since MeshCentral Satellite need to have domain rights to add and remove computer objects from the active directory and to have certificate authority (CA) rights, you may want to install the service, go in the service manager and change the \u201cLog On\u201d account to one with the proper rights. Once set, you can start the service from within MeshCentral Satellite. Once the service is started, there is a communication channel that will be create with the local application so you can still monitor what the service is doing. The lines starting with \u201cService:\u201c are coming from the background service. At this point, you can close the local application and the service will keep running in the background. License \u00b6 MeshCentral, MeshCentral Satellite and this document are both opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0 .","title":"MeshCentral Satellite"},{"location":"other/meshcentral_satellite/#meshcentral-satellite","text":"Coming Soon","title":"MeshCentral Satellite"},{"location":"other/meshcentral_satellite/#abstract","text":"MeshCentral Satellite is a Windows application that acts as a relay between a Windows Active Directory Domain and a MeshCentral Server. Once setup, the MeshCentral server can request that MeshCentral Satellite create an 802.1x computer profile for Intel AMT in the domain, or ask a certificate authority to issue or revoke a certificate.","title":"Abstract"},{"location":"other/meshcentral_satellite/#introduction","text":"A MeshCentral server can run in the cloud on a Linux server, but it may occasionally need to interact with a domain controller to perform some operations. MeshCentral Satellite is built to perform this function. MeshCentral Satellite is a Windows application built in C# and must run on a computer that is part of a domain and must run with sufficient rights to perform LDAP object addition and removal. If a certificate authority (CA) needs to be used, MeshCentral Satellite needs to have sufficient rights to ask the CA issue or revoke certificates. MeshCentral Satellite should run on a computer that is always on. Once running, it will attempt to connect to the MeshCentral server and keep the connection open awaiting requests. Currently, MeshCentral Satellite can perform four operations on behalf of the MeshCentral server: Create an Intel AMT domain computer. Remove an Intel AMT domain computer. Issue a certificate for Intel AMT. Revoke an Intel AMT certificate. MeshCentral Satellite can run both as a standalone application which is practical to get started and it can be setup as a background Windows Service for long term operations. To get started, we will run it as a standalone application and start working on getting it setup.","title":"Introduction"},{"location":"other/meshcentral_satellite/#installation-and-configuration","text":"Start by creating an empty folder on a computer that is part of the domain you need to interact with. For example, create a \u201cc:\\MeshCentralSatellite\u201d then copy \u201cMeshCentralSatellite.exe\u201d into that folder. You can find that executable in the \u201cnode_modules/meshcentral/agents\u201d folder of your server. If it\u2019s not present, update your server to the latest version and look again. Once started you should see something this: Go in the file menu and select \u201cSettings\u2026\u201d, this is where all of the MeshCentral Satellite setting are. It includes sections to connect to your MeshCentral server. Security groups you want device to join and Certificate settings. First, enter your MeshCentral server hostname and username and password. MeshCentral Satellite can\u2019t use two-factor authentication (2FA) so you need to create a user account in MeshCentral for Satellite or you can create a login token in the \u201cMy Account\u201d section of MeshCentral with an unlimited expire time and cut & paste the username and password given into MeshCentral Satellite. If your MeshCentral server is a test server that does not have a real TLS certificate, you can opt to ignore the TLS certificate on connection but this is not secure and so, not recommended. The \u201cDevice Name\u201d has two options, \u201cOperating System Name\u201d or \u201cNode Identifier\u201d. If you opt for \u201cOperating System Name\u201d, Intel AMT devices will show as, for example, \u201ciME-ComputerName\u201d in the list of domain computers. If \u201cnode identifier\u201d is used, Intel AMT devices will look like \u201ciME-xxxxxxxxxxx\u201d where xxx is the start of the MeshCentral node identifier for this device. Using the node identifier is more secure as it can\u2019t easily be replicate by any other device. The operating system name would be impersonated by another device causing various security issues. The security groups section will list any security groups created until the \u201cComputers\u201d section of the domain controller. Checking one or more of these security groups will automatically going new Intel AMT devices to these groups. Lastly, we have the certificate authority and certificate settings. If a certificate authority needs to used, enter the name of the CA which is in the format \u201c \\ \u201d you can then hit the check box next to the name and select the certificate template to use. For certificate configuration, you can leave it as-is with \u201cSAM Account Name\u201d and the common name and all alternative names selected. Once done, you can hit ok. The settings will be saved in a file called \u201cconfig.txt\u201d in plain text in the same folder as \u201cMeshCentralSatellite.exe\u201d. Make sure not to grant access to this file to anyone not authorized to do so as it will have the MeshCentral login username and password. Once done, select \u201cLocal Connect\u201d the \u201cFiles\u201d menu to connect to the MeshCentral server. MeshCentral Satellite should be connected and ready to receive commands from the server.","title":"Installation and Configuration"},{"location":"other/meshcentral_satellite/#checking-the-connection","text":"In order to make sure the server correctly recognizes the MeshCentral Satellite connection, you can go to the server console and type \u201cusersession\u201d. The Satellite session should be marked. Currently, you should only have a single satellite session per user. In the future, multiple sessions could be supported for redundancy.","title":"Checking the connection"},{"location":"other/meshcentral_satellite/#configuring-intel-amt-8021x","text":"To start using MeshCentral Satellite, you can configure Intel AMT with an 802.1x profile, this is done in the domain section of the config.json. Here is an example of an 802.1x EAP-TLS profile that will require that Intel AMT be issued a certificate: \"AmtManager\": { \"802.1x\": { \"AuthenticationProtocol\": \"EAP-TLS\", \"SatelliteCredentials\": \"admin\" }, \"WifiProfiles\": [ { \"ssid\": \"Network-8021x\", \"authentication\": \"wpa2-802.1x\", \"encryption\": \"ccmp-aes\" } ] } In this following example, MSCHAPv2 is used and so, MeshCentral Satellite will need to generate a random password, save it in the active directory and send the password back to MeshCentral for Intel AMT configuration: \"AmtManager\": { \"802.1x\": { \"AuthenticationProtocol\": \"PEAPv0/EAP-MSCHAPv2\", \"SatelliteCredentials\": \"admin\" }, \"WifiProfiles\": [ { \"ssid\": \"Network-8021x\", \"authentication\": \"wpa2-802.1x\", \"encryption\": \"ccmp-aes\" } ] } The second example does not require that a certificate authority be setup, the first example does. In both cases, the WIFI profile is set to \u201cwpa2-802.1x\u201d and so, the 802.1x profile will be setup for both the Intel AMT wired interface and the specified WIFI profile for wireless. Note that is both examples, \u201cSatelliteCredentials\u201d indicates the account name that MeshCentral Satellite will be connected on. In our case, we used the \u201cadmin\u201d account that matches the account configuration we used in sections 3 and 4. Make these changes to the config.json and restart the MeshCentral server. Once done, any device groups that are set to configure Intel AMT will generate operations for MeshCentral Satellite.","title":"Configuring Intel\u00ae AMT 802.1x"},{"location":"other/meshcentral_satellite/#computer-and-certificate-operations","text":"Once MeshCentral and MeshCentral Satellite are setup, make sure a device group has an active Intel AMT policy. In the example below, we have a device group with an Admin Control Mode (ACM) activation policy. Computers connecting to this device group will automatically be setup with the new 802.1x and WIFI profile, but you can go in an agent console and type \u201camtconfig\u201d to force the check of the Intel AMT configuration. In our case, it looks like this: MeshCentral is adding a new WIFI profile, setting up 802.1x and issuing a new Intel AMT certificate from the domain CA. This was all done in a few seconds. On the MeshCentral Satellite side, we see this: The MeshCentral Satellite received an 802.1x EAP-TLS request. It asked Intel AMT to generate a RSA key pair, to sign a certificate request, forwarded the request to the domain CA for signature and finally returned the final certificate to Intel AMT. The computer account in the domain was also updated and looks like this: The new Intel AMT device was added to the domain along with the Intel AMT version and node identifier in the description. If \u201cNode Identifier\u201d was selected as the computer name in MeshCentral Satellite settings, the friendly name would be in the description and the node identifier would be used as the device name. Finally, it\u2019s worth taking a look at how Intel AMT was configured before and after this operation. Before setting up the 802.1x profile, Intel AMT looked like this: Note that there is no 802.1x profiles or WIFI profiles. After the new configuration, MeshCommander shows Intel AMT looking like this: There are now two new certificates in the \u201cSecurity\u201d tab. One if the root of the domain CA, the other is the certificate assigned to the Intel AMT device by the CA. You also see the WIFI 802.1x profile. In this example, the device did not have a wired network interface, but if it did, 802.1x would also be setup for the wired interface.","title":"Computer and certificate operations"},{"location":"other/meshcentral_satellite/#running-as-a-background-service","text":"MeshCentral Satellite can be run as a background service. This is useful when running for lang periods on a domain server. You can use the \u201cService\u201d menu in MeshCentral Satellite to install, start, stop and uninstall the Windows service. Make sure to come and run \u201cMeshCentralSatellite.exe\u201d from the correct location you want to install the Windows Service from. Since MeshCentral Satellite need to have domain rights to add and remove computer objects from the active directory and to have certificate authority (CA) rights, you may want to install the service, go in the service manager and change the \u201cLog On\u201d account to one with the proper rights. Once set, you can start the service from within MeshCentral Satellite. Once the service is started, there is a communication channel that will be create with the local application so you can still monitor what the service is doing. The lines starting with \u201cService:\u201c are coming from the background service. At this point, you can close the local application and the service will keep running in the background.","title":"Running as a Background Service"},{"location":"other/meshcentral_satellite/#license","text":"MeshCentral, MeshCentral Satellite and this document are both opens source and licensed using Apache 2.0, the full license can be found at https://www.apache.org/licenses/LICENSE-2.0 .","title":"License"}]}